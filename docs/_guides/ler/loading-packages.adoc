---
title: Loading Packages
parent: LER Packages
grand_parent: Guides
nav_order: 2
---

= Loading Packages

== Purpose

This guide explains how to load LER packages into your applications using both
the Ruby API and CLI commands. Loading pre-built packages is significantly
faster than parsing raw EXPRESS files.

== References

* link:index.html[LER Packages Overview]
* link:creating-packages.html[Creating Packages]
* link:querying-packages.html[Querying Packages]
* link:../ruby-api/working-with-repository.html[Working with Repository]

== Concepts

Package loading:: The process of reading a LER package file and deserializing
its contents into a [`Repository`](../../lib/expressir/model/repository.rb)
instance.

Package reader:: The [`Expressir::Package::Reader`](../../lib/expressir/package/reader.rb)
class responsible for loading LER packages.

Deserialization:: Converting serialized data (Marshal, YAML, or JSON) back
into Ruby objects.

Pre-built indexes:: Entity, type, and reference indexes stored in the package
that are loaded directly without rebuilding.

== Loading packages via Ruby API

=== Basic package loading

Use [`Repository.from_package`](../../lib/expressir/model/repository.rb:256)
to load a LER package:

[source,ruby]
----
require "expressir"

# Load package
repo = Expressir::Model::Repository.from_package("schemas.ler")

# Package is ready to use
puts "Loaded #{repo.schemas.size} schemas"
----

The repository is fully initialized with:

* All schemas loaded and resolved
* Pre-built indexes ready for queries
* All references resolved

=== Using Package::Reader directly

For more control, use the [`Package::Reader`](../../lib/expressir/package/reader.rb:10)
class:

[source,ruby]
----
require "expressir/package/reader"

# Load using reader
reader = Expressir::Package::Reader.new
repo = reader.load("schemas.ler")

# Or use class method
repo = Expressir::Package::Reader.load("schemas.ler")
----

=== Accessing loaded data

Once loaded, use the repository normally:

[source,ruby]
----
# Load package
repo = Expressir::Model::Repository.from_package("schemas.ler")

# Access schemas
repo.schemas.each do |schema|
  puts "Schema: #{schema.id}"
  puts "  Entities: #{schema.entities&.size || 0}"
  puts "  Types: #{schema.types&.size || 0}"
end

# Use pre-built indexes
entity = repo.find_entity(qualified_name: "action_schema.action")
puts "Found entity: #{entity.id}" if entity

# List entities
entities = repo.list_entities
puts "Total entities: #{entities.size}"
----

=== Loading with error handling

Handle loading errors gracefully:

[source,ruby]
----
begin
  repo = Expressir::Model::Repository.from_package("schemas.ler")
  puts "✓ Package loaded successfully"
rescue ArgumentError => e
  puts "Error: #{e.message}"
  # Package file not found
rescue StandardError => e
  puts "Loading error: #{e.message}"
  # Corrupted package or incompatible format
end
----

=== Measuring load time

Track loading performance:

[source,ruby]
----
require "benchmark"

load_time = Benchmark.realtime do
  @repo = Expressir::Model::Repository.from_package("large_schemas.ler")
end

puts "Load time: #{(load_time * 1000).round(2)} ms"
puts "Schemas: #{@repo.schemas.size}"
puts "Entities: #{@repo.list_entities.size}"
----

== Loading packages via CLI

=== Package information

View package contents without full loading:

[source,bash]
----
# Show package metadata and statistics
expressir package info schemas.ler

# Output in JSON format
expressir package info schemas.ler --format json

# Output in YAML format
expressir package info schemas.ler --format yaml
----

.Example output
[example]
====
[source]
----
Package Information
==================================================
Name:        Production Schemas
Version:     2.1.0
Description: Schema set for production deployment
Created:     2024-01-15T10:30:00Z

Configuration
--------------------------------------------------
Express mode:         include_all
Resolution mode:      resolved
Serialization format: marshal

Statistics
--------------------------------------------------
Total schemas:    45
Total entities:   892
Total types:      456
Total functions:  123
Total rules:      67
Total procedures: 34
----
====

=== Listing package contents

List elements in the package:

[source,bash]
----
# List all entities
expressir package list schemas.ler --type entity

# List types
expressir package list schemas.ler --type type

# List entities from specific schema
expressir package list schemas.ler --type entity --schema action_schema

# List SELECT types only
expressir package list schemas.ler --type type --category select

# Show counts only
expressir package list schemas.ler --type entity --count-only
----

=== Extracting package contents

Extract package contents to directory:

[source,bash]
----
# Extract to directory
expressir package extract schemas.ler --output extracted/

# View extracted structure
ls -R extracted/
----

Extracted contents include:

* `metadata.yaml` - Package metadata
* `manifest.yaml` - Schema manifest
* `repository.marshal` (or `.yaml`, `.json`) - Serialized repository
* `entity_index.marshal` - Entity index
* `type_index.marshal` - Type index
* `reference_index.marshal` - Reference index
* `express_files/` - Original EXPRESS files (if included)

== Performance comparison

=== Load time comparison

LER packages load significantly faster than parsing EXPRESS files:

.Performance comparison example
[example]
====
[source,ruby]
----
require "benchmark"

# Scenario: 100 EXPRESS schema files
# Total size: 15 MB of EXPRESS source

# Method 1: Parse from EXPRESS files
parse_time = Benchmark.realtime do
  files = Dir.glob("schemas/**/*.exp")
  @repo1 = Expressir::Express::Parser.from_files(files)
end
puts "Parse time: #{parse_time.round(2)}s"  # ~45 seconds

# Method 2: Load from LER package
load_time = Benchmark.realtime do
  @repo2 = Expressir::Model::Repository.from_package("schemas.ler")
end
puts "Load time: #{load_time.round(2)}s"   # ~2 seconds

# Speed improvement
speedup = parse_time / load_time
puts "Speed improvement: #{speedup.round(1)}x faster"  # ~22x faster
----
====

=== Real-world performance data

Typical performance improvements:

[options="header"]
|===
| Schema Set Size | Parse Time | Load Time | Improvement

| Small (10 files)
| 5s
| 0.3s
| 16x faster

| Medium (50 files)
| 22s
| 1.2s
| 18x faster

| Large (100 files)
| 45s
| 2.0s
| 22x faster

| Very Large (200 files)
| 95s
| 4.5s
| 21x faster
|===

=== Performance factors

Factors affecting load performance:

Serialization format:: Marshal is fastest, YAML is slowest
+
[source]
----
Marshal:  1.0x (baseline)
JSON:     3.2x slower
YAML:     4.1x slower
----

Package size:: Linear relationship with schema count

Disk I/O speed:: SSD vs HDD can differ by 2-3x

Pre-built indexes:: No rebuild time needed (saves 0.5-2s)

== Memory considerations

=== Memory usage patterns

LER packages load entire repository into memory:

[options="header"]
|===
| Schema Count | Repository Size | Memory Usage | Load Time

| 10-50
| Small
| 10-50 MB
| <1 second

| 50-100
| Medium
| 50-200 MB
| 1-2 seconds

| 100-500
| Large
| 200-500 MB
| 2-5 seconds

| 500+
| Very Large
| 500+ MB
| 5+ seconds
|===

=== Managing memory usage

For large packages, consider:

.Memory optimization strategies
[example]
====
1. Use selective loading (load only needed schemas)
2. Clear repository when done: `repo = nil; GC.start`
3. Use streaming for one-time queries
4. Split into multiple smaller packages
====

=== Monitoring memory usage

Track memory consumption:

[source,ruby]
----
require "get_process_mem"

# Measure memory before
mem_before = GetProcessMem.new.mb

# Load package
repo = Expressir::Model::Repository.from_package("large.ler")

# Measure memory after
mem_after = GetProcessMem.new.mb
mem_used = mem_after - mem_before

puts "Memory used: #{mem_used.round(2)} MB"
puts "Schemas: #{repo.schemas.size}"
puts "Per schema: #{(mem_used / repo.schemas.size).round(2)} MB"
----

== Cache strategies

=== When to use caching

Use LER packages as a cache layer:

Development:: Keep EXPRESS files, build packages for testing

Production:: Deploy pre-built packages, no parsing needed

CI/CD:: Build once, deploy everywhere

=== Cache invalidation

Rebuild packages when:

* EXPRESS schemas change
* Schema versions are updated
* Dependencies are modified
* Validation rules change

=== Hybrid approach

Combine EXPRESS files and LER packages:

[source,ruby]
----
class SchemaLoader
  def initialize(package_path, schemas_dir)
    @package_path = package_path
    @schemas_dir = schemas_dir
  end

  def load
    # Check if package exists and is recent
    if package_fresh?
      load_from_package
    else
      load_from_express_and_rebuild
    end
  end

  private

  def package_fresh?
    return false unless File.exist?(@package_path)

    package_mtime = File.mtime(@package_path)
    schemas_mtime = Dir.glob("#{@schemas_dir}/**/*.exp")
                      .map { |f| File.mtime(f) }
                      .max

    package_mtime > schemas_mtime
  end

  def load_from_package
    puts "Loading from package (cached)..."
    Expressir::Model::Repository.from_package(@package_path)
  end

  def load_from_express_and_rebuild
    puts "Loading from EXPRESS (cache stale)..."
    files = Dir.glob("#{@schemas_dir}/**/*.exp")
    repo = Expressir::Express::Parser.from_files(files)

    puts "Rebuilding package cache..."
    repo.export_to_package(@package_path)

    repo
  end
end

# Usage
loader = SchemaLoader.new("cache/schemas.ler", "schemas/")
repo = loader.load
----

== Error handling

=== Common loading errors

==== Package file not found

.Error
[example]
====
[source]
----
ArgumentError: Package file not found: schemas.ler
----
====

.Solution
[example]
====
[source,ruby]
----
unless File.exist?("schemas.ler")
  abort "Package file not found. Build with: expressir package build ..."
end

repo = Expressir::Model::Repository.from_package("schemas.ler")
----
====

==== Corrupted package

.Error
[example]
====
[source]
----
Error: Metadata not found in package
----
====

.Solution
[example]
====
1. Verify package is a valid ZIP file: `unzip -t schemas.ler`
2. Rebuild package from source
3. Check disk space and file permissions
====

==== Incompatible format

.Error
[example]
====
[source]
----
Error: Unknown serialization format: custom
----
====

.Solution
[example]
====
Package was built with unsupported format. Rebuild with:
* `marshal` (recommended)
* `yaml`
* `json`
====

==== Version mismatch

.Error
[example]
====
[source]
----
Error: Package built with expressir 0.6.0, current version is 0.7.0
----
====

.Solution
[example]
====
Rebuild package with current Expressir version:
[source,bash]
----
expressir package build schemas/ new_package.ler
----
====

=== Robust error handling

Implement comprehensive error handling:

[source,ruby]
----
def load_package_safely(path, fallback_dir = nil)
  begin
    # Try loading package
    repo = Expressir::Model::Repository.from_package(path)
    puts "✓ Loaded package: #{path}"
    return repo

  rescue ArgumentError => e
    puts "Package not found: #{path}"

    if fallback_dir && Dir.exist?(fallback_dir)
      puts "Falling back to EXPRESS files..."
      return load_from_express(fallback_dir)
    else
      raise "No package or fallback available"
    end

  rescue StandardError => e
    puts "Error loading package: #{e.message}"

    if fallback_dir && Dir.exist?(fallback_dir)
      puts "Attempting recovery from EXPRESS files..."
      return load_from_express(fallback_dir)
    else
      raise
    end
  end
end

def load_from_express(dir)
  files = Dir.glob("#{dir}/**/*.exp")
  Expressir::Express::Parser.from_files(files)
end

# Usage with fallback
repo = load_package_safely(
  "cache/schemas.ler",
  "schemas/"  # fallback directory
)
----

== Verification after loading

=== Verify package integrity

Check loaded repository:

[source,ruby]
----
repo = Expressir::Model::Repository.from_package("schemas.ler")

# Verify schemas loaded
if repo.schemas.empty?
  abort "Error: No schemas loaded from package"
end

puts "Loaded schemas:"
repo.schemas.each { |s| puts "  - #{s.id}" }

# Verify indexes built
if repo.entity_index.nil?
  puts "Warning: Entity index not loaded"
  repo.build_indexes
end

# Test entity lookup
test_entity = repo.find_entity(qualified_name: "action_schema.action")
if test_entity
  puts "✓ Entity lookup working"
else
  puts "⚠ Entity lookup failed"
end
----

=== Validate repository

Run validation after loading:

[source,ruby]
----
repo = Expressir::Model::Repository.from_package("schemas.ler")

# Validate repository
validation = repo.validate

if validation[:valid?]
  puts "✓ Repository is valid"
else
  puts "⚠ Validation errors found:"
  validation[:errors].each do |error|
    puts "  - #{error[:message]}"
  end
end
----

=== Statistics check

Verify expected schema contents:

[source,ruby]
----
repo = Expressir::Model::Repository.from_package("schemas.ler")
stats = repo.statistics

puts "Package Statistics:"
puts "  Schemas: #{stats[:total_schemas]}"
puts "  Entities: #{stats[:total_entities]}"
puts "  Types: #{stats[:total_types]}"
puts "  Functions: #{stats[:total_functions]}"

# Compare with expected values
expected = { schemas: 45, entities: 892 }

if stats[:total_schemas] != expected[:schemas]
  puts "⚠ Schema count mismatch"
end

if stats[:total_entities] != expected[:entities]
  puts "⚠ Entity count mismatch"
end
----

== Next steps

* link:querying-packages.html[Querying Packages] - Search and filter package
contents
* link:validating-packages.html[Validating Packages] - Comprehensive package
validation
* link:package-formats.html[Package Formats] - Understanding serialization
formats
* link:creating-packages.html[Creating Packages] - Build your own packages

== Summary

Key takeaways for loading LER packages:

* Use `Repository.from_package()` for simplest loading
* Loading is 20-30x faster than parsing EXPRESS files
* Packages are fully ready after loading (indexes included)
* Memory usage scales linearly with package size
* Use packages as cache layer for best performance
* Implement error handling with fallback to EXPRESS files
* Validate repository after loading critical packages
* Marshal format provides fastest loading
* Extract packages to debug contents

Best practices:

* Always check package exists before loading
* Use try-catch for robust applications
* Verify loaded content with statistics
* Consider memory constraints for large packages
* Implement cache invalidation strategy
* Keep original EXPRESS files as source of truth
* Monitor load times in production
* Use fallback to EXPRESS files when needed