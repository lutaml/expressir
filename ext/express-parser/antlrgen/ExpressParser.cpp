
// Generated from Express.g4 by ANTLR 4.10.1


#include "ExpressListener.h"
#include "ExpressVisitor.h"

#include "ExpressParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct ExpressParserStaticData final {
  ExpressParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  ExpressParserStaticData(const ExpressParserStaticData&) = delete;
  ExpressParserStaticData(ExpressParserStaticData&&) = delete;
  ExpressParserStaticData& operator=(const ExpressParserStaticData&) = delete;
  ExpressParserStaticData& operator=(ExpressParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

std::once_flag expressParserOnceFlag;
ExpressParserStaticData *expressParserStaticData = nullptr;

void expressParserInitialize() {
  assert(expressParserStaticData == nullptr);
  auto staticData = std::make_unique<ExpressParserStaticData>(
    std::vector<std::string>{
      "attributeRef", "constantRef", "entityRef", "enumerationRef", "functionRef", 
      "parameterRef", "procedureRef", "ruleLabelRef", "ruleRef", "schemaRef", 
      "subtypeConstraintRef", "typeLabelRef", "typeRef", "variableRef", 
      "abstractEntityDeclaration", "abstractSupertype", "abstractSupertypeDeclaration", 
      "actualParameterList", "addLikeOp", "aggregateInitializer", "aggregateSource", 
      "aggregateType", "aggregationTypes", "algorithmHead", "aliasStmt", 
      "arrayType", "assignmentStmt", "attributeDecl", "attributeId", "attributeQualifier", 
      "bagType", "binaryType", "booleanType", "bound1", "bound2", "boundSpec", 
      "builtInConstant", "builtInFunction", "builtInProcedure", "caseAction", 
      "caseLabel", "caseStmt", "compoundStmt", "concreteTypes", "constantBody", 
      "constantDecl", "constantFactor", "constantId", "constructedTypes", 
      "declaration", "derivedAttr", "deriveClause", "domainRule", "element", 
      "entityBody", "entityConstructor", "entityDecl", "entityHead", "entityId", 
      "enumerationExtension", "enumerationId", "enumerationItems", "enumerationItem", 
      "enumerationReference", "enumerationType", "escapeStmt", "explicitAttr", 
      "expression", "factor", "formalParameter", "functionCall", "functionDecl", 
      "functionHead", "functionId", "generalizedTypes", "generalAggregationTypes", 
      "generalArrayType", "generalBagType", "generalListType", "generalRef", 
      "generalSetType", "genericEntityType", "genericType", "groupQualifier", 
      "ifStmt", "ifStmtStatements", "ifStmtElseStatements", "increment", 
      "incrementControl", "index", "index1", "index2", "indexQualifier", 
      "instantiableType", "integerType", "interfaceSpecification", "interval", 
      "intervalHigh", "intervalItem", "intervalLow", "intervalOp", "inverseAttr", 
      "inverseAttrType", "inverseClause", "listType", "literal", "localDecl", 
      "localVariable", "logicalExpression", "logicalLiteral", "logicalType", 
      "multiplicationLikeOp", "namedTypes", "namedTypeOrRename", "nullStmt", 
      "numberType", "numericExpression", "oneOf", "parameter", "parameterId", 
      "parameterType", "population", "precisionSpec", "primary", "procedureCallStmt", 
      "procedureDecl", "procedureHead", "procedureHeadParameter", "procedureId", 
      "qualifiableFactor", "qualifiedAttribute", "qualifier", "queryExpression", 
      "realType", "redeclaredAttribute", "referencedAttribute", "referenceClause", 
      "relOp", "relOpExtended", "renameId", "repeatControl", "repeatStmt", 
      "repetition", "resourceOrRename", "resourceRef", "returnStmt", "ruleDecl", 
      "ruleHead", "ruleId", "ruleLabelId", "schemaBody", "schemaBodyDeclaration", 
      "schemaDecl", "schemaId", "schemaVersionId", "selector", "selectExtension", 
      "selectList", "selectType", "setType", "simpleExpression", "simpleFactor", 
      "simpleFactorExpression", "simpleFactorUnaryExpression", "simpleTypes", 
      "skipStmt", "stmt", "stringLiteral", "stringType", "subsuper", "subtypeConstraint", 
      "subtypeConstraintBody", "subtypeConstraintDecl", "subtypeConstraintHead", 
      "subtypeConstraintId", "subtypeDeclaration", "supertypeConstraint", 
      "supertypeExpression", "supertypeFactor", "supertypeRule", "supertypeTerm", 
      "syntax", "term", "totalOver", "typeDecl", "typeId", "typeLabel", 
      "typeLabelId", "unaryOp", "underlyingType", "uniqueClause", "uniqueRule", 
      "untilControl", "useClause", "variableId", "whereClause", "whileControl", 
      "width", "widthSpec"
    },
    std::vector<std::string>{
      "", "';'", "'('", "','", "')'", "'+'", "'-'", "'['", "']'", "':'", 
      "':='", "'.'", "'\\u003F'", "'**'", "'\\'", "'{'", "'}'", "'<'", "'<='", 
      "'*'", "'/'", "'||'", "'<*'", "'|'", "'>'", "'>='", "'<>'", "'='", 
      "':<>:'", "':=:'"
    },
    std::vector<std::string>{
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "ABS", "ABSTRACT", 
      "ACOS", "AGGREGATE", "ALIAS", "AND", "ANDOR", "ARRAY", "AS", "ASIN", 
      "ATAN", "BAG", "BASED_ON", "BEGIN_", "BINARY", "BLENGTH", "BOOLEAN", 
      "BY", "CASE", "CONSTANT", "CONST_E", "COS", "DERIVE", "DIV", "ELSE", 
      "END_", "END_ALIAS", "END_CASE", "END_CONSTANT", "END_ENTITY", "END_FUNCTION", 
      "END_IF", "END_LOCAL", "END_PROCEDURE", "END_REPEAT", "END_RULE", 
      "END_SCHEMA", "END_SUBTYPE_CONSTRAINT", "END_TYPE", "ENTITY", "ENUMERATION", 
      "ESCAPE", "EXISTS", "EXP", "EXTENSIBLE", "FALSE", "FIXED", "FOR", 
      "FORMAT", "FROM", "FUNCTION", "GENERIC", "GENERIC_ENTITY", "HIBOUND", 
      "HIINDEX", "IF", "IN", "INSERT", "INTEGER", "INVERSE", "LENGTH", "LIKE", 
      "LIST", "LOBOUND", "LOCAL", "LOG", "LOG10", "LOG2", "LOGICAL", "LOINDEX", 
      "MOD", "NOT", "NUMBER", "NVL", "ODD", "OF", "ONEOF", "OPTIONAL", "OR", 
      "OTHERWISE", "PI", "PROCEDURE", "QUERY", "REAL", "REFERENCE", "REMOVE", 
      "RENAMED", "REPEAT", "RETURN", "ROLESOF", "RULE", "SCHEMA", "SELECT", 
      "SELF", "SET", "SIN", "SIZEOF", "SKIP_", "SQRT", "STRING", "SUBTYPE", 
      "SUBTYPE_CONSTRAINT", "SUPERTYPE", "TAN", "THEN", "TO", "TRUE", "TYPE", 
      "TYPEOF", "TOTAL_OVER", "UNIQUE", "UNKNOWN", "UNTIL", "USE", "USEDIN", 
      "VALUE_", "VALUE_IN", "VALUE_UNIQUE", "VAR", "WITH", "WHERE", "WHILE", 
      "XOR", "BinaryLiteral", "EncodedStringLiteral", "IntegerLiteral", 
      "RealLiteral", "SimpleId", "SimpleStringLiteral", "EmbeddedRemark", 
      "TailRemark", "Whitespace"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,161,1643,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,
  	7,122,2,123,7,123,2,124,7,124,2,125,7,125,2,126,7,126,2,127,7,127,2,128,
  	7,128,2,129,7,129,2,130,7,130,2,131,7,131,2,132,7,132,2,133,7,133,2,134,
  	7,134,2,135,7,135,2,136,7,136,2,137,7,137,2,138,7,138,2,139,7,139,2,140,
  	7,140,2,141,7,141,2,142,7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,
  	7,146,2,147,7,147,2,148,7,148,2,149,7,149,2,150,7,150,2,151,7,151,2,152,
  	7,152,2,153,7,153,2,154,7,154,2,155,7,155,2,156,7,156,2,157,7,157,2,158,
  	7,158,2,159,7,159,2,160,7,160,2,161,7,161,2,162,7,162,2,163,7,163,2,164,
  	7,164,2,165,7,165,2,166,7,166,2,167,7,167,2,168,7,168,2,169,7,169,2,170,
  	7,170,2,171,7,171,2,172,7,172,2,173,7,173,2,174,7,174,2,175,7,175,2,176,
  	7,176,2,177,7,177,2,178,7,178,2,179,7,179,2,180,7,180,2,181,7,181,2,182,
  	7,182,2,183,7,183,2,184,7,184,2,185,7,185,2,186,7,186,2,187,7,187,2,188,
  	7,188,2,189,7,189,2,190,7,190,2,191,7,191,2,192,7,192,2,193,7,193,2,194,
  	7,194,2,195,7,195,2,196,7,196,2,197,7,197,2,198,7,198,1,0,1,0,1,1,1,1,
  	1,2,1,2,1,3,1,3,1,4,1,4,1,5,1,5,1,6,1,6,1,7,1,7,1,8,1,8,1,9,1,9,1,10,
  	1,10,1,11,1,11,1,12,1,12,1,13,1,13,1,14,1,14,1,15,1,15,1,15,1,15,1,16,
  	1,16,1,16,3,16,436,8,16,1,17,1,17,1,17,1,17,5,17,442,8,17,10,17,12,17,
  	445,9,17,1,17,1,17,1,18,1,18,1,19,1,19,1,19,1,19,5,19,455,8,19,10,19,
  	12,19,458,9,19,3,19,460,8,19,1,19,1,19,1,20,1,20,1,21,1,21,1,21,3,21,
  	469,8,21,1,21,1,21,1,21,1,22,1,22,1,22,1,22,3,22,478,8,22,1,23,5,23,481,
  	8,23,10,23,12,23,484,9,23,1,23,3,23,487,8,23,1,23,3,23,490,8,23,1,24,
  	1,24,1,24,1,24,1,24,5,24,497,8,24,10,24,12,24,500,9,24,1,24,1,24,1,24,
  	5,24,505,8,24,10,24,12,24,508,9,24,1,24,1,24,1,24,1,25,1,25,1,25,1,25,
  	3,25,517,8,25,1,25,3,25,520,8,25,1,25,1,25,1,26,1,26,5,26,526,8,26,10,
  	26,12,26,529,9,26,1,26,1,26,1,26,1,26,1,27,1,27,3,27,537,8,27,1,28,1,
  	28,1,29,1,29,1,29,1,30,1,30,3,30,546,8,30,1,30,1,30,1,30,1,31,1,31,3,
  	31,553,8,31,1,32,1,32,1,33,1,33,1,34,1,34,1,35,1,35,1,35,1,35,1,35,1,
  	35,1,36,1,36,1,37,1,37,1,38,1,38,1,39,1,39,1,39,5,39,576,8,39,10,39,12,
  	39,579,9,39,1,39,1,39,1,39,1,40,1,40,1,41,1,41,1,41,1,41,5,41,590,8,41,
  	10,41,12,41,593,9,41,1,41,1,41,1,41,3,41,598,8,41,1,41,1,41,1,41,1,42,
  	1,42,1,42,5,42,606,8,42,10,42,12,42,609,9,42,1,42,1,42,1,42,1,43,1,43,
  	1,43,3,43,617,8,43,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,45,1,45,1,45,
  	5,45,629,8,45,10,45,12,45,632,9,45,1,45,1,45,1,45,1,46,1,46,3,46,639,
  	8,46,1,47,1,47,1,48,1,48,3,48,645,8,48,1,49,1,49,1,49,1,49,1,49,3,49,
  	652,8,49,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,51,1,51,1,51,5,51,664,8,
  	51,10,51,12,51,667,9,51,1,52,1,52,1,52,3,52,672,8,52,1,52,1,52,1,53,1,
  	53,1,53,3,53,679,8,53,1,54,5,54,682,8,54,10,54,12,54,685,9,54,1,54,3,
  	54,688,8,54,1,54,3,54,691,8,54,1,54,3,54,694,8,54,1,54,3,54,697,8,54,
  	1,55,1,55,1,55,1,55,1,55,5,55,704,8,55,10,55,12,55,707,9,55,3,55,709,
  	8,55,1,55,1,55,1,56,1,56,1,56,1,56,1,56,1,57,1,57,1,57,1,57,1,57,1,58,
  	1,58,1,59,1,59,1,59,1,59,3,59,729,8,59,1,60,1,60,1,61,1,61,1,61,1,61,
  	5,61,737,8,61,10,61,12,61,740,9,61,1,61,1,61,1,62,1,62,1,63,1,63,1,63,
  	3,63,749,8,63,1,63,1,63,1,64,3,64,754,8,64,1,64,1,64,1,64,1,64,3,64,760,
  	8,64,1,65,1,65,1,65,1,66,1,66,1,66,5,66,768,8,66,10,66,12,66,771,9,66,
  	1,66,1,66,3,66,775,8,66,1,66,1,66,1,66,1,67,1,67,1,67,1,67,3,67,784,8,
  	67,1,68,1,68,1,68,3,68,789,8,68,1,69,1,69,1,69,5,69,794,8,69,10,69,12,
  	69,797,9,69,1,69,1,69,1,69,1,70,1,70,3,70,804,8,70,1,70,3,70,807,8,70,
  	1,71,1,71,1,71,1,71,5,71,813,8,71,10,71,12,71,816,9,71,1,71,1,71,1,71,
  	1,72,1,72,1,72,1,72,1,72,1,72,5,72,827,8,72,10,72,12,72,830,9,72,1,72,
  	1,72,3,72,834,8,72,1,72,1,72,1,72,1,72,1,73,1,73,1,74,1,74,1,74,1,74,
  	3,74,846,8,74,1,75,1,75,1,75,1,75,3,75,852,8,75,1,76,1,76,3,76,856,8,
  	76,1,76,1,76,3,76,860,8,76,1,76,3,76,863,8,76,1,76,1,76,1,77,1,77,3,77,
  	869,8,77,1,77,1,77,1,77,1,78,1,78,3,78,876,8,78,1,78,1,78,3,78,880,8,
  	78,1,78,1,78,1,79,1,79,3,79,886,8,79,1,80,1,80,3,80,890,8,80,1,80,1,80,
  	1,80,1,81,1,81,1,81,3,81,898,8,81,1,82,1,82,1,82,3,82,903,8,82,1,83,1,
  	83,1,83,1,84,1,84,1,84,1,84,1,84,1,84,3,84,914,8,84,1,84,1,84,1,84,1,
  	85,1,85,5,85,921,8,85,10,85,12,85,924,9,85,1,86,1,86,5,86,928,8,86,10,
  	86,12,86,931,9,86,1,87,1,87,1,88,1,88,1,88,1,88,1,88,1,88,1,88,3,88,942,
  	8,88,1,89,1,89,1,90,1,90,1,91,1,91,1,92,1,92,1,92,1,92,3,92,954,8,92,
  	1,92,1,92,1,93,1,93,3,93,960,8,93,1,94,1,94,1,95,1,95,3,95,966,8,95,1,
  	96,1,96,1,96,1,96,1,96,1,96,1,96,1,96,1,97,1,97,1,98,1,98,1,99,1,99,1,
  	100,1,100,1,101,1,101,1,101,1,101,1,101,1,101,1,101,3,101,991,8,101,1,
  	101,1,101,1,101,1,102,1,102,3,102,998,8,102,1,102,3,102,1001,8,102,1,
  	102,1,102,1,103,1,103,1,103,5,103,1008,8,103,10,103,12,103,1011,9,103,
  	1,104,1,104,3,104,1015,8,104,1,104,1,104,3,104,1019,8,104,1,104,1,104,
  	1,105,1,105,1,105,1,105,1,105,3,105,1028,8,105,1,106,1,106,1,106,5,106,
  	1033,8,106,10,106,12,106,1036,9,106,1,106,1,106,1,106,1,107,1,107,1,107,
  	5,107,1044,8,107,10,107,12,107,1047,9,107,1,107,1,107,1,107,1,107,3,107,
  	1053,8,107,1,107,1,107,1,108,1,108,1,109,1,109,1,110,1,110,1,111,1,111,
  	1,112,1,112,3,112,1067,8,112,1,113,1,113,1,113,1,113,3,113,1073,8,113,
  	3,113,1075,8,113,1,114,1,114,1,115,1,115,1,116,1,116,1,117,1,117,1,117,
  	1,117,1,117,5,117,1088,8,117,10,117,12,117,1091,9,117,1,117,1,117,1,118,
  	1,118,1,119,1,119,1,120,1,120,1,120,3,120,1102,8,120,1,121,1,121,1,122,
  	1,122,1,123,1,123,1,123,5,123,1111,8,123,10,123,12,123,1114,9,123,3,123,
  	1116,8,123,1,124,1,124,3,124,1120,8,124,1,124,3,124,1123,8,124,1,124,
  	1,124,1,125,1,125,1,125,5,125,1130,8,125,10,125,12,125,1133,9,125,1,125,
  	1,125,1,125,1,126,1,126,1,126,1,126,1,126,1,126,5,126,1144,8,126,10,126,
  	12,126,1147,9,126,1,126,1,126,3,126,1151,8,126,1,126,1,126,1,127,3,127,
  	1156,8,127,1,127,1,127,1,128,1,128,1,129,1,129,1,129,1,129,1,129,3,129,
  	1167,8,129,1,130,1,130,1,130,1,130,1,131,1,131,1,131,3,131,1176,8,131,
  	1,132,1,132,1,132,1,132,1,132,1,132,1,132,1,132,1,132,1,133,1,133,1,133,
  	1,133,1,133,3,133,1192,8,133,1,134,1,134,1,134,3,134,1197,8,134,1,135,
  	1,135,3,135,1201,8,135,1,136,1,136,1,136,1,136,1,136,1,136,1,136,5,136,
  	1210,8,136,10,136,12,136,1213,9,136,1,136,1,136,3,136,1217,8,136,1,136,
  	1,136,1,137,1,137,1,138,1,138,1,138,3,138,1226,8,138,1,139,1,139,1,139,
  	1,139,1,139,3,139,1233,8,139,1,140,3,140,1236,8,140,1,140,3,140,1239,
  	8,140,1,140,3,140,1242,8,140,1,141,1,141,1,141,1,141,1,141,5,141,1249,
  	8,141,10,141,12,141,1252,9,141,1,141,1,141,1,141,1,142,1,142,1,143,1,
  	143,1,143,3,143,1262,8,143,1,144,1,144,1,144,1,144,1,144,3,144,1269,8,
  	144,1,145,1,145,1,145,1,145,1,145,3,145,1276,8,145,1,145,1,145,1,146,
  	1,146,1,146,5,146,1283,8,146,10,146,12,146,1286,9,146,1,146,1,146,1,146,
  	1,146,1,147,1,147,1,147,1,147,1,147,1,147,1,147,5,147,1299,8,147,10,147,
  	12,147,1302,9,147,1,147,1,147,1,147,1,148,1,148,1,149,1,149,1,150,5,150,
  	1312,8,150,10,150,12,150,1315,9,150,1,150,3,150,1318,8,150,1,150,5,150,
  	1321,8,150,10,150,12,150,1324,9,150,1,151,1,151,3,151,1328,8,151,1,152,
  	1,152,1,152,3,152,1333,8,152,1,152,1,152,1,152,1,152,1,152,1,153,1,153,
  	1,154,1,154,1,155,1,155,1,156,1,156,1,156,1,156,3,156,1350,8,156,1,157,
  	1,157,1,157,1,157,5,157,1356,8,157,10,157,12,157,1359,9,157,1,157,1,157,
  	1,158,1,158,3,158,1365,8,158,3,158,1367,8,158,1,158,1,158,1,158,3,158,
  	1372,8,158,1,159,1,159,3,159,1376,8,159,1,159,1,159,1,159,1,160,1,160,
  	1,160,1,160,5,160,1385,8,160,10,160,12,160,1388,9,160,1,161,1,161,1,161,
  	1,161,1,161,1,161,1,161,3,161,1397,8,161,1,162,1,162,1,162,1,162,1,162,
  	3,162,1404,8,162,1,163,1,163,1,163,1,164,1,164,1,164,1,164,1,164,1,164,
  	1,164,3,164,1416,8,164,1,165,1,165,1,165,1,166,1,166,1,166,1,166,1,166,
  	1,166,1,166,1,166,1,166,1,166,1,166,3,166,1432,8,166,1,167,1,167,1,168,
  	1,168,3,168,1438,8,168,1,169,3,169,1441,8,169,1,169,3,169,1444,8,169,
  	1,170,1,170,1,170,1,170,1,170,1,171,3,171,1452,8,171,1,171,3,171,1455,
  	8,171,1,171,1,171,1,171,3,171,1460,8,171,1,172,1,172,1,172,1,172,1,172,
  	1,173,1,173,1,173,1,173,1,173,1,173,1,174,1,174,1,175,1,175,1,175,1,175,
  	1,175,1,175,5,175,1481,8,175,10,175,12,175,1484,9,175,1,175,1,175,1,176,
  	1,176,1,176,3,176,1491,8,176,1,177,1,177,1,177,5,177,1496,8,177,10,177,
  	12,177,1499,9,177,1,178,1,178,1,178,5,178,1504,8,178,10,178,12,178,1507,
  	9,178,1,179,1,179,1,179,1,180,1,180,1,180,1,180,1,180,1,180,3,180,1518,
  	8,180,1,181,4,181,1521,8,181,11,181,12,181,1522,1,181,1,181,1,182,1,182,
  	1,182,1,182,5,182,1531,8,182,10,182,12,182,1534,9,182,1,183,1,183,1,183,
  	1,183,1,183,5,183,1541,8,183,10,183,12,183,1544,9,183,1,183,1,183,1,183,
  	1,184,1,184,1,184,1,184,1,184,1,184,3,184,1555,8,184,1,184,1,184,1,184,
  	1,185,1,185,1,186,1,186,3,186,1564,8,186,1,187,1,187,1,188,1,188,1,189,
  	1,189,3,189,1572,8,189,1,190,1,190,1,190,1,190,1,190,1,190,5,190,1580,
  	8,190,10,190,12,190,1583,9,190,1,191,1,191,1,191,3,191,1588,8,191,1,191,
  	1,191,1,191,5,191,1593,8,191,10,191,12,191,1596,9,191,1,192,1,192,1,192,
  	1,193,1,193,1,193,1,193,1,193,1,193,1,193,5,193,1608,8,193,10,193,12,
  	193,1611,9,193,1,193,1,193,3,193,1615,8,193,1,193,1,193,1,194,1,194,1,
  	195,1,195,1,195,1,195,1,195,1,195,5,195,1627,8,195,10,195,12,195,1630,
  	9,195,1,196,1,196,1,196,1,197,1,197,1,198,1,198,1,198,1,198,3,198,1641,
  	8,198,1,198,0,0,199,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,
  	36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,
  	82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,
  	122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,
  	158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,
  	194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,
  	230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,
  	266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,
  	302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,
  	338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,
  	374,376,378,380,382,384,386,388,390,392,394,396,0,11,3,0,5,6,108,108,
  	152,152,4,0,12,12,50,50,110,110,123,123,19,0,30,30,32,32,39,40,45,45,
  	51,51,72,73,78,78,83,84,90,90,93,93,95,97,99,99,103,104,119,119,125,126,
  	128,128,133,133,138,138,144,147,2,0,87,87,115,115,1,0,17,18,2,0,41,41,
  	124,124,3,0,75,75,136,136,141,141,4,0,19,21,35,35,53,53,100,100,2,0,17,
  	18,24,29,2,0,154,154,158,158,2,0,5,6,101,101,1642,0,398,1,0,0,0,2,400,
  	1,0,0,0,4,402,1,0,0,0,6,404,1,0,0,0,8,406,1,0,0,0,10,408,1,0,0,0,12,410,
  	1,0,0,0,14,412,1,0,0,0,16,414,1,0,0,0,18,416,1,0,0,0,20,418,1,0,0,0,22,
  	420,1,0,0,0,24,422,1,0,0,0,26,424,1,0,0,0,28,426,1,0,0,0,30,428,1,0,0,
  	0,32,432,1,0,0,0,34,437,1,0,0,0,36,448,1,0,0,0,38,450,1,0,0,0,40,463,
  	1,0,0,0,42,465,1,0,0,0,44,477,1,0,0,0,46,482,1,0,0,0,48,491,1,0,0,0,50,
  	512,1,0,0,0,52,523,1,0,0,0,54,536,1,0,0,0,56,538,1,0,0,0,58,540,1,0,0,
  	0,60,543,1,0,0,0,62,550,1,0,0,0,64,554,1,0,0,0,66,556,1,0,0,0,68,558,
  	1,0,0,0,70,560,1,0,0,0,72,566,1,0,0,0,74,568,1,0,0,0,76,570,1,0,0,0,78,
  	572,1,0,0,0,80,583,1,0,0,0,82,585,1,0,0,0,84,602,1,0,0,0,86,616,1,0,0,
  	0,88,618,1,0,0,0,90,625,1,0,0,0,92,638,1,0,0,0,94,640,1,0,0,0,96,644,
  	1,0,0,0,98,651,1,0,0,0,100,653,1,0,0,0,102,660,1,0,0,0,104,671,1,0,0,
  	0,106,675,1,0,0,0,108,683,1,0,0,0,110,698,1,0,0,0,112,712,1,0,0,0,114,
  	717,1,0,0,0,116,722,1,0,0,0,118,724,1,0,0,0,120,730,1,0,0,0,122,732,1,
  	0,0,0,124,743,1,0,0,0,126,748,1,0,0,0,128,753,1,0,0,0,130,761,1,0,0,0,
  	132,764,1,0,0,0,134,779,1,0,0,0,136,785,1,0,0,0,138,790,1,0,0,0,140,803,
  	1,0,0,0,142,808,1,0,0,0,144,820,1,0,0,0,146,839,1,0,0,0,148,845,1,0,0,
  	0,150,851,1,0,0,0,152,853,1,0,0,0,154,866,1,0,0,0,156,873,1,0,0,0,158,
  	885,1,0,0,0,160,887,1,0,0,0,162,894,1,0,0,0,164,899,1,0,0,0,166,904,1,
  	0,0,0,168,907,1,0,0,0,170,918,1,0,0,0,172,925,1,0,0,0,174,932,1,0,0,0,
  	176,934,1,0,0,0,178,943,1,0,0,0,180,945,1,0,0,0,182,947,1,0,0,0,184,949,
  	1,0,0,0,186,959,1,0,0,0,188,961,1,0,0,0,190,965,1,0,0,0,192,967,1,0,0,
  	0,194,975,1,0,0,0,196,977,1,0,0,0,198,979,1,0,0,0,200,981,1,0,0,0,202,
  	983,1,0,0,0,204,1000,1,0,0,0,206,1004,1,0,0,0,208,1012,1,0,0,0,210,1027,
  	1,0,0,0,212,1029,1,0,0,0,214,1040,1,0,0,0,216,1056,1,0,0,0,218,1058,1,
  	0,0,0,220,1060,1,0,0,0,222,1062,1,0,0,0,224,1066,1,0,0,0,226,1068,1,0,
  	0,0,228,1076,1,0,0,0,230,1078,1,0,0,0,232,1080,1,0,0,0,234,1082,1,0,0,
  	0,236,1094,1,0,0,0,238,1096,1,0,0,0,240,1101,1,0,0,0,242,1103,1,0,0,0,
  	244,1105,1,0,0,0,246,1115,1,0,0,0,248,1119,1,0,0,0,250,1126,1,0,0,0,252,
  	1137,1,0,0,0,254,1155,1,0,0,0,256,1159,1,0,0,0,258,1166,1,0,0,0,260,1168,
  	1,0,0,0,262,1175,1,0,0,0,264,1177,1,0,0,0,266,1186,1,0,0,0,268,1193,1,
  	0,0,0,270,1200,1,0,0,0,272,1202,1,0,0,0,274,1220,1,0,0,0,276,1225,1,0,
  	0,0,278,1232,1,0,0,0,280,1235,1,0,0,0,282,1243,1,0,0,0,284,1256,1,0,0,
  	0,286,1258,1,0,0,0,288,1268,1,0,0,0,290,1270,1,0,0,0,292,1279,1,0,0,0,
  	294,1291,1,0,0,0,296,1306,1,0,0,0,298,1308,1,0,0,0,300,1313,1,0,0,0,302,
  	1327,1,0,0,0,304,1329,1,0,0,0,306,1339,1,0,0,0,308,1341,1,0,0,0,310,1343,
  	1,0,0,0,312,1345,1,0,0,0,314,1351,1,0,0,0,316,1366,1,0,0,0,318,1373,1,
  	0,0,0,320,1380,1,0,0,0,322,1396,1,0,0,0,324,1403,1,0,0,0,326,1405,1,0,
  	0,0,328,1415,1,0,0,0,330,1417,1,0,0,0,332,1431,1,0,0,0,334,1433,1,0,0,
  	0,336,1435,1,0,0,0,338,1440,1,0,0,0,340,1445,1,0,0,0,342,1451,1,0,0,0,
  	344,1461,1,0,0,0,346,1466,1,0,0,0,348,1472,1,0,0,0,350,1474,1,0,0,0,352,
  	1490,1,0,0,0,354,1492,1,0,0,0,356,1500,1,0,0,0,358,1508,1,0,0,0,360,1517,
  	1,0,0,0,362,1520,1,0,0,0,364,1526,1,0,0,0,366,1535,1,0,0,0,368,1548,1,
  	0,0,0,370,1559,1,0,0,0,372,1563,1,0,0,0,374,1565,1,0,0,0,376,1567,1,0,
  	0,0,378,1571,1,0,0,0,380,1573,1,0,0,0,382,1587,1,0,0,0,384,1597,1,0,0,
  	0,386,1600,1,0,0,0,388,1618,1,0,0,0,390,1620,1,0,0,0,392,1631,1,0,0,0,
  	394,1634,1,0,0,0,396,1636,1,0,0,0,398,399,3,56,28,0,399,1,1,0,0,0,400,
  	401,3,94,47,0,401,3,1,0,0,0,402,403,3,116,58,0,403,5,1,0,0,0,404,405,
  	3,120,60,0,405,7,1,0,0,0,406,407,3,146,73,0,407,9,1,0,0,0,408,409,3,238,
  	119,0,409,11,1,0,0,0,410,411,3,256,128,0,411,13,1,0,0,0,412,413,3,298,
  	149,0,413,15,1,0,0,0,414,415,3,296,148,0,415,17,1,0,0,0,416,417,3,306,
  	153,0,417,19,1,0,0,0,418,419,3,348,174,0,419,21,1,0,0,0,420,421,3,374,
  	187,0,421,23,1,0,0,0,422,423,3,370,185,0,423,25,1,0,0,0,424,425,3,388,
  	194,0,425,27,1,0,0,0,426,427,5,31,0,0,427,29,1,0,0,0,428,429,5,31,0,0,
  	429,430,5,132,0,0,430,431,5,1,0,0,431,31,1,0,0,0,432,433,5,31,0,0,433,
  	435,5,132,0,0,434,436,3,340,170,0,435,434,1,0,0,0,435,436,1,0,0,0,436,
  	33,1,0,0,0,437,438,5,2,0,0,438,443,3,236,118,0,439,440,5,3,0,0,440,442,
  	3,236,118,0,441,439,1,0,0,0,442,445,1,0,0,0,443,441,1,0,0,0,443,444,1,
  	0,0,0,444,446,1,0,0,0,445,443,1,0,0,0,446,447,5,4,0,0,447,35,1,0,0,0,
  	448,449,7,0,0,0,449,37,1,0,0,0,450,459,5,7,0,0,451,456,3,106,53,0,452,
  	453,5,3,0,0,453,455,3,106,53,0,454,452,1,0,0,0,455,458,1,0,0,0,456,454,
  	1,0,0,0,456,457,1,0,0,0,457,460,1,0,0,0,458,456,1,0,0,0,459,451,1,0,0,
  	0,459,460,1,0,0,0,460,461,1,0,0,0,461,462,5,8,0,0,462,39,1,0,0,0,463,
  	464,3,320,160,0,464,41,1,0,0,0,465,468,5,33,0,0,466,467,5,9,0,0,467,469,
  	3,372,186,0,468,466,1,0,0,0,468,469,1,0,0,0,469,470,1,0,0,0,470,471,5,
  	105,0,0,471,472,3,240,120,0,472,43,1,0,0,0,473,478,3,50,25,0,474,478,
  	3,60,30,0,475,478,3,208,104,0,476,478,3,318,159,0,477,473,1,0,0,0,477,
  	474,1,0,0,0,477,475,1,0,0,0,477,476,1,0,0,0,478,45,1,0,0,0,479,481,3,
  	98,49,0,480,479,1,0,0,0,481,484,1,0,0,0,482,480,1,0,0,0,482,483,1,0,0,
  	0,483,486,1,0,0,0,484,482,1,0,0,0,485,487,3,90,45,0,486,485,1,0,0,0,486,
  	487,1,0,0,0,487,489,1,0,0,0,488,490,3,212,106,0,489,488,1,0,0,0,489,490,
  	1,0,0,0,490,47,1,0,0,0,491,492,5,34,0,0,492,493,3,388,194,0,493,494,5,
  	77,0,0,494,498,3,158,79,0,495,497,3,262,131,0,496,495,1,0,0,0,497,500,
  	1,0,0,0,498,496,1,0,0,0,498,499,1,0,0,0,499,501,1,0,0,0,500,498,1,0,0,
  	0,501,502,5,1,0,0,502,506,3,332,166,0,503,505,3,332,166,0,504,503,1,0,
  	0,0,505,508,1,0,0,0,506,504,1,0,0,0,506,507,1,0,0,0,507,509,1,0,0,0,508,
  	506,1,0,0,0,509,510,5,56,0,0,510,511,5,1,0,0,511,49,1,0,0,0,512,513,5,
  	37,0,0,513,514,3,70,35,0,514,516,5,105,0,0,515,517,5,107,0,0,516,515,
  	1,0,0,0,516,517,1,0,0,0,517,519,1,0,0,0,518,520,5,140,0,0,519,518,1,0,
  	0,0,519,520,1,0,0,0,520,521,1,0,0,0,521,522,3,186,93,0,522,51,1,0,0,0,
  	523,527,3,158,79,0,524,526,3,262,131,0,525,524,1,0,0,0,526,529,1,0,0,
  	0,527,525,1,0,0,0,527,528,1,0,0,0,528,530,1,0,0,0,529,527,1,0,0,0,530,
  	531,5,10,0,0,531,532,3,134,67,0,532,533,5,1,0,0,533,53,1,0,0,0,534,537,
  	3,56,28,0,535,537,3,268,134,0,536,534,1,0,0,0,536,535,1,0,0,0,537,55,
  	1,0,0,0,538,539,5,157,0,0,539,57,1,0,0,0,540,541,5,11,0,0,541,542,3,0,
  	0,0,542,59,1,0,0,0,543,545,5,41,0,0,544,546,3,70,35,0,545,544,1,0,0,0,
  	545,546,1,0,0,0,546,547,1,0,0,0,547,548,5,105,0,0,548,549,3,186,93,0,
  	549,61,1,0,0,0,550,552,5,44,0,0,551,553,3,396,198,0,552,551,1,0,0,0,552,
  	553,1,0,0,0,553,63,1,0,0,0,554,555,5,46,0,0,555,65,1,0,0,0,556,557,3,
  	232,116,0,557,67,1,0,0,0,558,559,3,232,116,0,559,69,1,0,0,0,560,561,5,
  	7,0,0,561,562,3,66,33,0,562,563,5,9,0,0,563,564,3,68,34,0,564,565,5,8,
  	0,0,565,71,1,0,0,0,566,567,7,1,0,0,567,73,1,0,0,0,568,569,7,2,0,0,569,
  	75,1,0,0,0,570,571,7,3,0,0,571,77,1,0,0,0,572,577,3,80,40,0,573,574,5,
  	3,0,0,574,576,3,80,40,0,575,573,1,0,0,0,576,579,1,0,0,0,577,575,1,0,0,
  	0,577,578,1,0,0,0,578,580,1,0,0,0,579,577,1,0,0,0,580,581,5,9,0,0,581,
  	582,3,332,166,0,582,79,1,0,0,0,583,584,3,134,67,0,584,81,1,0,0,0,585,
  	586,5,48,0,0,586,587,3,310,155,0,587,591,5,105,0,0,588,590,3,78,39,0,
  	589,588,1,0,0,0,590,593,1,0,0,0,591,589,1,0,0,0,591,592,1,0,0,0,592,597,
  	1,0,0,0,593,591,1,0,0,0,594,595,5,109,0,0,595,596,5,9,0,0,596,598,3,332,
  	166,0,597,594,1,0,0,0,597,598,1,0,0,0,598,599,1,0,0,0,599,600,5,57,0,
  	0,600,601,5,1,0,0,601,83,1,0,0,0,602,603,5,43,0,0,603,607,3,332,166,0,
  	604,606,3,332,166,0,605,604,1,0,0,0,606,609,1,0,0,0,607,605,1,0,0,0,607,
  	608,1,0,0,0,608,610,1,0,0,0,609,607,1,0,0,0,610,611,5,55,0,0,611,612,
  	5,1,0,0,612,85,1,0,0,0,613,617,3,44,22,0,614,617,3,328,164,0,615,617,
  	3,24,12,0,616,613,1,0,0,0,616,614,1,0,0,0,616,615,1,0,0,0,617,87,1,0,
  	0,0,618,619,3,94,47,0,619,620,5,9,0,0,620,621,3,186,93,0,621,622,5,10,
  	0,0,622,623,3,134,67,0,623,624,5,1,0,0,624,89,1,0,0,0,625,626,5,49,0,
  	0,626,630,3,88,44,0,627,629,3,88,44,0,628,627,1,0,0,0,629,632,1,0,0,0,
  	630,628,1,0,0,0,630,631,1,0,0,0,631,633,1,0,0,0,632,630,1,0,0,0,633,634,
  	5,58,0,0,634,635,5,1,0,0,635,91,1,0,0,0,636,639,3,72,36,0,637,639,3,2,
  	1,0,638,636,1,0,0,0,638,637,1,0,0,0,639,93,1,0,0,0,640,641,5,157,0,0,
  	641,95,1,0,0,0,642,645,3,128,64,0,643,645,3,316,158,0,644,642,1,0,0,0,
  	644,643,1,0,0,0,645,97,1,0,0,0,646,652,3,112,56,0,647,652,3,142,71,0,
  	648,652,3,250,125,0,649,652,3,344,172,0,650,652,3,368,184,0,651,646,1,
  	0,0,0,651,647,1,0,0,0,651,648,1,0,0,0,651,649,1,0,0,0,651,650,1,0,0,0,
  	652,99,1,0,0,0,653,654,3,54,27,0,654,655,5,9,0,0,655,656,3,240,120,0,
  	656,657,5,10,0,0,657,658,3,134,67,0,658,659,5,1,0,0,659,101,1,0,0,0,660,
  	661,5,52,0,0,661,665,3,100,50,0,662,664,3,100,50,0,663,662,1,0,0,0,664,
  	667,1,0,0,0,665,663,1,0,0,0,665,666,1,0,0,0,666,103,1,0,0,0,667,665,1,
  	0,0,0,668,669,3,298,149,0,669,670,5,9,0,0,670,672,1,0,0,0,671,668,1,0,
  	0,0,671,672,1,0,0,0,672,673,1,0,0,0,673,674,3,134,67,0,674,105,1,0,0,
  	0,675,678,3,134,67,0,676,677,5,9,0,0,677,679,3,284,142,0,678,676,1,0,
  	0,0,678,679,1,0,0,0,679,107,1,0,0,0,680,682,3,132,66,0,681,680,1,0,0,
  	0,682,685,1,0,0,0,683,681,1,0,0,0,683,684,1,0,0,0,684,687,1,0,0,0,685,
  	683,1,0,0,0,686,688,3,102,51,0,687,686,1,0,0,0,687,688,1,0,0,0,688,690,
  	1,0,0,0,689,691,3,206,103,0,690,689,1,0,0,0,690,691,1,0,0,0,691,693,1,
  	0,0,0,692,694,3,380,190,0,693,692,1,0,0,0,693,694,1,0,0,0,694,696,1,0,
  	0,0,695,697,3,390,195,0,696,695,1,0,0,0,696,697,1,0,0,0,697,109,1,0,0,
  	0,698,699,3,4,2,0,699,708,5,2,0,0,700,705,3,134,67,0,701,702,5,3,0,0,
  	702,704,3,134,67,0,703,701,1,0,0,0,704,707,1,0,0,0,705,703,1,0,0,0,705,
  	706,1,0,0,0,706,709,1,0,0,0,707,705,1,0,0,0,708,700,1,0,0,0,708,709,1,
  	0,0,0,709,710,1,0,0,0,710,711,5,4,0,0,711,111,1,0,0,0,712,713,3,114,57,
  	0,713,714,3,108,54,0,714,715,5,59,0,0,715,716,5,1,0,0,716,113,1,0,0,0,
  	717,718,5,69,0,0,718,719,3,116,58,0,719,720,3,338,169,0,720,721,5,1,0,
  	0,721,115,1,0,0,0,722,723,5,157,0,0,723,117,1,0,0,0,724,725,5,42,0,0,
  	725,728,3,24,12,0,726,727,5,149,0,0,727,729,3,122,61,0,728,726,1,0,0,
  	0,728,729,1,0,0,0,729,119,1,0,0,0,730,731,5,157,0,0,731,121,1,0,0,0,732,
  	733,5,2,0,0,733,738,3,124,62,0,734,735,5,3,0,0,735,737,3,124,62,0,736,
  	734,1,0,0,0,737,740,1,0,0,0,738,736,1,0,0,0,738,739,1,0,0,0,739,741,1,
  	0,0,0,740,738,1,0,0,0,741,742,5,4,0,0,742,123,1,0,0,0,743,744,3,120,60,
  	0,744,125,1,0,0,0,745,746,3,24,12,0,746,747,5,11,0,0,747,749,1,0,0,0,
  	748,745,1,0,0,0,748,749,1,0,0,0,749,750,1,0,0,0,750,751,3,6,3,0,751,127,
  	1,0,0,0,752,754,5,74,0,0,753,752,1,0,0,0,753,754,1,0,0,0,754,755,1,0,
  	0,0,755,759,5,70,0,0,756,757,5,105,0,0,757,760,3,122,61,0,758,760,3,118,
  	59,0,759,756,1,0,0,0,759,758,1,0,0,0,759,760,1,0,0,0,760,129,1,0,0,0,
  	761,762,5,71,0,0,762,763,5,1,0,0,763,131,1,0,0,0,764,769,3,54,27,0,765,
  	766,5,3,0,0,766,768,3,54,27,0,767,765,1,0,0,0,768,771,1,0,0,0,769,767,
  	1,0,0,0,769,770,1,0,0,0,770,772,1,0,0,0,771,769,1,0,0,0,772,774,5,9,0,
  	0,773,775,5,107,0,0,774,773,1,0,0,0,774,775,1,0,0,0,775,776,1,0,0,0,776,
  	777,3,240,120,0,777,778,5,1,0,0,778,133,1,0,0,0,779,783,3,320,160,0,780,
  	781,3,276,138,0,781,782,3,320,160,0,782,784,1,0,0,0,783,780,1,0,0,0,783,
  	784,1,0,0,0,784,135,1,0,0,0,785,788,3,322,161,0,786,787,5,13,0,0,787,
  	789,3,322,161,0,788,786,1,0,0,0,788,789,1,0,0,0,789,137,1,0,0,0,790,795,
  	3,238,119,0,791,792,5,3,0,0,792,794,3,238,119,0,793,791,1,0,0,0,794,797,
  	1,0,0,0,795,793,1,0,0,0,795,796,1,0,0,0,796,798,1,0,0,0,797,795,1,0,0,
  	0,798,799,5,9,0,0,799,800,3,240,120,0,800,139,1,0,0,0,801,804,3,74,37,
  	0,802,804,3,8,4,0,803,801,1,0,0,0,803,802,1,0,0,0,804,806,1,0,0,0,805,
  	807,3,34,17,0,806,805,1,0,0,0,806,807,1,0,0,0,807,141,1,0,0,0,808,809,
  	3,144,72,0,809,810,3,46,23,0,810,814,3,332,166,0,811,813,3,332,166,0,
  	812,811,1,0,0,0,813,816,1,0,0,0,814,812,1,0,0,0,814,815,1,0,0,0,815,817,
  	1,0,0,0,816,814,1,0,0,0,817,818,5,60,0,0,818,819,5,1,0,0,819,143,1,0,
  	0,0,820,821,5,80,0,0,821,833,3,146,73,0,822,823,5,2,0,0,823,828,3,138,
  	69,0,824,825,5,1,0,0,825,827,3,138,69,0,826,824,1,0,0,0,827,830,1,0,0,
  	0,828,826,1,0,0,0,828,829,1,0,0,0,829,831,1,0,0,0,830,828,1,0,0,0,831,
  	832,5,4,0,0,832,834,1,0,0,0,833,822,1,0,0,0,833,834,1,0,0,0,834,835,1,
  	0,0,0,835,836,5,9,0,0,836,837,3,240,120,0,837,838,5,1,0,0,838,145,1,0,
  	0,0,839,840,5,157,0,0,840,147,1,0,0,0,841,846,3,42,21,0,842,846,3,150,
  	75,0,843,846,3,162,81,0,844,846,3,164,82,0,845,841,1,0,0,0,845,842,1,
  	0,0,0,845,843,1,0,0,0,845,844,1,0,0,0,846,149,1,0,0,0,847,852,3,152,76,
  	0,848,852,3,154,77,0,849,852,3,156,78,0,850,852,3,160,80,0,851,847,1,
  	0,0,0,851,848,1,0,0,0,851,849,1,0,0,0,851,850,1,0,0,0,852,151,1,0,0,0,
  	853,855,5,37,0,0,854,856,3,70,35,0,855,854,1,0,0,0,855,856,1,0,0,0,856,
  	857,1,0,0,0,857,859,5,105,0,0,858,860,5,107,0,0,859,858,1,0,0,0,859,860,
  	1,0,0,0,860,862,1,0,0,0,861,863,5,140,0,0,862,861,1,0,0,0,862,863,1,0,
  	0,0,863,864,1,0,0,0,864,865,3,240,120,0,865,153,1,0,0,0,866,868,5,41,
  	0,0,867,869,3,70,35,0,868,867,1,0,0,0,868,869,1,0,0,0,869,870,1,0,0,0,
  	870,871,5,105,0,0,871,872,3,240,120,0,872,155,1,0,0,0,873,875,5,92,0,
  	0,874,876,3,70,35,0,875,874,1,0,0,0,875,876,1,0,0,0,876,877,1,0,0,0,877,
  	879,5,105,0,0,878,880,5,140,0,0,879,878,1,0,0,0,879,880,1,0,0,0,880,881,
  	1,0,0,0,881,882,3,240,120,0,882,157,1,0,0,0,883,886,3,10,5,0,884,886,
  	3,388,194,0,885,883,1,0,0,0,885,884,1,0,0,0,886,159,1,0,0,0,887,889,5,
  	124,0,0,888,890,3,70,35,0,889,888,1,0,0,0,889,890,1,0,0,0,890,891,1,0,
  	0,0,891,892,5,105,0,0,892,893,3,240,120,0,893,161,1,0,0,0,894,897,5,82,
  	0,0,895,896,5,9,0,0,896,898,3,372,186,0,897,895,1,0,0,0,897,898,1,0,0,
  	0,898,163,1,0,0,0,899,902,5,81,0,0,900,901,5,9,0,0,901,903,3,372,186,
  	0,902,900,1,0,0,0,902,903,1,0,0,0,903,165,1,0,0,0,904,905,5,14,0,0,905,
  	906,3,4,2,0,906,167,1,0,0,0,907,908,5,85,0,0,908,909,3,216,108,0,909,
  	910,5,134,0,0,910,913,3,170,85,0,911,912,5,54,0,0,912,914,3,172,86,0,
  	913,911,1,0,0,0,913,914,1,0,0,0,914,915,1,0,0,0,915,916,5,61,0,0,916,
  	917,5,1,0,0,917,169,1,0,0,0,918,922,3,332,166,0,919,921,3,332,166,0,920,
  	919,1,0,0,0,921,924,1,0,0,0,922,920,1,0,0,0,922,923,1,0,0,0,923,171,1,
  	0,0,0,924,922,1,0,0,0,925,929,3,332,166,0,926,928,3,332,166,0,927,926,
  	1,0,0,0,928,931,1,0,0,0,929,927,1,0,0,0,929,930,1,0,0,0,930,173,1,0,0,
  	0,931,929,1,0,0,0,932,933,3,232,116,0,933,175,1,0,0,0,934,935,3,388,194,
  	0,935,936,5,10,0,0,936,937,3,66,33,0,937,938,5,135,0,0,938,941,3,68,34,
  	0,939,940,5,47,0,0,940,942,3,174,87,0,941,939,1,0,0,0,941,942,1,0,0,0,
  	942,177,1,0,0,0,943,944,3,232,116,0,944,179,1,0,0,0,945,946,3,178,89,
  	0,946,181,1,0,0,0,947,948,3,178,89,0,948,183,1,0,0,0,949,950,5,7,0,0,
  	950,953,3,180,90,0,951,952,5,9,0,0,952,954,3,182,91,0,953,951,1,0,0,0,
  	953,954,1,0,0,0,954,955,1,0,0,0,955,956,5,8,0,0,956,185,1,0,0,0,957,960,
  	3,86,43,0,958,960,3,4,2,0,959,957,1,0,0,0,959,958,1,0,0,0,960,187,1,0,
  	0,0,961,962,5,88,0,0,962,189,1,0,0,0,963,966,3,272,136,0,964,966,3,386,
  	193,0,965,963,1,0,0,0,965,964,1,0,0,0,966,191,1,0,0,0,967,968,5,15,0,
  	0,968,969,3,198,99,0,969,970,3,200,100,0,970,971,3,196,98,0,971,972,3,
  	200,100,0,972,973,3,194,97,0,973,974,5,16,0,0,974,193,1,0,0,0,975,976,
  	3,320,160,0,976,195,1,0,0,0,977,978,3,320,160,0,978,197,1,0,0,0,979,980,
  	3,320,160,0,980,199,1,0,0,0,981,982,7,4,0,0,982,201,1,0,0,0,983,984,3,
  	54,27,0,984,985,5,9,0,0,985,986,3,204,102,0,986,990,5,77,0,0,987,988,
  	3,4,2,0,988,989,5,11,0,0,989,991,1,0,0,0,990,987,1,0,0,0,990,991,1,0,
  	0,0,991,992,1,0,0,0,992,993,3,0,0,0,993,994,5,1,0,0,994,203,1,0,0,0,995,
  	997,7,5,0,0,996,998,3,70,35,0,997,996,1,0,0,0,997,998,1,0,0,0,998,999,
  	1,0,0,0,999,1001,5,105,0,0,1000,995,1,0,0,0,1000,1001,1,0,0,0,1001,1002,
  	1,0,0,0,1002,1003,3,4,2,0,1003,205,1,0,0,0,1004,1005,5,89,0,0,1005,1009,
  	3,202,101,0,1006,1008,3,202,101,0,1007,1006,1,0,0,0,1008,1011,1,0,0,0,
  	1009,1007,1,0,0,0,1009,1010,1,0,0,0,1010,207,1,0,0,0,1011,1009,1,0,0,
  	0,1012,1014,5,92,0,0,1013,1015,3,70,35,0,1014,1013,1,0,0,0,1014,1015,
  	1,0,0,0,1015,1016,1,0,0,0,1016,1018,5,105,0,0,1017,1019,5,140,0,0,1018,
  	1017,1,0,0,0,1018,1019,1,0,0,0,1019,1020,1,0,0,0,1020,1021,3,186,93,0,
  	1021,209,1,0,0,0,1022,1028,5,153,0,0,1023,1028,5,155,0,0,1024,1028,3,
  	218,109,0,1025,1028,5,156,0,0,1026,1028,3,334,167,0,1027,1022,1,0,0,0,
  	1027,1023,1,0,0,0,1027,1024,1,0,0,0,1027,1025,1,0,0,0,1027,1026,1,0,0,
  	0,1028,211,1,0,0,0,1029,1030,5,94,0,0,1030,1034,3,214,107,0,1031,1033,
  	3,214,107,0,1032,1031,1,0,0,0,1033,1036,1,0,0,0,1034,1032,1,0,0,0,1034,
  	1035,1,0,0,0,1035,1037,1,0,0,0,1036,1034,1,0,0,0,1037,1038,5,62,0,0,1038,
  	1039,5,1,0,0,1039,213,1,0,0,0,1040,1045,3,388,194,0,1041,1042,5,3,0,0,
  	1042,1044,3,388,194,0,1043,1041,1,0,0,0,1044,1047,1,0,0,0,1045,1043,1,
  	0,0,0,1045,1046,1,0,0,0,1046,1048,1,0,0,0,1047,1045,1,0,0,0,1048,1049,
  	5,9,0,0,1049,1052,3,240,120,0,1050,1051,5,10,0,0,1051,1053,3,134,67,0,
  	1052,1050,1,0,0,0,1052,1053,1,0,0,0,1053,1054,1,0,0,0,1054,1055,5,1,0,
  	0,1055,215,1,0,0,0,1056,1057,3,134,67,0,1057,217,1,0,0,0,1058,1059,7,
  	6,0,0,1059,219,1,0,0,0,1060,1061,5,98,0,0,1061,221,1,0,0,0,1062,1063,
  	7,7,0,0,1063,223,1,0,0,0,1064,1067,3,4,2,0,1065,1067,3,24,12,0,1066,1064,
  	1,0,0,0,1066,1065,1,0,0,0,1067,225,1,0,0,0,1068,1074,3,224,112,0,1069,
  	1072,5,38,0,0,1070,1073,3,116,58,0,1071,1073,3,370,185,0,1072,1070,1,
  	0,0,0,1072,1071,1,0,0,0,1073,1075,1,0,0,0,1074,1069,1,0,0,0,1074,1075,
  	1,0,0,0,1075,227,1,0,0,0,1076,1077,5,1,0,0,1077,229,1,0,0,0,1078,1079,
  	5,102,0,0,1079,231,1,0,0,0,1080,1081,3,320,160,0,1081,233,1,0,0,0,1082,
  	1083,5,106,0,0,1083,1084,5,2,0,0,1084,1089,3,354,177,0,1085,1086,5,3,
  	0,0,1086,1088,3,354,177,0,1087,1085,1,0,0,0,1088,1091,1,0,0,0,1089,1087,
  	1,0,0,0,1089,1090,1,0,0,0,1090,1092,1,0,0,0,1091,1089,1,0,0,0,1092,1093,
  	5,4,0,0,1093,235,1,0,0,0,1094,1095,3,134,67,0,1095,237,1,0,0,0,1096,1097,
  	5,157,0,0,1097,239,1,0,0,0,1098,1102,3,148,74,0,1099,1102,3,224,112,0,
  	1100,1102,3,328,164,0,1101,1098,1,0,0,0,1101,1099,1,0,0,0,1101,1100,1,
  	0,0,0,1102,241,1,0,0,0,1103,1104,3,4,2,0,1104,243,1,0,0,0,1105,1106,3,
  	232,116,0,1106,245,1,0,0,0,1107,1116,3,210,105,0,1108,1112,3,258,129,
  	0,1109,1111,3,262,131,0,1110,1109,1,0,0,0,1111,1114,1,0,0,0,1112,1110,
  	1,0,0,0,1112,1113,1,0,0,0,1113,1116,1,0,0,0,1114,1112,1,0,0,0,1115,1107,
  	1,0,0,0,1115,1108,1,0,0,0,1116,247,1,0,0,0,1117,1120,3,76,38,0,1118,1120,
  	3,12,6,0,1119,1117,1,0,0,0,1119,1118,1,0,0,0,1120,1122,1,0,0,0,1121,1123,
  	3,34,17,0,1122,1121,1,0,0,0,1122,1123,1,0,0,0,1123,1124,1,0,0,0,1124,
  	1125,5,1,0,0,1125,249,1,0,0,0,1126,1127,3,252,126,0,1127,1131,3,46,23,
  	0,1128,1130,3,332,166,0,1129,1128,1,0,0,0,1130,1133,1,0,0,0,1131,1129,
  	1,0,0,0,1131,1132,1,0,0,0,1132,1134,1,0,0,0,1133,1131,1,0,0,0,1134,1135,
  	5,63,0,0,1135,1136,5,1,0,0,1136,251,1,0,0,0,1137,1138,5,111,0,0,1138,
  	1150,3,256,128,0,1139,1140,5,2,0,0,1140,1145,3,254,127,0,1141,1142,5,
  	1,0,0,1142,1144,3,254,127,0,1143,1141,1,0,0,0,1144,1147,1,0,0,0,1145,
  	1143,1,0,0,0,1145,1146,1,0,0,0,1146,1148,1,0,0,0,1147,1145,1,0,0,0,1148,
  	1149,5,4,0,0,1149,1151,1,0,0,0,1150,1139,1,0,0,0,1150,1151,1,0,0,0,1151,
  	1152,1,0,0,0,1152,1153,5,1,0,0,1153,253,1,0,0,0,1154,1156,5,148,0,0,1155,
  	1154,1,0,0,0,1155,1156,1,0,0,0,1156,1157,1,0,0,0,1157,1158,3,138,69,0,
  	1158,255,1,0,0,0,1159,1160,5,157,0,0,1160,257,1,0,0,0,1161,1167,3,0,0,
  	0,1162,1167,3,92,46,0,1163,1167,3,140,70,0,1164,1167,3,158,79,0,1165,
  	1167,3,242,121,0,1166,1161,1,0,0,0,1166,1162,1,0,0,0,1166,1163,1,0,0,
  	0,1166,1164,1,0,0,0,1166,1165,1,0,0,0,1167,259,1,0,0,0,1168,1169,5,123,
  	0,0,1169,1170,3,166,83,0,1170,1171,3,58,29,0,1171,261,1,0,0,0,1172,1176,
  	3,58,29,0,1173,1176,3,166,83,0,1174,1176,3,184,92,0,1175,1172,1,0,0,0,
  	1175,1173,1,0,0,0,1175,1174,1,0,0,0,1176,263,1,0,0,0,1177,1178,5,112,
  	0,0,1178,1179,5,2,0,0,1179,1180,3,388,194,0,1180,1181,5,22,0,0,1181,1182,
  	3,40,20,0,1182,1183,5,23,0,0,1183,1184,3,216,108,0,1184,1185,5,4,0,0,
  	1185,265,1,0,0,0,1186,1191,5,113,0,0,1187,1188,5,2,0,0,1188,1189,3,244,
  	122,0,1189,1190,5,4,0,0,1190,1192,1,0,0,0,1191,1187,1,0,0,0,1191,1192,
  	1,0,0,0,1192,267,1,0,0,0,1193,1196,3,260,130,0,1194,1195,5,116,0,0,1195,
  	1197,3,56,28,0,1196,1194,1,0,0,0,1196,1197,1,0,0,0,1197,269,1,0,0,0,1198,
  	1201,3,0,0,0,1199,1201,3,260,130,0,1200,1198,1,0,0,0,1200,1199,1,0,0,
  	0,1201,271,1,0,0,0,1202,1203,5,114,0,0,1203,1204,5,79,0,0,1204,1216,3,
  	18,9,0,1205,1206,5,2,0,0,1206,1211,3,286,143,0,1207,1208,5,3,0,0,1208,
  	1210,3,286,143,0,1209,1207,1,0,0,0,1210,1213,1,0,0,0,1211,1209,1,0,0,
  	0,1211,1212,1,0,0,0,1212,1214,1,0,0,0,1213,1211,1,0,0,0,1214,1215,5,4,
  	0,0,1215,1217,1,0,0,0,1216,1205,1,0,0,0,1216,1217,1,0,0,0,1217,1218,1,
  	0,0,0,1218,1219,5,1,0,0,1219,273,1,0,0,0,1220,1221,7,8,0,0,1221,275,1,
  	0,0,0,1222,1226,3,274,137,0,1223,1226,5,86,0,0,1224,1226,5,91,0,0,1225,
  	1222,1,0,0,0,1225,1223,1,0,0,0,1225,1224,1,0,0,0,1226,277,1,0,0,0,1227,
  	1233,3,94,47,0,1228,1233,3,116,58,0,1229,1233,3,146,73,0,1230,1233,3,
  	256,128,0,1231,1233,3,370,185,0,1232,1227,1,0,0,0,1232,1228,1,0,0,0,1232,
  	1229,1,0,0,0,1232,1230,1,0,0,0,1232,1231,1,0,0,0,1233,279,1,0,0,0,1234,
  	1236,3,176,88,0,1235,1234,1,0,0,0,1235,1236,1,0,0,0,1236,1238,1,0,0,0,
  	1237,1239,3,392,196,0,1238,1237,1,0,0,0,1238,1239,1,0,0,0,1239,1241,1,
  	0,0,0,1240,1242,3,384,192,0,1241,1240,1,0,0,0,1241,1242,1,0,0,0,1242,
  	281,1,0,0,0,1243,1244,5,117,0,0,1244,1245,3,280,140,0,1245,1246,5,1,0,
  	0,1246,1250,3,332,166,0,1247,1249,3,332,166,0,1248,1247,1,0,0,0,1249,
  	1252,1,0,0,0,1250,1248,1,0,0,0,1250,1251,1,0,0,0,1251,1253,1,0,0,0,1252,
  	1250,1,0,0,0,1253,1254,5,64,0,0,1254,1255,5,1,0,0,1255,283,1,0,0,0,1256,
  	1257,3,232,116,0,1257,285,1,0,0,0,1258,1261,3,288,144,0,1259,1260,5,38,
  	0,0,1260,1262,3,278,139,0,1261,1259,1,0,0,0,1261,1262,1,0,0,0,1262,287,
  	1,0,0,0,1263,1269,3,2,1,0,1264,1269,3,4,2,0,1265,1269,3,8,4,0,1266,1269,
  	3,12,6,0,1267,1269,3,24,12,0,1268,1263,1,0,0,0,1268,1264,1,0,0,0,1268,
  	1265,1,0,0,0,1268,1266,1,0,0,0,1268,1267,1,0,0,0,1269,289,1,0,0,0,1270,
  	1275,5,118,0,0,1271,1272,5,2,0,0,1272,1273,3,134,67,0,1273,1274,5,4,0,
  	0,1274,1276,1,0,0,0,1275,1271,1,0,0,0,1275,1276,1,0,0,0,1276,1277,1,0,
  	0,0,1277,1278,5,1,0,0,1278,291,1,0,0,0,1279,1280,3,294,147,0,1280,1284,
  	3,46,23,0,1281,1283,3,332,166,0,1282,1281,1,0,0,0,1283,1286,1,0,0,0,1284,
  	1282,1,0,0,0,1284,1285,1,0,0,0,1285,1287,1,0,0,0,1286,1284,1,0,0,0,1287,
  	1288,3,390,195,0,1288,1289,5,65,0,0,1289,1290,5,1,0,0,1290,293,1,0,0,
  	0,1291,1292,5,120,0,0,1292,1293,3,296,148,0,1293,1294,5,77,0,0,1294,1295,
  	5,2,0,0,1295,1300,3,4,2,0,1296,1297,5,3,0,0,1297,1299,3,4,2,0,1298,1296,
  	1,0,0,0,1299,1302,1,0,0,0,1300,1298,1,0,0,0,1300,1301,1,0,0,0,1301,1303,
  	1,0,0,0,1302,1300,1,0,0,0,1303,1304,5,4,0,0,1304,1305,5,1,0,0,1305,295,
  	1,0,0,0,1306,1307,5,157,0,0,1307,297,1,0,0,0,1308,1309,5,157,0,0,1309,
  	299,1,0,0,0,1310,1312,3,190,95,0,1311,1310,1,0,0,0,1312,1315,1,0,0,0,
  	1313,1311,1,0,0,0,1313,1314,1,0,0,0,1314,1317,1,0,0,0,1315,1313,1,0,0,
  	0,1316,1318,3,90,45,0,1317,1316,1,0,0,0,1317,1318,1,0,0,0,1318,1322,1,
  	0,0,0,1319,1321,3,302,151,0,1320,1319,1,0,0,0,1321,1324,1,0,0,0,1322,
  	1320,1,0,0,0,1322,1323,1,0,0,0,1323,301,1,0,0,0,1324,1322,1,0,0,0,1325,
  	1328,3,98,49,0,1326,1328,3,292,146,0,1327,1325,1,0,0,0,1327,1326,1,0,
  	0,0,1328,303,1,0,0,0,1329,1330,5,121,0,0,1330,1332,3,306,153,0,1331,1333,
  	3,308,154,0,1332,1331,1,0,0,0,1332,1333,1,0,0,0,1333,1334,1,0,0,0,1334,
  	1335,5,1,0,0,1335,1336,3,300,150,0,1336,1337,5,66,0,0,1337,1338,5,1,0,
  	0,1338,305,1,0,0,0,1339,1340,5,157,0,0,1340,307,1,0,0,0,1341,1342,3,334,
  	167,0,1342,309,1,0,0,0,1343,1344,3,134,67,0,1344,311,1,0,0,0,1345,1346,
  	5,42,0,0,1346,1349,3,24,12,0,1347,1348,5,149,0,0,1348,1350,3,314,157,
  	0,1349,1347,1,0,0,0,1349,1350,1,0,0,0,1350,313,1,0,0,0,1351,1352,5,2,
  	0,0,1352,1357,3,224,112,0,1353,1354,5,3,0,0,1354,1356,3,224,112,0,1355,
  	1353,1,0,0,0,1356,1359,1,0,0,0,1357,1355,1,0,0,0,1357,1358,1,0,0,0,1358,
  	1360,1,0,0,0,1359,1357,1,0,0,0,1360,1361,5,4,0,0,1361,315,1,0,0,0,1362,
  	1364,5,74,0,0,1363,1365,5,82,0,0,1364,1363,1,0,0,0,1364,1365,1,0,0,0,
  	1365,1367,1,0,0,0,1366,1362,1,0,0,0,1366,1367,1,0,0,0,1367,1368,1,0,0,
  	0,1368,1371,5,122,0,0,1369,1372,3,314,157,0,1370,1372,3,312,156,0,1371,
  	1369,1,0,0,0,1371,1370,1,0,0,0,1371,1372,1,0,0,0,1372,317,1,0,0,0,1373,
  	1375,5,124,0,0,1374,1376,3,70,35,0,1375,1374,1,0,0,0,1375,1376,1,0,0,
  	0,1376,1377,1,0,0,0,1377,1378,5,105,0,0,1378,1379,3,186,93,0,1379,319,
  	1,0,0,0,1380,1386,3,364,182,0,1381,1382,3,36,18,0,1382,1383,3,364,182,
  	0,1383,1385,1,0,0,0,1384,1381,1,0,0,0,1385,1388,1,0,0,0,1386,1384,1,0,
  	0,0,1386,1387,1,0,0,0,1387,321,1,0,0,0,1388,1386,1,0,0,0,1389,1397,3,
  	38,19,0,1390,1397,3,110,55,0,1391,1397,3,126,63,0,1392,1397,3,192,96,
  	0,1393,1397,3,264,132,0,1394,1397,3,324,162,0,1395,1397,3,326,163,0,1396,
  	1389,1,0,0,0,1396,1390,1,0,0,0,1396,1391,1,0,0,0,1396,1392,1,0,0,0,1396,
  	1393,1,0,0,0,1396,1394,1,0,0,0,1396,1395,1,0,0,0,1397,323,1,0,0,0,1398,
  	1399,5,2,0,0,1399,1400,3,134,67,0,1400,1401,5,4,0,0,1401,1404,1,0,0,0,
  	1402,1404,3,246,123,0,1403,1398,1,0,0,0,1403,1402,1,0,0,0,1404,325,1,
  	0,0,0,1405,1406,3,376,188,0,1406,1407,3,324,162,0,1407,327,1,0,0,0,1408,
  	1416,3,62,31,0,1409,1416,3,64,32,0,1410,1416,3,188,94,0,1411,1416,3,220,
  	110,0,1412,1416,3,230,115,0,1413,1416,3,266,133,0,1414,1416,3,336,168,
  	0,1415,1408,1,0,0,0,1415,1409,1,0,0,0,1415,1410,1,0,0,0,1415,1411,1,0,
  	0,0,1415,1412,1,0,0,0,1415,1413,1,0,0,0,1415,1414,1,0,0,0,1416,329,1,
  	0,0,0,1417,1418,5,127,0,0,1418,1419,5,1,0,0,1419,331,1,0,0,0,1420,1432,
  	3,48,24,0,1421,1432,3,52,26,0,1422,1432,3,82,41,0,1423,1432,3,84,42,0,
  	1424,1432,3,130,65,0,1425,1432,3,168,84,0,1426,1432,3,228,114,0,1427,
  	1432,3,248,124,0,1428,1432,3,282,141,0,1429,1432,3,290,145,0,1430,1432,
  	3,330,165,0,1431,1420,1,0,0,0,1431,1421,1,0,0,0,1431,1422,1,0,0,0,1431,
  	1423,1,0,0,0,1431,1424,1,0,0,0,1431,1425,1,0,0,0,1431,1426,1,0,0,0,1431,
  	1427,1,0,0,0,1431,1428,1,0,0,0,1431,1429,1,0,0,0,1431,1430,1,0,0,0,1432,
  	333,1,0,0,0,1433,1434,7,9,0,0,1434,335,1,0,0,0,1435,1437,5,129,0,0,1436,
  	1438,3,396,198,0,1437,1436,1,0,0,0,1437,1438,1,0,0,0,1438,337,1,0,0,0,
  	1439,1441,3,352,176,0,1440,1439,1,0,0,0,1440,1441,1,0,0,0,1441,1443,1,
  	0,0,0,1442,1444,3,350,175,0,1443,1442,1,0,0,0,1443,1444,1,0,0,0,1444,
  	339,1,0,0,0,1445,1446,5,105,0,0,1446,1447,5,2,0,0,1447,1448,3,354,177,
  	0,1448,1449,5,4,0,0,1449,341,1,0,0,0,1450,1452,3,30,15,0,1451,1450,1,
  	0,0,0,1451,1452,1,0,0,0,1452,1454,1,0,0,0,1453,1455,3,366,183,0,1454,
  	1453,1,0,0,0,1454,1455,1,0,0,0,1455,1459,1,0,0,0,1456,1457,3,354,177,
  	0,1457,1458,5,1,0,0,1458,1460,1,0,0,0,1459,1456,1,0,0,0,1459,1460,1,0,
  	0,0,1460,343,1,0,0,0,1461,1462,3,346,173,0,1462,1463,3,342,171,0,1463,
  	1464,5,67,0,0,1464,1465,5,1,0,0,1465,345,1,0,0,0,1466,1467,5,131,0,0,
  	1467,1468,3,348,174,0,1468,1469,5,77,0,0,1469,1470,3,4,2,0,1470,1471,
  	5,1,0,0,1471,347,1,0,0,0,1472,1473,5,157,0,0,1473,349,1,0,0,0,1474,1475,
  	5,130,0,0,1475,1476,5,105,0,0,1476,1477,5,2,0,0,1477,1482,3,4,2,0,1478,
  	1479,5,3,0,0,1479,1481,3,4,2,0,1480,1478,1,0,0,0,1481,1484,1,0,0,0,1482,
  	1480,1,0,0,0,1482,1483,1,0,0,0,1483,1485,1,0,0,0,1484,1482,1,0,0,0,1485,
  	1486,5,4,0,0,1486,351,1,0,0,0,1487,1491,3,28,14,0,1488,1491,3,32,16,0,
  	1489,1491,3,358,179,0,1490,1487,1,0,0,0,1490,1488,1,0,0,0,1490,1489,1,
  	0,0,0,1491,353,1,0,0,0,1492,1497,3,356,178,0,1493,1494,5,36,0,0,1494,
  	1496,3,356,178,0,1495,1493,1,0,0,0,1496,1499,1,0,0,0,1497,1495,1,0,0,
  	0,1497,1498,1,0,0,0,1498,355,1,0,0,0,1499,1497,1,0,0,0,1500,1505,3,360,
  	180,0,1501,1502,5,35,0,0,1502,1504,3,360,180,0,1503,1501,1,0,0,0,1504,
  	1507,1,0,0,0,1505,1503,1,0,0,0,1505,1506,1,0,0,0,1506,357,1,0,0,0,1507,
  	1505,1,0,0,0,1508,1509,5,132,0,0,1509,1510,3,340,170,0,1510,359,1,0,0,
  	0,1511,1518,3,4,2,0,1512,1518,3,234,117,0,1513,1514,5,2,0,0,1514,1515,
  	3,354,177,0,1515,1516,5,4,0,0,1516,1518,1,0,0,0,1517,1511,1,0,0,0,1517,
  	1512,1,0,0,0,1517,1513,1,0,0,0,1518,361,1,0,0,0,1519,1521,3,304,152,0,
  	1520,1519,1,0,0,0,1521,1522,1,0,0,0,1522,1520,1,0,0,0,1522,1523,1,0,0,
  	0,1523,1524,1,0,0,0,1524,1525,5,0,0,1,1525,363,1,0,0,0,1526,1532,3,136,
  	68,0,1527,1528,3,222,111,0,1528,1529,3,136,68,0,1529,1531,1,0,0,0,1530,
  	1527,1,0,0,0,1531,1534,1,0,0,0,1532,1530,1,0,0,0,1532,1533,1,0,0,0,1533,
  	365,1,0,0,0,1534,1532,1,0,0,0,1535,1536,5,139,0,0,1536,1537,5,2,0,0,1537,
  	1542,3,4,2,0,1538,1539,5,3,0,0,1539,1541,3,4,2,0,1540,1538,1,0,0,0,1541,
  	1544,1,0,0,0,1542,1540,1,0,0,0,1542,1543,1,0,0,0,1543,1545,1,0,0,0,1544,
  	1542,1,0,0,0,1545,1546,5,4,0,0,1546,1547,5,1,0,0,1547,367,1,0,0,0,1548,
  	1549,5,137,0,0,1549,1550,3,370,185,0,1550,1551,5,27,0,0,1551,1552,3,378,
  	189,0,1552,1554,5,1,0,0,1553,1555,3,390,195,0,1554,1553,1,0,0,0,1554,
  	1555,1,0,0,0,1555,1556,1,0,0,0,1556,1557,5,68,0,0,1557,1558,5,1,0,0,1558,
  	369,1,0,0,0,1559,1560,5,157,0,0,1560,371,1,0,0,0,1561,1564,3,374,187,
  	0,1562,1564,3,22,11,0,1563,1561,1,0,0,0,1563,1562,1,0,0,0,1564,373,1,
  	0,0,0,1565,1566,5,157,0,0,1566,375,1,0,0,0,1567,1568,7,10,0,0,1568,377,
  	1,0,0,0,1569,1572,3,86,43,0,1570,1572,3,96,48,0,1571,1569,1,0,0,0,1571,
  	1570,1,0,0,0,1572,379,1,0,0,0,1573,1574,5,140,0,0,1574,1575,3,382,191,
  	0,1575,1581,5,1,0,0,1576,1577,3,382,191,0,1577,1578,5,1,0,0,1578,1580,
  	1,0,0,0,1579,1576,1,0,0,0,1580,1583,1,0,0,0,1581,1579,1,0,0,0,1581,1582,
  	1,0,0,0,1582,381,1,0,0,0,1583,1581,1,0,0,0,1584,1585,3,298,149,0,1585,
  	1586,5,9,0,0,1586,1588,1,0,0,0,1587,1584,1,0,0,0,1587,1588,1,0,0,0,1588,
  	1589,1,0,0,0,1589,1594,3,270,135,0,1590,1591,5,3,0,0,1591,1593,3,270,
  	135,0,1592,1590,1,0,0,0,1593,1596,1,0,0,0,1594,1592,1,0,0,0,1594,1595,
  	1,0,0,0,1595,383,1,0,0,0,1596,1594,1,0,0,0,1597,1598,5,142,0,0,1598,1599,
  	3,216,108,0,1599,385,1,0,0,0,1600,1601,5,143,0,0,1601,1602,5,79,0,0,1602,
  	1614,3,18,9,0,1603,1604,5,2,0,0,1604,1609,3,226,113,0,1605,1606,5,3,0,
  	0,1606,1608,3,226,113,0,1607,1605,1,0,0,0,1608,1611,1,0,0,0,1609,1607,
  	1,0,0,0,1609,1610,1,0,0,0,1610,1612,1,0,0,0,1611,1609,1,0,0,0,1612,1613,
  	5,4,0,0,1613,1615,1,0,0,0,1614,1603,1,0,0,0,1614,1615,1,0,0,0,1615,1616,
  	1,0,0,0,1616,1617,5,1,0,0,1617,387,1,0,0,0,1618,1619,5,157,0,0,1619,389,
  	1,0,0,0,1620,1621,5,150,0,0,1621,1622,3,104,52,0,1622,1628,5,1,0,0,1623,
  	1624,3,104,52,0,1624,1625,5,1,0,0,1625,1627,1,0,0,0,1626,1623,1,0,0,0,
  	1627,1630,1,0,0,0,1628,1626,1,0,0,0,1628,1629,1,0,0,0,1629,391,1,0,0,
  	0,1630,1628,1,0,0,0,1631,1632,5,151,0,0,1632,1633,3,216,108,0,1633,393,
  	1,0,0,0,1634,1635,3,232,116,0,1635,395,1,0,0,0,1636,1637,5,2,0,0,1637,
  	1638,3,394,197,0,1638,1640,5,4,0,0,1639,1641,5,76,0,0,1640,1639,1,0,0,
  	0,1640,1641,1,0,0,0,1641,397,1,0,0,0,151,435,443,456,459,468,477,482,
  	486,489,498,506,516,519,527,536,545,552,577,591,597,607,616,630,638,644,
  	651,665,671,678,683,687,690,693,696,705,708,728,738,748,753,759,769,774,
  	783,788,795,803,806,814,828,833,845,851,855,859,862,868,875,879,885,889,
  	897,902,913,922,929,941,953,959,965,990,997,1000,1009,1014,1018,1027,
  	1034,1045,1052,1066,1072,1074,1089,1101,1112,1115,1119,1122,1131,1145,
  	1150,1155,1166,1175,1191,1196,1200,1211,1216,1225,1232,1235,1238,1241,
  	1250,1261,1268,1275,1284,1300,1313,1317,1322,1327,1332,1349,1357,1364,
  	1366,1371,1375,1386,1396,1403,1415,1431,1437,1440,1443,1451,1454,1459,
  	1482,1490,1497,1505,1517,1522,1532,1542,1554,1563,1571,1581,1587,1594,
  	1609,1614,1628,1640
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  expressParserStaticData = staticData.release();
}

}

ExpressParser::ExpressParser(TokenStream *input) : ExpressParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

ExpressParser::ExpressParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  ExpressParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *expressParserStaticData->atn, expressParserStaticData->decisionToDFA, expressParserStaticData->sharedContextCache, options);
}

ExpressParser::~ExpressParser() {
  delete _interpreter;
}

const atn::ATN& ExpressParser::getATN() const {
  return *expressParserStaticData->atn;
}

std::string ExpressParser::getGrammarFileName() const {
  return "Express.g4";
}

const std::vector<std::string>& ExpressParser::getRuleNames() const {
  return expressParserStaticData->ruleNames;
}

const dfa::Vocabulary& ExpressParser::getVocabulary() const {
  return expressParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView ExpressParser::getSerializedATN() const {
  return expressParserStaticData->serializedATN;
}


//----------------- AttributeRefContext ------------------------------------------------------------------

ExpressParser::AttributeRefContext::AttributeRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::AttributeIdContext* ExpressParser::AttributeRefContext::attributeId() {
  return getRuleContext<ExpressParser::AttributeIdContext>(0);
}


size_t ExpressParser::AttributeRefContext::getRuleIndex() const {
  return ExpressParser::RuleAttributeRef;
}

void ExpressParser::AttributeRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributeRef(this);
}

void ExpressParser::AttributeRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributeRef(this);
}


std::any ExpressParser::AttributeRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitAttributeRef(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::AttributeRefContext* ExpressParser::attributeRef() {
  AttributeRefContext *_localctx = _tracker.createInstance<AttributeRefContext>(_ctx, getState());
  enterRule(_localctx, 0, ExpressParser::RuleAttributeRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(398);
    attributeId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstantRefContext ------------------------------------------------------------------

ExpressParser::ConstantRefContext::ConstantRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::ConstantIdContext* ExpressParser::ConstantRefContext::constantId() {
  return getRuleContext<ExpressParser::ConstantIdContext>(0);
}


size_t ExpressParser::ConstantRefContext::getRuleIndex() const {
  return ExpressParser::RuleConstantRef;
}

void ExpressParser::ConstantRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstantRef(this);
}

void ExpressParser::ConstantRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstantRef(this);
}


std::any ExpressParser::ConstantRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitConstantRef(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ConstantRefContext* ExpressParser::constantRef() {
  ConstantRefContext *_localctx = _tracker.createInstance<ConstantRefContext>(_ctx, getState());
  enterRule(_localctx, 2, ExpressParser::RuleConstantRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(400);
    constantId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EntityRefContext ------------------------------------------------------------------

ExpressParser::EntityRefContext::EntityRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::EntityIdContext* ExpressParser::EntityRefContext::entityId() {
  return getRuleContext<ExpressParser::EntityIdContext>(0);
}


size_t ExpressParser::EntityRefContext::getRuleIndex() const {
  return ExpressParser::RuleEntityRef;
}

void ExpressParser::EntityRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEntityRef(this);
}

void ExpressParser::EntityRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEntityRef(this);
}


std::any ExpressParser::EntityRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitEntityRef(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::EntityRefContext* ExpressParser::entityRef() {
  EntityRefContext *_localctx = _tracker.createInstance<EntityRefContext>(_ctx, getState());
  enterRule(_localctx, 4, ExpressParser::RuleEntityRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(402);
    entityId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumerationRefContext ------------------------------------------------------------------

ExpressParser::EnumerationRefContext::EnumerationRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::EnumerationIdContext* ExpressParser::EnumerationRefContext::enumerationId() {
  return getRuleContext<ExpressParser::EnumerationIdContext>(0);
}


size_t ExpressParser::EnumerationRefContext::getRuleIndex() const {
  return ExpressParser::RuleEnumerationRef;
}

void ExpressParser::EnumerationRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumerationRef(this);
}

void ExpressParser::EnumerationRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumerationRef(this);
}


std::any ExpressParser::EnumerationRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitEnumerationRef(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::EnumerationRefContext* ExpressParser::enumerationRef() {
  EnumerationRefContext *_localctx = _tracker.createInstance<EnumerationRefContext>(_ctx, getState());
  enterRule(_localctx, 6, ExpressParser::RuleEnumerationRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(404);
    enumerationId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionRefContext ------------------------------------------------------------------

ExpressParser::FunctionRefContext::FunctionRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::FunctionIdContext* ExpressParser::FunctionRefContext::functionId() {
  return getRuleContext<ExpressParser::FunctionIdContext>(0);
}


size_t ExpressParser::FunctionRefContext::getRuleIndex() const {
  return ExpressParser::RuleFunctionRef;
}

void ExpressParser::FunctionRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionRef(this);
}

void ExpressParser::FunctionRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionRef(this);
}


std::any ExpressParser::FunctionRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitFunctionRef(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::FunctionRefContext* ExpressParser::functionRef() {
  FunctionRefContext *_localctx = _tracker.createInstance<FunctionRefContext>(_ctx, getState());
  enterRule(_localctx, 8, ExpressParser::RuleFunctionRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(406);
    functionId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterRefContext ------------------------------------------------------------------

ExpressParser::ParameterRefContext::ParameterRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::ParameterIdContext* ExpressParser::ParameterRefContext::parameterId() {
  return getRuleContext<ExpressParser::ParameterIdContext>(0);
}


size_t ExpressParser::ParameterRefContext::getRuleIndex() const {
  return ExpressParser::RuleParameterRef;
}

void ExpressParser::ParameterRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameterRef(this);
}

void ExpressParser::ParameterRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameterRef(this);
}


std::any ExpressParser::ParameterRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitParameterRef(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ParameterRefContext* ExpressParser::parameterRef() {
  ParameterRefContext *_localctx = _tracker.createInstance<ParameterRefContext>(_ctx, getState());
  enterRule(_localctx, 10, ExpressParser::RuleParameterRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(408);
    parameterId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcedureRefContext ------------------------------------------------------------------

ExpressParser::ProcedureRefContext::ProcedureRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::ProcedureIdContext* ExpressParser::ProcedureRefContext::procedureId() {
  return getRuleContext<ExpressParser::ProcedureIdContext>(0);
}


size_t ExpressParser::ProcedureRefContext::getRuleIndex() const {
  return ExpressParser::RuleProcedureRef;
}

void ExpressParser::ProcedureRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedureRef(this);
}

void ExpressParser::ProcedureRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedureRef(this);
}


std::any ExpressParser::ProcedureRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitProcedureRef(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ProcedureRefContext* ExpressParser::procedureRef() {
  ProcedureRefContext *_localctx = _tracker.createInstance<ProcedureRefContext>(_ctx, getState());
  enterRule(_localctx, 12, ExpressParser::RuleProcedureRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(410);
    procedureId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RuleLabelRefContext ------------------------------------------------------------------

ExpressParser::RuleLabelRefContext::RuleLabelRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::RuleLabelIdContext* ExpressParser::RuleLabelRefContext::ruleLabelId() {
  return getRuleContext<ExpressParser::RuleLabelIdContext>(0);
}


size_t ExpressParser::RuleLabelRefContext::getRuleIndex() const {
  return ExpressParser::RuleRuleLabelRef;
}

void ExpressParser::RuleLabelRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRuleLabelRef(this);
}

void ExpressParser::RuleLabelRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRuleLabelRef(this);
}


std::any ExpressParser::RuleLabelRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitRuleLabelRef(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::RuleLabelRefContext* ExpressParser::ruleLabelRef() {
  RuleLabelRefContext *_localctx = _tracker.createInstance<RuleLabelRefContext>(_ctx, getState());
  enterRule(_localctx, 14, ExpressParser::RuleRuleLabelRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(412);
    ruleLabelId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RuleRefContext ------------------------------------------------------------------

ExpressParser::RuleRefContext::RuleRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::RuleIdContext* ExpressParser::RuleRefContext::ruleId() {
  return getRuleContext<ExpressParser::RuleIdContext>(0);
}


size_t ExpressParser::RuleRefContext::getRuleIndex() const {
  return ExpressParser::RuleRuleRef;
}

void ExpressParser::RuleRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRuleRef(this);
}

void ExpressParser::RuleRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRuleRef(this);
}


std::any ExpressParser::RuleRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitRuleRef(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::RuleRefContext* ExpressParser::ruleRef() {
  RuleRefContext *_localctx = _tracker.createInstance<RuleRefContext>(_ctx, getState());
  enterRule(_localctx, 16, ExpressParser::RuleRuleRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(414);
    ruleId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SchemaRefContext ------------------------------------------------------------------

ExpressParser::SchemaRefContext::SchemaRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::SchemaIdContext* ExpressParser::SchemaRefContext::schemaId() {
  return getRuleContext<ExpressParser::SchemaIdContext>(0);
}


size_t ExpressParser::SchemaRefContext::getRuleIndex() const {
  return ExpressParser::RuleSchemaRef;
}

void ExpressParser::SchemaRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchemaRef(this);
}

void ExpressParser::SchemaRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchemaRef(this);
}


std::any ExpressParser::SchemaRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSchemaRef(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SchemaRefContext* ExpressParser::schemaRef() {
  SchemaRefContext *_localctx = _tracker.createInstance<SchemaRefContext>(_ctx, getState());
  enterRule(_localctx, 18, ExpressParser::RuleSchemaRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(416);
    schemaId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubtypeConstraintRefContext ------------------------------------------------------------------

ExpressParser::SubtypeConstraintRefContext::SubtypeConstraintRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::SubtypeConstraintIdContext* ExpressParser::SubtypeConstraintRefContext::subtypeConstraintId() {
  return getRuleContext<ExpressParser::SubtypeConstraintIdContext>(0);
}


size_t ExpressParser::SubtypeConstraintRefContext::getRuleIndex() const {
  return ExpressParser::RuleSubtypeConstraintRef;
}

void ExpressParser::SubtypeConstraintRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubtypeConstraintRef(this);
}

void ExpressParser::SubtypeConstraintRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubtypeConstraintRef(this);
}


std::any ExpressParser::SubtypeConstraintRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSubtypeConstraintRef(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SubtypeConstraintRefContext* ExpressParser::subtypeConstraintRef() {
  SubtypeConstraintRefContext *_localctx = _tracker.createInstance<SubtypeConstraintRefContext>(_ctx, getState());
  enterRule(_localctx, 20, ExpressParser::RuleSubtypeConstraintRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(418);
    subtypeConstraintId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeLabelRefContext ------------------------------------------------------------------

ExpressParser::TypeLabelRefContext::TypeLabelRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::TypeLabelIdContext* ExpressParser::TypeLabelRefContext::typeLabelId() {
  return getRuleContext<ExpressParser::TypeLabelIdContext>(0);
}


size_t ExpressParser::TypeLabelRefContext::getRuleIndex() const {
  return ExpressParser::RuleTypeLabelRef;
}

void ExpressParser::TypeLabelRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeLabelRef(this);
}

void ExpressParser::TypeLabelRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeLabelRef(this);
}


std::any ExpressParser::TypeLabelRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitTypeLabelRef(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::TypeLabelRefContext* ExpressParser::typeLabelRef() {
  TypeLabelRefContext *_localctx = _tracker.createInstance<TypeLabelRefContext>(_ctx, getState());
  enterRule(_localctx, 22, ExpressParser::RuleTypeLabelRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(420);
    typeLabelId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeRefContext ------------------------------------------------------------------

ExpressParser::TypeRefContext::TypeRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::TypeIdContext* ExpressParser::TypeRefContext::typeId() {
  return getRuleContext<ExpressParser::TypeIdContext>(0);
}


size_t ExpressParser::TypeRefContext::getRuleIndex() const {
  return ExpressParser::RuleTypeRef;
}

void ExpressParser::TypeRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeRef(this);
}

void ExpressParser::TypeRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeRef(this);
}


std::any ExpressParser::TypeRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitTypeRef(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::TypeRefContext* ExpressParser::typeRef() {
  TypeRefContext *_localctx = _tracker.createInstance<TypeRefContext>(_ctx, getState());
  enterRule(_localctx, 24, ExpressParser::RuleTypeRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(422);
    typeId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableRefContext ------------------------------------------------------------------

ExpressParser::VariableRefContext::VariableRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::VariableIdContext* ExpressParser::VariableRefContext::variableId() {
  return getRuleContext<ExpressParser::VariableIdContext>(0);
}


size_t ExpressParser::VariableRefContext::getRuleIndex() const {
  return ExpressParser::RuleVariableRef;
}

void ExpressParser::VariableRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableRef(this);
}

void ExpressParser::VariableRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableRef(this);
}


std::any ExpressParser::VariableRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitVariableRef(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::VariableRefContext* ExpressParser::variableRef() {
  VariableRefContext *_localctx = _tracker.createInstance<VariableRefContext>(_ctx, getState());
  enterRule(_localctx, 26, ExpressParser::RuleVariableRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(424);
    variableId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AbstractEntityDeclarationContext ------------------------------------------------------------------

ExpressParser::AbstractEntityDeclarationContext::AbstractEntityDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::AbstractEntityDeclarationContext::ABSTRACT() {
  return getToken(ExpressParser::ABSTRACT, 0);
}


size_t ExpressParser::AbstractEntityDeclarationContext::getRuleIndex() const {
  return ExpressParser::RuleAbstractEntityDeclaration;
}

void ExpressParser::AbstractEntityDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAbstractEntityDeclaration(this);
}

void ExpressParser::AbstractEntityDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAbstractEntityDeclaration(this);
}


std::any ExpressParser::AbstractEntityDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitAbstractEntityDeclaration(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::AbstractEntityDeclarationContext* ExpressParser::abstractEntityDeclaration() {
  AbstractEntityDeclarationContext *_localctx = _tracker.createInstance<AbstractEntityDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 28, ExpressParser::RuleAbstractEntityDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(426);
    match(ExpressParser::ABSTRACT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AbstractSupertypeContext ------------------------------------------------------------------

ExpressParser::AbstractSupertypeContext::AbstractSupertypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::AbstractSupertypeContext::ABSTRACT() {
  return getToken(ExpressParser::ABSTRACT, 0);
}

tree::TerminalNode* ExpressParser::AbstractSupertypeContext::SUPERTYPE() {
  return getToken(ExpressParser::SUPERTYPE, 0);
}


size_t ExpressParser::AbstractSupertypeContext::getRuleIndex() const {
  return ExpressParser::RuleAbstractSupertype;
}

void ExpressParser::AbstractSupertypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAbstractSupertype(this);
}

void ExpressParser::AbstractSupertypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAbstractSupertype(this);
}


std::any ExpressParser::AbstractSupertypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitAbstractSupertype(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::AbstractSupertypeContext* ExpressParser::abstractSupertype() {
  AbstractSupertypeContext *_localctx = _tracker.createInstance<AbstractSupertypeContext>(_ctx, getState());
  enterRule(_localctx, 30, ExpressParser::RuleAbstractSupertype);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(428);
    match(ExpressParser::ABSTRACT);
    setState(429);
    match(ExpressParser::SUPERTYPE);
    setState(430);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AbstractSupertypeDeclarationContext ------------------------------------------------------------------

ExpressParser::AbstractSupertypeDeclarationContext::AbstractSupertypeDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::AbstractSupertypeDeclarationContext::ABSTRACT() {
  return getToken(ExpressParser::ABSTRACT, 0);
}

tree::TerminalNode* ExpressParser::AbstractSupertypeDeclarationContext::SUPERTYPE() {
  return getToken(ExpressParser::SUPERTYPE, 0);
}

ExpressParser::SubtypeConstraintContext* ExpressParser::AbstractSupertypeDeclarationContext::subtypeConstraint() {
  return getRuleContext<ExpressParser::SubtypeConstraintContext>(0);
}


size_t ExpressParser::AbstractSupertypeDeclarationContext::getRuleIndex() const {
  return ExpressParser::RuleAbstractSupertypeDeclaration;
}

void ExpressParser::AbstractSupertypeDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAbstractSupertypeDeclaration(this);
}

void ExpressParser::AbstractSupertypeDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAbstractSupertypeDeclaration(this);
}


std::any ExpressParser::AbstractSupertypeDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitAbstractSupertypeDeclaration(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::AbstractSupertypeDeclarationContext* ExpressParser::abstractSupertypeDeclaration() {
  AbstractSupertypeDeclarationContext *_localctx = _tracker.createInstance<AbstractSupertypeDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 32, ExpressParser::RuleAbstractSupertypeDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(432);
    match(ExpressParser::ABSTRACT);
    setState(433);
    match(ExpressParser::SUPERTYPE);
    setState(435);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::OF) {
      setState(434);
      subtypeConstraint();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ActualParameterListContext ------------------------------------------------------------------

ExpressParser::ActualParameterListContext::ActualParameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExpressParser::ParameterContext *> ExpressParser::ActualParameterListContext::parameter() {
  return getRuleContexts<ExpressParser::ParameterContext>();
}

ExpressParser::ParameterContext* ExpressParser::ActualParameterListContext::parameter(size_t i) {
  return getRuleContext<ExpressParser::ParameterContext>(i);
}


size_t ExpressParser::ActualParameterListContext::getRuleIndex() const {
  return ExpressParser::RuleActualParameterList;
}

void ExpressParser::ActualParameterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterActualParameterList(this);
}

void ExpressParser::ActualParameterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitActualParameterList(this);
}


std::any ExpressParser::ActualParameterListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitActualParameterList(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ActualParameterListContext* ExpressParser::actualParameterList() {
  ActualParameterListContext *_localctx = _tracker.createInstance<ActualParameterListContext>(_ctx, getState());
  enterRule(_localctx, 34, ExpressParser::RuleActualParameterList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(437);
    match(ExpressParser::T__1);
    setState(438);
    parameter();
    setState(443);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExpressParser::T__2) {
      setState(439);
      match(ExpressParser::T__2);
      setState(440);
      parameter();
      setState(445);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(446);
    match(ExpressParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AddLikeOpContext ------------------------------------------------------------------

ExpressParser::AddLikeOpContext::AddLikeOpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::AddLikeOpContext::OR() {
  return getToken(ExpressParser::OR, 0);
}

tree::TerminalNode* ExpressParser::AddLikeOpContext::XOR() {
  return getToken(ExpressParser::XOR, 0);
}


size_t ExpressParser::AddLikeOpContext::getRuleIndex() const {
  return ExpressParser::RuleAddLikeOp;
}

void ExpressParser::AddLikeOpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAddLikeOp(this);
}

void ExpressParser::AddLikeOpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAddLikeOp(this);
}


std::any ExpressParser::AddLikeOpContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitAddLikeOp(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::AddLikeOpContext* ExpressParser::addLikeOp() {
  AddLikeOpContext *_localctx = _tracker.createInstance<AddLikeOpContext>(_ctx, getState());
  enterRule(_localctx, 36, ExpressParser::RuleAddLikeOp);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(448);
    _la = _input->LA(1);
    if (!(_la == ExpressParser::T__4

    || _la == ExpressParser::T__5 || _la == ExpressParser::OR

    || _la == ExpressParser::XOR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AggregateInitializerContext ------------------------------------------------------------------

ExpressParser::AggregateInitializerContext::AggregateInitializerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExpressParser::ElementContext *> ExpressParser::AggregateInitializerContext::element() {
  return getRuleContexts<ExpressParser::ElementContext>();
}

ExpressParser::ElementContext* ExpressParser::AggregateInitializerContext::element(size_t i) {
  return getRuleContext<ExpressParser::ElementContext>(i);
}


size_t ExpressParser::AggregateInitializerContext::getRuleIndex() const {
  return ExpressParser::RuleAggregateInitializer;
}

void ExpressParser::AggregateInitializerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAggregateInitializer(this);
}

void ExpressParser::AggregateInitializerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAggregateInitializer(this);
}


std::any ExpressParser::AggregateInitializerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitAggregateInitializer(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::AggregateInitializerContext* ExpressParser::aggregateInitializer() {
  AggregateInitializerContext *_localctx = _tracker.createInstance<AggregateInitializerContext>(_ctx, getState());
  enterRule(_localctx, 38, ExpressParser::RuleAggregateInitializer);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(450);
    match(ExpressParser::T__6);
    setState(459);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << ExpressParser::T__1)
      | (1ULL << ExpressParser::T__4)
      | (1ULL << ExpressParser::T__5)
      | (1ULL << ExpressParser::T__6)
      | (1ULL << ExpressParser::T__11)
      | (1ULL << ExpressParser::T__14)
      | (1ULL << ExpressParser::ABS)
      | (1ULL << ExpressParser::ACOS)
      | (1ULL << ExpressParser::ASIN)
      | (1ULL << ExpressParser::ATAN)
      | (1ULL << ExpressParser::BLENGTH)
      | (1ULL << ExpressParser::CONST_E)
      | (1ULL << ExpressParser::COS))) != 0) || ((((_la - 72) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 72)) & ((1ULL << (ExpressParser::EXISTS - 72))
      | (1ULL << (ExpressParser::EXP - 72))
      | (1ULL << (ExpressParser::FALSE - 72))
      | (1ULL << (ExpressParser::FORMAT - 72))
      | (1ULL << (ExpressParser::HIBOUND - 72))
      | (1ULL << (ExpressParser::HIINDEX - 72))
      | (1ULL << (ExpressParser::LENGTH - 72))
      | (1ULL << (ExpressParser::LOBOUND - 72))
      | (1ULL << (ExpressParser::LOG - 72))
      | (1ULL << (ExpressParser::LOG10 - 72))
      | (1ULL << (ExpressParser::LOG2 - 72))
      | (1ULL << (ExpressParser::LOINDEX - 72))
      | (1ULL << (ExpressParser::NOT - 72))
      | (1ULL << (ExpressParser::NVL - 72))
      | (1ULL << (ExpressParser::ODD - 72))
      | (1ULL << (ExpressParser::PI - 72))
      | (1ULL << (ExpressParser::QUERY - 72))
      | (1ULL << (ExpressParser::ROLESOF - 72))
      | (1ULL << (ExpressParser::SELF - 72))
      | (1ULL << (ExpressParser::SIN - 72))
      | (1ULL << (ExpressParser::SIZEOF - 72))
      | (1ULL << (ExpressParser::SQRT - 72))
      | (1ULL << (ExpressParser::TAN - 72)))) != 0) || ((((_la - 136) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 136)) & ((1ULL << (ExpressParser::TRUE - 136))
      | (1ULL << (ExpressParser::TYPEOF - 136))
      | (1ULL << (ExpressParser::UNKNOWN - 136))
      | (1ULL << (ExpressParser::USEDIN - 136))
      | (1ULL << (ExpressParser::VALUE_ - 136))
      | (1ULL << (ExpressParser::VALUE_IN - 136))
      | (1ULL << (ExpressParser::VALUE_UNIQUE - 136))
      | (1ULL << (ExpressParser::BinaryLiteral - 136))
      | (1ULL << (ExpressParser::EncodedStringLiteral - 136))
      | (1ULL << (ExpressParser::IntegerLiteral - 136))
      | (1ULL << (ExpressParser::RealLiteral - 136))
      | (1ULL << (ExpressParser::SimpleId - 136))
      | (1ULL << (ExpressParser::SimpleStringLiteral - 136)))) != 0)) {
      setState(451);
      element();
      setState(456);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == ExpressParser::T__2) {
        setState(452);
        match(ExpressParser::T__2);
        setState(453);
        element();
        setState(458);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(461);
    match(ExpressParser::T__7);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AggregateSourceContext ------------------------------------------------------------------

ExpressParser::AggregateSourceContext::AggregateSourceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::SimpleExpressionContext* ExpressParser::AggregateSourceContext::simpleExpression() {
  return getRuleContext<ExpressParser::SimpleExpressionContext>(0);
}


size_t ExpressParser::AggregateSourceContext::getRuleIndex() const {
  return ExpressParser::RuleAggregateSource;
}

void ExpressParser::AggregateSourceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAggregateSource(this);
}

void ExpressParser::AggregateSourceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAggregateSource(this);
}


std::any ExpressParser::AggregateSourceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitAggregateSource(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::AggregateSourceContext* ExpressParser::aggregateSource() {
  AggregateSourceContext *_localctx = _tracker.createInstance<AggregateSourceContext>(_ctx, getState());
  enterRule(_localctx, 40, ExpressParser::RuleAggregateSource);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(463);
    simpleExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AggregateTypeContext ------------------------------------------------------------------

ExpressParser::AggregateTypeContext::AggregateTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::AggregateTypeContext::AGGREGATE() {
  return getToken(ExpressParser::AGGREGATE, 0);
}

tree::TerminalNode* ExpressParser::AggregateTypeContext::OF() {
  return getToken(ExpressParser::OF, 0);
}

ExpressParser::ParameterTypeContext* ExpressParser::AggregateTypeContext::parameterType() {
  return getRuleContext<ExpressParser::ParameterTypeContext>(0);
}

ExpressParser::TypeLabelContext* ExpressParser::AggregateTypeContext::typeLabel() {
  return getRuleContext<ExpressParser::TypeLabelContext>(0);
}


size_t ExpressParser::AggregateTypeContext::getRuleIndex() const {
  return ExpressParser::RuleAggregateType;
}

void ExpressParser::AggregateTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAggregateType(this);
}

void ExpressParser::AggregateTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAggregateType(this);
}


std::any ExpressParser::AggregateTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitAggregateType(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::AggregateTypeContext* ExpressParser::aggregateType() {
  AggregateTypeContext *_localctx = _tracker.createInstance<AggregateTypeContext>(_ctx, getState());
  enterRule(_localctx, 42, ExpressParser::RuleAggregateType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(465);
    match(ExpressParser::AGGREGATE);
    setState(468);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::T__8) {
      setState(466);
      match(ExpressParser::T__8);
      setState(467);
      typeLabel();
    }
    setState(470);
    match(ExpressParser::OF);
    setState(471);
    parameterType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AggregationTypesContext ------------------------------------------------------------------

ExpressParser::AggregationTypesContext::AggregationTypesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::ArrayTypeContext* ExpressParser::AggregationTypesContext::arrayType() {
  return getRuleContext<ExpressParser::ArrayTypeContext>(0);
}

ExpressParser::BagTypeContext* ExpressParser::AggregationTypesContext::bagType() {
  return getRuleContext<ExpressParser::BagTypeContext>(0);
}

ExpressParser::ListTypeContext* ExpressParser::AggregationTypesContext::listType() {
  return getRuleContext<ExpressParser::ListTypeContext>(0);
}

ExpressParser::SetTypeContext* ExpressParser::AggregationTypesContext::setType() {
  return getRuleContext<ExpressParser::SetTypeContext>(0);
}


size_t ExpressParser::AggregationTypesContext::getRuleIndex() const {
  return ExpressParser::RuleAggregationTypes;
}

void ExpressParser::AggregationTypesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAggregationTypes(this);
}

void ExpressParser::AggregationTypesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAggregationTypes(this);
}


std::any ExpressParser::AggregationTypesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitAggregationTypes(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::AggregationTypesContext* ExpressParser::aggregationTypes() {
  AggregationTypesContext *_localctx = _tracker.createInstance<AggregationTypesContext>(_ctx, getState());
  enterRule(_localctx, 44, ExpressParser::RuleAggregationTypes);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(477);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExpressParser::ARRAY: {
        enterOuterAlt(_localctx, 1);
        setState(473);
        arrayType();
        break;
      }

      case ExpressParser::BAG: {
        enterOuterAlt(_localctx, 2);
        setState(474);
        bagType();
        break;
      }

      case ExpressParser::LIST: {
        enterOuterAlt(_localctx, 3);
        setState(475);
        listType();
        break;
      }

      case ExpressParser::SET: {
        enterOuterAlt(_localctx, 4);
        setState(476);
        setType();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlgorithmHeadContext ------------------------------------------------------------------

ExpressParser::AlgorithmHeadContext::AlgorithmHeadContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExpressParser::DeclarationContext *> ExpressParser::AlgorithmHeadContext::declaration() {
  return getRuleContexts<ExpressParser::DeclarationContext>();
}

ExpressParser::DeclarationContext* ExpressParser::AlgorithmHeadContext::declaration(size_t i) {
  return getRuleContext<ExpressParser::DeclarationContext>(i);
}

ExpressParser::ConstantDeclContext* ExpressParser::AlgorithmHeadContext::constantDecl() {
  return getRuleContext<ExpressParser::ConstantDeclContext>(0);
}

ExpressParser::LocalDeclContext* ExpressParser::AlgorithmHeadContext::localDecl() {
  return getRuleContext<ExpressParser::LocalDeclContext>(0);
}


size_t ExpressParser::AlgorithmHeadContext::getRuleIndex() const {
  return ExpressParser::RuleAlgorithmHead;
}

void ExpressParser::AlgorithmHeadContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlgorithmHead(this);
}

void ExpressParser::AlgorithmHeadContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlgorithmHead(this);
}


std::any ExpressParser::AlgorithmHeadContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitAlgorithmHead(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::AlgorithmHeadContext* ExpressParser::algorithmHead() {
  AlgorithmHeadContext *_localctx = _tracker.createInstance<AlgorithmHeadContext>(_ctx, getState());
  enterRule(_localctx, 46, ExpressParser::RuleAlgorithmHead);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(482);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 69) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 69)) & ((1ULL << (ExpressParser::ENTITY - 69))
      | (1ULL << (ExpressParser::FUNCTION - 69))
      | (1ULL << (ExpressParser::PROCEDURE - 69))
      | (1ULL << (ExpressParser::SUBTYPE_CONSTRAINT - 69)))) != 0) || _la == ExpressParser::TYPE) {
      setState(479);
      declaration();
      setState(484);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(486);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::CONSTANT) {
      setState(485);
      constantDecl();
    }
    setState(489);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::LOCAL) {
      setState(488);
      localDecl();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AliasStmtContext ------------------------------------------------------------------

ExpressParser::AliasStmtContext::AliasStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::AliasStmtContext::ALIAS() {
  return getToken(ExpressParser::ALIAS, 0);
}

ExpressParser::VariableIdContext* ExpressParser::AliasStmtContext::variableId() {
  return getRuleContext<ExpressParser::VariableIdContext>(0);
}

tree::TerminalNode* ExpressParser::AliasStmtContext::FOR() {
  return getToken(ExpressParser::FOR, 0);
}

ExpressParser::GeneralRefContext* ExpressParser::AliasStmtContext::generalRef() {
  return getRuleContext<ExpressParser::GeneralRefContext>(0);
}

std::vector<ExpressParser::StmtContext *> ExpressParser::AliasStmtContext::stmt() {
  return getRuleContexts<ExpressParser::StmtContext>();
}

ExpressParser::StmtContext* ExpressParser::AliasStmtContext::stmt(size_t i) {
  return getRuleContext<ExpressParser::StmtContext>(i);
}

tree::TerminalNode* ExpressParser::AliasStmtContext::END_ALIAS() {
  return getToken(ExpressParser::END_ALIAS, 0);
}

std::vector<ExpressParser::QualifierContext *> ExpressParser::AliasStmtContext::qualifier() {
  return getRuleContexts<ExpressParser::QualifierContext>();
}

ExpressParser::QualifierContext* ExpressParser::AliasStmtContext::qualifier(size_t i) {
  return getRuleContext<ExpressParser::QualifierContext>(i);
}


size_t ExpressParser::AliasStmtContext::getRuleIndex() const {
  return ExpressParser::RuleAliasStmt;
}

void ExpressParser::AliasStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAliasStmt(this);
}

void ExpressParser::AliasStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAliasStmt(this);
}


std::any ExpressParser::AliasStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitAliasStmt(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::AliasStmtContext* ExpressParser::aliasStmt() {
  AliasStmtContext *_localctx = _tracker.createInstance<AliasStmtContext>(_ctx, getState());
  enterRule(_localctx, 48, ExpressParser::RuleAliasStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(491);
    match(ExpressParser::ALIAS);
    setState(492);
    variableId();
    setState(493);
    match(ExpressParser::FOR);
    setState(494);
    generalRef();
    setState(498);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << ExpressParser::T__6)
      | (1ULL << ExpressParser::T__10)
      | (1ULL << ExpressParser::T__13))) != 0)) {
      setState(495);
      qualifier();
      setState(500);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(501);
    match(ExpressParser::T__0);
    setState(502);
    stmt();
    setState(506);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << ExpressParser::T__0)
      | (1ULL << ExpressParser::ALIAS)
      | (1ULL << ExpressParser::BEGIN_)
      | (1ULL << ExpressParser::CASE))) != 0) || ((((_la - 71) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 71)) & ((1ULL << (ExpressParser::ESCAPE - 71))
      | (1ULL << (ExpressParser::IF - 71))
      | (1ULL << (ExpressParser::INSERT - 71))
      | (1ULL << (ExpressParser::REMOVE - 71))
      | (1ULL << (ExpressParser::REPEAT - 71))
      | (1ULL << (ExpressParser::RETURN - 71))
      | (1ULL << (ExpressParser::SKIP_ - 71)))) != 0) || _la == ExpressParser::SimpleId) {
      setState(503);
      stmt();
      setState(508);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(509);
    match(ExpressParser::END_ALIAS);
    setState(510);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArrayTypeContext ------------------------------------------------------------------

ExpressParser::ArrayTypeContext::ArrayTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::ArrayTypeContext::ARRAY() {
  return getToken(ExpressParser::ARRAY, 0);
}

ExpressParser::BoundSpecContext* ExpressParser::ArrayTypeContext::boundSpec() {
  return getRuleContext<ExpressParser::BoundSpecContext>(0);
}

tree::TerminalNode* ExpressParser::ArrayTypeContext::OF() {
  return getToken(ExpressParser::OF, 0);
}

ExpressParser::InstantiableTypeContext* ExpressParser::ArrayTypeContext::instantiableType() {
  return getRuleContext<ExpressParser::InstantiableTypeContext>(0);
}

tree::TerminalNode* ExpressParser::ArrayTypeContext::OPTIONAL() {
  return getToken(ExpressParser::OPTIONAL, 0);
}

tree::TerminalNode* ExpressParser::ArrayTypeContext::UNIQUE() {
  return getToken(ExpressParser::UNIQUE, 0);
}


size_t ExpressParser::ArrayTypeContext::getRuleIndex() const {
  return ExpressParser::RuleArrayType;
}

void ExpressParser::ArrayTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayType(this);
}

void ExpressParser::ArrayTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayType(this);
}


std::any ExpressParser::ArrayTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitArrayType(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ArrayTypeContext* ExpressParser::arrayType() {
  ArrayTypeContext *_localctx = _tracker.createInstance<ArrayTypeContext>(_ctx, getState());
  enterRule(_localctx, 50, ExpressParser::RuleArrayType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(512);
    match(ExpressParser::ARRAY);
    setState(513);
    boundSpec();
    setState(514);
    match(ExpressParser::OF);
    setState(516);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::OPTIONAL) {
      setState(515);
      match(ExpressParser::OPTIONAL);
    }
    setState(519);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::UNIQUE) {
      setState(518);
      match(ExpressParser::UNIQUE);
    }
    setState(521);
    instantiableType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentStmtContext ------------------------------------------------------------------

ExpressParser::AssignmentStmtContext::AssignmentStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::GeneralRefContext* ExpressParser::AssignmentStmtContext::generalRef() {
  return getRuleContext<ExpressParser::GeneralRefContext>(0);
}

ExpressParser::ExpressionContext* ExpressParser::AssignmentStmtContext::expression() {
  return getRuleContext<ExpressParser::ExpressionContext>(0);
}

std::vector<ExpressParser::QualifierContext *> ExpressParser::AssignmentStmtContext::qualifier() {
  return getRuleContexts<ExpressParser::QualifierContext>();
}

ExpressParser::QualifierContext* ExpressParser::AssignmentStmtContext::qualifier(size_t i) {
  return getRuleContext<ExpressParser::QualifierContext>(i);
}


size_t ExpressParser::AssignmentStmtContext::getRuleIndex() const {
  return ExpressParser::RuleAssignmentStmt;
}

void ExpressParser::AssignmentStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentStmt(this);
}

void ExpressParser::AssignmentStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentStmt(this);
}


std::any ExpressParser::AssignmentStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitAssignmentStmt(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::AssignmentStmtContext* ExpressParser::assignmentStmt() {
  AssignmentStmtContext *_localctx = _tracker.createInstance<AssignmentStmtContext>(_ctx, getState());
  enterRule(_localctx, 52, ExpressParser::RuleAssignmentStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(523);
    generalRef();
    setState(527);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << ExpressParser::T__6)
      | (1ULL << ExpressParser::T__10)
      | (1ULL << ExpressParser::T__13))) != 0)) {
      setState(524);
      qualifier();
      setState(529);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(530);
    match(ExpressParser::T__9);
    setState(531);
    expression();
    setState(532);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeDeclContext ------------------------------------------------------------------

ExpressParser::AttributeDeclContext::AttributeDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::AttributeIdContext* ExpressParser::AttributeDeclContext::attributeId() {
  return getRuleContext<ExpressParser::AttributeIdContext>(0);
}

ExpressParser::RedeclaredAttributeContext* ExpressParser::AttributeDeclContext::redeclaredAttribute() {
  return getRuleContext<ExpressParser::RedeclaredAttributeContext>(0);
}


size_t ExpressParser::AttributeDeclContext::getRuleIndex() const {
  return ExpressParser::RuleAttributeDecl;
}

void ExpressParser::AttributeDeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributeDecl(this);
}

void ExpressParser::AttributeDeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributeDecl(this);
}


std::any ExpressParser::AttributeDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitAttributeDecl(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::AttributeDeclContext* ExpressParser::attributeDecl() {
  AttributeDeclContext *_localctx = _tracker.createInstance<AttributeDeclContext>(_ctx, getState());
  enterRule(_localctx, 54, ExpressParser::RuleAttributeDecl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(536);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExpressParser::SimpleId: {
        enterOuterAlt(_localctx, 1);
        setState(534);
        attributeId();
        break;
      }

      case ExpressParser::SELF: {
        enterOuterAlt(_localctx, 2);
        setState(535);
        redeclaredAttribute();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeIdContext ------------------------------------------------------------------

ExpressParser::AttributeIdContext::AttributeIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::AttributeIdContext::SimpleId() {
  return getToken(ExpressParser::SimpleId, 0);
}


size_t ExpressParser::AttributeIdContext::getRuleIndex() const {
  return ExpressParser::RuleAttributeId;
}

void ExpressParser::AttributeIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributeId(this);
}

void ExpressParser::AttributeIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributeId(this);
}


std::any ExpressParser::AttributeIdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitAttributeId(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::AttributeIdContext* ExpressParser::attributeId() {
  AttributeIdContext *_localctx = _tracker.createInstance<AttributeIdContext>(_ctx, getState());
  enterRule(_localctx, 56, ExpressParser::RuleAttributeId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(538);
    match(ExpressParser::SimpleId);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeQualifierContext ------------------------------------------------------------------

ExpressParser::AttributeQualifierContext::AttributeQualifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::AttributeRefContext* ExpressParser::AttributeQualifierContext::attributeRef() {
  return getRuleContext<ExpressParser::AttributeRefContext>(0);
}


size_t ExpressParser::AttributeQualifierContext::getRuleIndex() const {
  return ExpressParser::RuleAttributeQualifier;
}

void ExpressParser::AttributeQualifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributeQualifier(this);
}

void ExpressParser::AttributeQualifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributeQualifier(this);
}


std::any ExpressParser::AttributeQualifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitAttributeQualifier(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::AttributeQualifierContext* ExpressParser::attributeQualifier() {
  AttributeQualifierContext *_localctx = _tracker.createInstance<AttributeQualifierContext>(_ctx, getState());
  enterRule(_localctx, 58, ExpressParser::RuleAttributeQualifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(540);
    match(ExpressParser::T__10);
    setState(541);
    attributeRef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BagTypeContext ------------------------------------------------------------------

ExpressParser::BagTypeContext::BagTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::BagTypeContext::BAG() {
  return getToken(ExpressParser::BAG, 0);
}

tree::TerminalNode* ExpressParser::BagTypeContext::OF() {
  return getToken(ExpressParser::OF, 0);
}

ExpressParser::InstantiableTypeContext* ExpressParser::BagTypeContext::instantiableType() {
  return getRuleContext<ExpressParser::InstantiableTypeContext>(0);
}

ExpressParser::BoundSpecContext* ExpressParser::BagTypeContext::boundSpec() {
  return getRuleContext<ExpressParser::BoundSpecContext>(0);
}


size_t ExpressParser::BagTypeContext::getRuleIndex() const {
  return ExpressParser::RuleBagType;
}

void ExpressParser::BagTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBagType(this);
}

void ExpressParser::BagTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBagType(this);
}


std::any ExpressParser::BagTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitBagType(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::BagTypeContext* ExpressParser::bagType() {
  BagTypeContext *_localctx = _tracker.createInstance<BagTypeContext>(_ctx, getState());
  enterRule(_localctx, 60, ExpressParser::RuleBagType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(543);
    match(ExpressParser::BAG);
    setState(545);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::T__6) {
      setState(544);
      boundSpec();
    }
    setState(547);
    match(ExpressParser::OF);
    setState(548);
    instantiableType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryTypeContext ------------------------------------------------------------------

ExpressParser::BinaryTypeContext::BinaryTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::BinaryTypeContext::BINARY() {
  return getToken(ExpressParser::BINARY, 0);
}

ExpressParser::WidthSpecContext* ExpressParser::BinaryTypeContext::widthSpec() {
  return getRuleContext<ExpressParser::WidthSpecContext>(0);
}


size_t ExpressParser::BinaryTypeContext::getRuleIndex() const {
  return ExpressParser::RuleBinaryType;
}

void ExpressParser::BinaryTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryType(this);
}

void ExpressParser::BinaryTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryType(this);
}


std::any ExpressParser::BinaryTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitBinaryType(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::BinaryTypeContext* ExpressParser::binaryType() {
  BinaryTypeContext *_localctx = _tracker.createInstance<BinaryTypeContext>(_ctx, getState());
  enterRule(_localctx, 62, ExpressParser::RuleBinaryType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(550);
    match(ExpressParser::BINARY);
    setState(552);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::T__1) {
      setState(551);
      widthSpec();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BooleanTypeContext ------------------------------------------------------------------

ExpressParser::BooleanTypeContext::BooleanTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::BooleanTypeContext::BOOLEAN() {
  return getToken(ExpressParser::BOOLEAN, 0);
}


size_t ExpressParser::BooleanTypeContext::getRuleIndex() const {
  return ExpressParser::RuleBooleanType;
}

void ExpressParser::BooleanTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBooleanType(this);
}

void ExpressParser::BooleanTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBooleanType(this);
}


std::any ExpressParser::BooleanTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitBooleanType(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::BooleanTypeContext* ExpressParser::booleanType() {
  BooleanTypeContext *_localctx = _tracker.createInstance<BooleanTypeContext>(_ctx, getState());
  enterRule(_localctx, 64, ExpressParser::RuleBooleanType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(554);
    match(ExpressParser::BOOLEAN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bound1Context ------------------------------------------------------------------

ExpressParser::Bound1Context::Bound1Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::NumericExpressionContext* ExpressParser::Bound1Context::numericExpression() {
  return getRuleContext<ExpressParser::NumericExpressionContext>(0);
}


size_t ExpressParser::Bound1Context::getRuleIndex() const {
  return ExpressParser::RuleBound1;
}

void ExpressParser::Bound1Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBound1(this);
}

void ExpressParser::Bound1Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBound1(this);
}


std::any ExpressParser::Bound1Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitBound1(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::Bound1Context* ExpressParser::bound1() {
  Bound1Context *_localctx = _tracker.createInstance<Bound1Context>(_ctx, getState());
  enterRule(_localctx, 66, ExpressParser::RuleBound1);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(556);
    numericExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bound2Context ------------------------------------------------------------------

ExpressParser::Bound2Context::Bound2Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::NumericExpressionContext* ExpressParser::Bound2Context::numericExpression() {
  return getRuleContext<ExpressParser::NumericExpressionContext>(0);
}


size_t ExpressParser::Bound2Context::getRuleIndex() const {
  return ExpressParser::RuleBound2;
}

void ExpressParser::Bound2Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBound2(this);
}

void ExpressParser::Bound2Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBound2(this);
}


std::any ExpressParser::Bound2Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitBound2(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::Bound2Context* ExpressParser::bound2() {
  Bound2Context *_localctx = _tracker.createInstance<Bound2Context>(_ctx, getState());
  enterRule(_localctx, 68, ExpressParser::RuleBound2);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(558);
    numericExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BoundSpecContext ------------------------------------------------------------------

ExpressParser::BoundSpecContext::BoundSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::Bound1Context* ExpressParser::BoundSpecContext::bound1() {
  return getRuleContext<ExpressParser::Bound1Context>(0);
}

ExpressParser::Bound2Context* ExpressParser::BoundSpecContext::bound2() {
  return getRuleContext<ExpressParser::Bound2Context>(0);
}


size_t ExpressParser::BoundSpecContext::getRuleIndex() const {
  return ExpressParser::RuleBoundSpec;
}

void ExpressParser::BoundSpecContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBoundSpec(this);
}

void ExpressParser::BoundSpecContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBoundSpec(this);
}


std::any ExpressParser::BoundSpecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitBoundSpec(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::BoundSpecContext* ExpressParser::boundSpec() {
  BoundSpecContext *_localctx = _tracker.createInstance<BoundSpecContext>(_ctx, getState());
  enterRule(_localctx, 70, ExpressParser::RuleBoundSpec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(560);
    match(ExpressParser::T__6);
    setState(561);
    bound1();
    setState(562);
    match(ExpressParser::T__8);
    setState(563);
    bound2();
    setState(564);
    match(ExpressParser::T__7);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BuiltInConstantContext ------------------------------------------------------------------

ExpressParser::BuiltInConstantContext::BuiltInConstantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::BuiltInConstantContext::CONST_E() {
  return getToken(ExpressParser::CONST_E, 0);
}

tree::TerminalNode* ExpressParser::BuiltInConstantContext::PI() {
  return getToken(ExpressParser::PI, 0);
}

tree::TerminalNode* ExpressParser::BuiltInConstantContext::SELF() {
  return getToken(ExpressParser::SELF, 0);
}


size_t ExpressParser::BuiltInConstantContext::getRuleIndex() const {
  return ExpressParser::RuleBuiltInConstant;
}

void ExpressParser::BuiltInConstantContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBuiltInConstant(this);
}

void ExpressParser::BuiltInConstantContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBuiltInConstant(this);
}


std::any ExpressParser::BuiltInConstantContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitBuiltInConstant(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::BuiltInConstantContext* ExpressParser::builtInConstant() {
  BuiltInConstantContext *_localctx = _tracker.createInstance<BuiltInConstantContext>(_ctx, getState());
  enterRule(_localctx, 72, ExpressParser::RuleBuiltInConstant);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(566);
    _la = _input->LA(1);
    if (!(_la == ExpressParser::T__11

    || _la == ExpressParser::CONST_E || _la == ExpressParser::PI

    || _la == ExpressParser::SELF)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BuiltInFunctionContext ------------------------------------------------------------------

ExpressParser::BuiltInFunctionContext::BuiltInFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::ABS() {
  return getToken(ExpressParser::ABS, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::ACOS() {
  return getToken(ExpressParser::ACOS, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::ASIN() {
  return getToken(ExpressParser::ASIN, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::ATAN() {
  return getToken(ExpressParser::ATAN, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::BLENGTH() {
  return getToken(ExpressParser::BLENGTH, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::COS() {
  return getToken(ExpressParser::COS, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::EXISTS() {
  return getToken(ExpressParser::EXISTS, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::EXP() {
  return getToken(ExpressParser::EXP, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::FORMAT() {
  return getToken(ExpressParser::FORMAT, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::HIBOUND() {
  return getToken(ExpressParser::HIBOUND, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::HIINDEX() {
  return getToken(ExpressParser::HIINDEX, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::LENGTH() {
  return getToken(ExpressParser::LENGTH, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::LOBOUND() {
  return getToken(ExpressParser::LOBOUND, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::LOINDEX() {
  return getToken(ExpressParser::LOINDEX, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::LOG() {
  return getToken(ExpressParser::LOG, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::LOG2() {
  return getToken(ExpressParser::LOG2, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::LOG10() {
  return getToken(ExpressParser::LOG10, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::NVL() {
  return getToken(ExpressParser::NVL, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::ODD() {
  return getToken(ExpressParser::ODD, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::ROLESOF() {
  return getToken(ExpressParser::ROLESOF, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::SIN() {
  return getToken(ExpressParser::SIN, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::SIZEOF() {
  return getToken(ExpressParser::SIZEOF, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::SQRT() {
  return getToken(ExpressParser::SQRT, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::TAN() {
  return getToken(ExpressParser::TAN, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::TYPEOF() {
  return getToken(ExpressParser::TYPEOF, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::USEDIN() {
  return getToken(ExpressParser::USEDIN, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::VALUE_() {
  return getToken(ExpressParser::VALUE_, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::VALUE_IN() {
  return getToken(ExpressParser::VALUE_IN, 0);
}

tree::TerminalNode* ExpressParser::BuiltInFunctionContext::VALUE_UNIQUE() {
  return getToken(ExpressParser::VALUE_UNIQUE, 0);
}


size_t ExpressParser::BuiltInFunctionContext::getRuleIndex() const {
  return ExpressParser::RuleBuiltInFunction;
}

void ExpressParser::BuiltInFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBuiltInFunction(this);
}

void ExpressParser::BuiltInFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBuiltInFunction(this);
}


std::any ExpressParser::BuiltInFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitBuiltInFunction(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::BuiltInFunctionContext* ExpressParser::builtInFunction() {
  BuiltInFunctionContext *_localctx = _tracker.createInstance<BuiltInFunctionContext>(_ctx, getState());
  enterRule(_localctx, 74, ExpressParser::RuleBuiltInFunction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(568);
    _la = _input->LA(1);
    if (!(((((_la - 30) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 30)) & ((1ULL << (ExpressParser::ABS - 30))
      | (1ULL << (ExpressParser::ACOS - 30))
      | (1ULL << (ExpressParser::ASIN - 30))
      | (1ULL << (ExpressParser::ATAN - 30))
      | (1ULL << (ExpressParser::BLENGTH - 30))
      | (1ULL << (ExpressParser::COS - 30))
      | (1ULL << (ExpressParser::EXISTS - 30))
      | (1ULL << (ExpressParser::EXP - 30))
      | (1ULL << (ExpressParser::FORMAT - 30))
      | (1ULL << (ExpressParser::HIBOUND - 30))
      | (1ULL << (ExpressParser::HIINDEX - 30))
      | (1ULL << (ExpressParser::LENGTH - 30))
      | (1ULL << (ExpressParser::LOBOUND - 30)))) != 0) || ((((_la - 95) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 95)) & ((1ULL << (ExpressParser::LOG - 95))
      | (1ULL << (ExpressParser::LOG10 - 95))
      | (1ULL << (ExpressParser::LOG2 - 95))
      | (1ULL << (ExpressParser::LOINDEX - 95))
      | (1ULL << (ExpressParser::NVL - 95))
      | (1ULL << (ExpressParser::ODD - 95))
      | (1ULL << (ExpressParser::ROLESOF - 95))
      | (1ULL << (ExpressParser::SIN - 95))
      | (1ULL << (ExpressParser::SIZEOF - 95))
      | (1ULL << (ExpressParser::SQRT - 95))
      | (1ULL << (ExpressParser::TAN - 95))
      | (1ULL << (ExpressParser::TYPEOF - 95))
      | (1ULL << (ExpressParser::USEDIN - 95))
      | (1ULL << (ExpressParser::VALUE_ - 95))
      | (1ULL << (ExpressParser::VALUE_IN - 95))
      | (1ULL << (ExpressParser::VALUE_UNIQUE - 95)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BuiltInProcedureContext ------------------------------------------------------------------

ExpressParser::BuiltInProcedureContext::BuiltInProcedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::BuiltInProcedureContext::INSERT() {
  return getToken(ExpressParser::INSERT, 0);
}

tree::TerminalNode* ExpressParser::BuiltInProcedureContext::REMOVE() {
  return getToken(ExpressParser::REMOVE, 0);
}


size_t ExpressParser::BuiltInProcedureContext::getRuleIndex() const {
  return ExpressParser::RuleBuiltInProcedure;
}

void ExpressParser::BuiltInProcedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBuiltInProcedure(this);
}

void ExpressParser::BuiltInProcedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBuiltInProcedure(this);
}


std::any ExpressParser::BuiltInProcedureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitBuiltInProcedure(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::BuiltInProcedureContext* ExpressParser::builtInProcedure() {
  BuiltInProcedureContext *_localctx = _tracker.createInstance<BuiltInProcedureContext>(_ctx, getState());
  enterRule(_localctx, 76, ExpressParser::RuleBuiltInProcedure);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(570);
    _la = _input->LA(1);
    if (!(_la == ExpressParser::INSERT

    || _la == ExpressParser::REMOVE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseActionContext ------------------------------------------------------------------

ExpressParser::CaseActionContext::CaseActionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExpressParser::CaseLabelContext *> ExpressParser::CaseActionContext::caseLabel() {
  return getRuleContexts<ExpressParser::CaseLabelContext>();
}

ExpressParser::CaseLabelContext* ExpressParser::CaseActionContext::caseLabel(size_t i) {
  return getRuleContext<ExpressParser::CaseLabelContext>(i);
}

ExpressParser::StmtContext* ExpressParser::CaseActionContext::stmt() {
  return getRuleContext<ExpressParser::StmtContext>(0);
}


size_t ExpressParser::CaseActionContext::getRuleIndex() const {
  return ExpressParser::RuleCaseAction;
}

void ExpressParser::CaseActionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseAction(this);
}

void ExpressParser::CaseActionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseAction(this);
}


std::any ExpressParser::CaseActionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitCaseAction(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::CaseActionContext* ExpressParser::caseAction() {
  CaseActionContext *_localctx = _tracker.createInstance<CaseActionContext>(_ctx, getState());
  enterRule(_localctx, 78, ExpressParser::RuleCaseAction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(572);
    caseLabel();
    setState(577);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExpressParser::T__2) {
      setState(573);
      match(ExpressParser::T__2);
      setState(574);
      caseLabel();
      setState(579);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(580);
    match(ExpressParser::T__8);
    setState(581);
    stmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseLabelContext ------------------------------------------------------------------

ExpressParser::CaseLabelContext::CaseLabelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::ExpressionContext* ExpressParser::CaseLabelContext::expression() {
  return getRuleContext<ExpressParser::ExpressionContext>(0);
}


size_t ExpressParser::CaseLabelContext::getRuleIndex() const {
  return ExpressParser::RuleCaseLabel;
}

void ExpressParser::CaseLabelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseLabel(this);
}

void ExpressParser::CaseLabelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseLabel(this);
}


std::any ExpressParser::CaseLabelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitCaseLabel(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::CaseLabelContext* ExpressParser::caseLabel() {
  CaseLabelContext *_localctx = _tracker.createInstance<CaseLabelContext>(_ctx, getState());
  enterRule(_localctx, 80, ExpressParser::RuleCaseLabel);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(583);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseStmtContext ------------------------------------------------------------------

ExpressParser::CaseStmtContext::CaseStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::CaseStmtContext::CASE() {
  return getToken(ExpressParser::CASE, 0);
}

ExpressParser::SelectorContext* ExpressParser::CaseStmtContext::selector() {
  return getRuleContext<ExpressParser::SelectorContext>(0);
}

tree::TerminalNode* ExpressParser::CaseStmtContext::OF() {
  return getToken(ExpressParser::OF, 0);
}

tree::TerminalNode* ExpressParser::CaseStmtContext::END_CASE() {
  return getToken(ExpressParser::END_CASE, 0);
}

std::vector<ExpressParser::CaseActionContext *> ExpressParser::CaseStmtContext::caseAction() {
  return getRuleContexts<ExpressParser::CaseActionContext>();
}

ExpressParser::CaseActionContext* ExpressParser::CaseStmtContext::caseAction(size_t i) {
  return getRuleContext<ExpressParser::CaseActionContext>(i);
}

tree::TerminalNode* ExpressParser::CaseStmtContext::OTHERWISE() {
  return getToken(ExpressParser::OTHERWISE, 0);
}

ExpressParser::StmtContext* ExpressParser::CaseStmtContext::stmt() {
  return getRuleContext<ExpressParser::StmtContext>(0);
}


size_t ExpressParser::CaseStmtContext::getRuleIndex() const {
  return ExpressParser::RuleCaseStmt;
}

void ExpressParser::CaseStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseStmt(this);
}

void ExpressParser::CaseStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseStmt(this);
}


std::any ExpressParser::CaseStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitCaseStmt(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::CaseStmtContext* ExpressParser::caseStmt() {
  CaseStmtContext *_localctx = _tracker.createInstance<CaseStmtContext>(_ctx, getState());
  enterRule(_localctx, 82, ExpressParser::RuleCaseStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(585);
    match(ExpressParser::CASE);
    setState(586);
    selector();
    setState(587);
    match(ExpressParser::OF);
    setState(591);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << ExpressParser::T__1)
      | (1ULL << ExpressParser::T__4)
      | (1ULL << ExpressParser::T__5)
      | (1ULL << ExpressParser::T__6)
      | (1ULL << ExpressParser::T__11)
      | (1ULL << ExpressParser::T__14)
      | (1ULL << ExpressParser::ABS)
      | (1ULL << ExpressParser::ACOS)
      | (1ULL << ExpressParser::ASIN)
      | (1ULL << ExpressParser::ATAN)
      | (1ULL << ExpressParser::BLENGTH)
      | (1ULL << ExpressParser::CONST_E)
      | (1ULL << ExpressParser::COS))) != 0) || ((((_la - 72) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 72)) & ((1ULL << (ExpressParser::EXISTS - 72))
      | (1ULL << (ExpressParser::EXP - 72))
      | (1ULL << (ExpressParser::FALSE - 72))
      | (1ULL << (ExpressParser::FORMAT - 72))
      | (1ULL << (ExpressParser::HIBOUND - 72))
      | (1ULL << (ExpressParser::HIINDEX - 72))
      | (1ULL << (ExpressParser::LENGTH - 72))
      | (1ULL << (ExpressParser::LOBOUND - 72))
      | (1ULL << (ExpressParser::LOG - 72))
      | (1ULL << (ExpressParser::LOG10 - 72))
      | (1ULL << (ExpressParser::LOG2 - 72))
      | (1ULL << (ExpressParser::LOINDEX - 72))
      | (1ULL << (ExpressParser::NOT - 72))
      | (1ULL << (ExpressParser::NVL - 72))
      | (1ULL << (ExpressParser::ODD - 72))
      | (1ULL << (ExpressParser::PI - 72))
      | (1ULL << (ExpressParser::QUERY - 72))
      | (1ULL << (ExpressParser::ROLESOF - 72))
      | (1ULL << (ExpressParser::SELF - 72))
      | (1ULL << (ExpressParser::SIN - 72))
      | (1ULL << (ExpressParser::SIZEOF - 72))
      | (1ULL << (ExpressParser::SQRT - 72))
      | (1ULL << (ExpressParser::TAN - 72)))) != 0) || ((((_la - 136) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 136)) & ((1ULL << (ExpressParser::TRUE - 136))
      | (1ULL << (ExpressParser::TYPEOF - 136))
      | (1ULL << (ExpressParser::UNKNOWN - 136))
      | (1ULL << (ExpressParser::USEDIN - 136))
      | (1ULL << (ExpressParser::VALUE_ - 136))
      | (1ULL << (ExpressParser::VALUE_IN - 136))
      | (1ULL << (ExpressParser::VALUE_UNIQUE - 136))
      | (1ULL << (ExpressParser::BinaryLiteral - 136))
      | (1ULL << (ExpressParser::EncodedStringLiteral - 136))
      | (1ULL << (ExpressParser::IntegerLiteral - 136))
      | (1ULL << (ExpressParser::RealLiteral - 136))
      | (1ULL << (ExpressParser::SimpleId - 136))
      | (1ULL << (ExpressParser::SimpleStringLiteral - 136)))) != 0)) {
      setState(588);
      caseAction();
      setState(593);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(597);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::OTHERWISE) {
      setState(594);
      match(ExpressParser::OTHERWISE);
      setState(595);
      match(ExpressParser::T__8);
      setState(596);
      stmt();
    }
    setState(599);
    match(ExpressParser::END_CASE);
    setState(600);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompoundStmtContext ------------------------------------------------------------------

ExpressParser::CompoundStmtContext::CompoundStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::CompoundStmtContext::BEGIN_() {
  return getToken(ExpressParser::BEGIN_, 0);
}

std::vector<ExpressParser::StmtContext *> ExpressParser::CompoundStmtContext::stmt() {
  return getRuleContexts<ExpressParser::StmtContext>();
}

ExpressParser::StmtContext* ExpressParser::CompoundStmtContext::stmt(size_t i) {
  return getRuleContext<ExpressParser::StmtContext>(i);
}

tree::TerminalNode* ExpressParser::CompoundStmtContext::END_() {
  return getToken(ExpressParser::END_, 0);
}


size_t ExpressParser::CompoundStmtContext::getRuleIndex() const {
  return ExpressParser::RuleCompoundStmt;
}

void ExpressParser::CompoundStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompoundStmt(this);
}

void ExpressParser::CompoundStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompoundStmt(this);
}


std::any ExpressParser::CompoundStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitCompoundStmt(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::CompoundStmtContext* ExpressParser::compoundStmt() {
  CompoundStmtContext *_localctx = _tracker.createInstance<CompoundStmtContext>(_ctx, getState());
  enterRule(_localctx, 84, ExpressParser::RuleCompoundStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(602);
    match(ExpressParser::BEGIN_);
    setState(603);
    stmt();
    setState(607);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << ExpressParser::T__0)
      | (1ULL << ExpressParser::ALIAS)
      | (1ULL << ExpressParser::BEGIN_)
      | (1ULL << ExpressParser::CASE))) != 0) || ((((_la - 71) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 71)) & ((1ULL << (ExpressParser::ESCAPE - 71))
      | (1ULL << (ExpressParser::IF - 71))
      | (1ULL << (ExpressParser::INSERT - 71))
      | (1ULL << (ExpressParser::REMOVE - 71))
      | (1ULL << (ExpressParser::REPEAT - 71))
      | (1ULL << (ExpressParser::RETURN - 71))
      | (1ULL << (ExpressParser::SKIP_ - 71)))) != 0) || _la == ExpressParser::SimpleId) {
      setState(604);
      stmt();
      setState(609);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(610);
    match(ExpressParser::END_);
    setState(611);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConcreteTypesContext ------------------------------------------------------------------

ExpressParser::ConcreteTypesContext::ConcreteTypesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::AggregationTypesContext* ExpressParser::ConcreteTypesContext::aggregationTypes() {
  return getRuleContext<ExpressParser::AggregationTypesContext>(0);
}

ExpressParser::SimpleTypesContext* ExpressParser::ConcreteTypesContext::simpleTypes() {
  return getRuleContext<ExpressParser::SimpleTypesContext>(0);
}

ExpressParser::TypeRefContext* ExpressParser::ConcreteTypesContext::typeRef() {
  return getRuleContext<ExpressParser::TypeRefContext>(0);
}


size_t ExpressParser::ConcreteTypesContext::getRuleIndex() const {
  return ExpressParser::RuleConcreteTypes;
}

void ExpressParser::ConcreteTypesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConcreteTypes(this);
}

void ExpressParser::ConcreteTypesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConcreteTypes(this);
}


std::any ExpressParser::ConcreteTypesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitConcreteTypes(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ConcreteTypesContext* ExpressParser::concreteTypes() {
  ConcreteTypesContext *_localctx = _tracker.createInstance<ConcreteTypesContext>(_ctx, getState());
  enterRule(_localctx, 86, ExpressParser::RuleConcreteTypes);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(616);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExpressParser::ARRAY:
      case ExpressParser::BAG:
      case ExpressParser::LIST:
      case ExpressParser::SET: {
        enterOuterAlt(_localctx, 1);
        setState(613);
        aggregationTypes();
        break;
      }

      case ExpressParser::BINARY:
      case ExpressParser::BOOLEAN:
      case ExpressParser::INTEGER:
      case ExpressParser::LOGICAL:
      case ExpressParser::NUMBER:
      case ExpressParser::REAL:
      case ExpressParser::STRING: {
        enterOuterAlt(_localctx, 2);
        setState(614);
        simpleTypes();
        break;
      }

      case ExpressParser::SimpleId: {
        enterOuterAlt(_localctx, 3);
        setState(615);
        typeRef();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstantBodyContext ------------------------------------------------------------------

ExpressParser::ConstantBodyContext::ConstantBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::ConstantIdContext* ExpressParser::ConstantBodyContext::constantId() {
  return getRuleContext<ExpressParser::ConstantIdContext>(0);
}

ExpressParser::InstantiableTypeContext* ExpressParser::ConstantBodyContext::instantiableType() {
  return getRuleContext<ExpressParser::InstantiableTypeContext>(0);
}

ExpressParser::ExpressionContext* ExpressParser::ConstantBodyContext::expression() {
  return getRuleContext<ExpressParser::ExpressionContext>(0);
}


size_t ExpressParser::ConstantBodyContext::getRuleIndex() const {
  return ExpressParser::RuleConstantBody;
}

void ExpressParser::ConstantBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstantBody(this);
}

void ExpressParser::ConstantBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstantBody(this);
}


std::any ExpressParser::ConstantBodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitConstantBody(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ConstantBodyContext* ExpressParser::constantBody() {
  ConstantBodyContext *_localctx = _tracker.createInstance<ConstantBodyContext>(_ctx, getState());
  enterRule(_localctx, 88, ExpressParser::RuleConstantBody);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(618);
    constantId();
    setState(619);
    match(ExpressParser::T__8);
    setState(620);
    instantiableType();
    setState(621);
    match(ExpressParser::T__9);
    setState(622);
    expression();
    setState(623);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstantDeclContext ------------------------------------------------------------------

ExpressParser::ConstantDeclContext::ConstantDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::ConstantDeclContext::CONSTANT() {
  return getToken(ExpressParser::CONSTANT, 0);
}

std::vector<ExpressParser::ConstantBodyContext *> ExpressParser::ConstantDeclContext::constantBody() {
  return getRuleContexts<ExpressParser::ConstantBodyContext>();
}

ExpressParser::ConstantBodyContext* ExpressParser::ConstantDeclContext::constantBody(size_t i) {
  return getRuleContext<ExpressParser::ConstantBodyContext>(i);
}

tree::TerminalNode* ExpressParser::ConstantDeclContext::END_CONSTANT() {
  return getToken(ExpressParser::END_CONSTANT, 0);
}


size_t ExpressParser::ConstantDeclContext::getRuleIndex() const {
  return ExpressParser::RuleConstantDecl;
}

void ExpressParser::ConstantDeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstantDecl(this);
}

void ExpressParser::ConstantDeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstantDecl(this);
}


std::any ExpressParser::ConstantDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitConstantDecl(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ConstantDeclContext* ExpressParser::constantDecl() {
  ConstantDeclContext *_localctx = _tracker.createInstance<ConstantDeclContext>(_ctx, getState());
  enterRule(_localctx, 90, ExpressParser::RuleConstantDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(625);
    match(ExpressParser::CONSTANT);
    setState(626);
    constantBody();
    setState(630);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExpressParser::SimpleId) {
      setState(627);
      constantBody();
      setState(632);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(633);
    match(ExpressParser::END_CONSTANT);
    setState(634);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstantFactorContext ------------------------------------------------------------------

ExpressParser::ConstantFactorContext::ConstantFactorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::BuiltInConstantContext* ExpressParser::ConstantFactorContext::builtInConstant() {
  return getRuleContext<ExpressParser::BuiltInConstantContext>(0);
}

ExpressParser::ConstantRefContext* ExpressParser::ConstantFactorContext::constantRef() {
  return getRuleContext<ExpressParser::ConstantRefContext>(0);
}


size_t ExpressParser::ConstantFactorContext::getRuleIndex() const {
  return ExpressParser::RuleConstantFactor;
}

void ExpressParser::ConstantFactorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstantFactor(this);
}

void ExpressParser::ConstantFactorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstantFactor(this);
}


std::any ExpressParser::ConstantFactorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitConstantFactor(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ConstantFactorContext* ExpressParser::constantFactor() {
  ConstantFactorContext *_localctx = _tracker.createInstance<ConstantFactorContext>(_ctx, getState());
  enterRule(_localctx, 92, ExpressParser::RuleConstantFactor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(638);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExpressParser::T__11:
      case ExpressParser::CONST_E:
      case ExpressParser::PI:
      case ExpressParser::SELF: {
        enterOuterAlt(_localctx, 1);
        setState(636);
        builtInConstant();
        break;
      }

      case ExpressParser::SimpleId: {
        enterOuterAlt(_localctx, 2);
        setState(637);
        constantRef();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstantIdContext ------------------------------------------------------------------

ExpressParser::ConstantIdContext::ConstantIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::ConstantIdContext::SimpleId() {
  return getToken(ExpressParser::SimpleId, 0);
}


size_t ExpressParser::ConstantIdContext::getRuleIndex() const {
  return ExpressParser::RuleConstantId;
}

void ExpressParser::ConstantIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstantId(this);
}

void ExpressParser::ConstantIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstantId(this);
}


std::any ExpressParser::ConstantIdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitConstantId(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ConstantIdContext* ExpressParser::constantId() {
  ConstantIdContext *_localctx = _tracker.createInstance<ConstantIdContext>(_ctx, getState());
  enterRule(_localctx, 94, ExpressParser::RuleConstantId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(640);
    match(ExpressParser::SimpleId);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstructedTypesContext ------------------------------------------------------------------

ExpressParser::ConstructedTypesContext::ConstructedTypesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::EnumerationTypeContext* ExpressParser::ConstructedTypesContext::enumerationType() {
  return getRuleContext<ExpressParser::EnumerationTypeContext>(0);
}

ExpressParser::SelectTypeContext* ExpressParser::ConstructedTypesContext::selectType() {
  return getRuleContext<ExpressParser::SelectTypeContext>(0);
}


size_t ExpressParser::ConstructedTypesContext::getRuleIndex() const {
  return ExpressParser::RuleConstructedTypes;
}

void ExpressParser::ConstructedTypesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstructedTypes(this);
}

void ExpressParser::ConstructedTypesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstructedTypes(this);
}


std::any ExpressParser::ConstructedTypesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitConstructedTypes(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ConstructedTypesContext* ExpressParser::constructedTypes() {
  ConstructedTypesContext *_localctx = _tracker.createInstance<ConstructedTypesContext>(_ctx, getState());
  enterRule(_localctx, 96, ExpressParser::RuleConstructedTypes);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(644);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(642);
      enumerationType();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(643);
      selectType();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclarationContext ------------------------------------------------------------------

ExpressParser::DeclarationContext::DeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::EntityDeclContext* ExpressParser::DeclarationContext::entityDecl() {
  return getRuleContext<ExpressParser::EntityDeclContext>(0);
}

ExpressParser::FunctionDeclContext* ExpressParser::DeclarationContext::functionDecl() {
  return getRuleContext<ExpressParser::FunctionDeclContext>(0);
}

ExpressParser::ProcedureDeclContext* ExpressParser::DeclarationContext::procedureDecl() {
  return getRuleContext<ExpressParser::ProcedureDeclContext>(0);
}

ExpressParser::SubtypeConstraintDeclContext* ExpressParser::DeclarationContext::subtypeConstraintDecl() {
  return getRuleContext<ExpressParser::SubtypeConstraintDeclContext>(0);
}

ExpressParser::TypeDeclContext* ExpressParser::DeclarationContext::typeDecl() {
  return getRuleContext<ExpressParser::TypeDeclContext>(0);
}


size_t ExpressParser::DeclarationContext::getRuleIndex() const {
  return ExpressParser::RuleDeclaration;
}

void ExpressParser::DeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclaration(this);
}

void ExpressParser::DeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclaration(this);
}


std::any ExpressParser::DeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitDeclaration(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::DeclarationContext* ExpressParser::declaration() {
  DeclarationContext *_localctx = _tracker.createInstance<DeclarationContext>(_ctx, getState());
  enterRule(_localctx, 98, ExpressParser::RuleDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(651);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExpressParser::ENTITY: {
        enterOuterAlt(_localctx, 1);
        setState(646);
        entityDecl();
        break;
      }

      case ExpressParser::FUNCTION: {
        enterOuterAlt(_localctx, 2);
        setState(647);
        functionDecl();
        break;
      }

      case ExpressParser::PROCEDURE: {
        enterOuterAlt(_localctx, 3);
        setState(648);
        procedureDecl();
        break;
      }

      case ExpressParser::SUBTYPE_CONSTRAINT: {
        enterOuterAlt(_localctx, 4);
        setState(649);
        subtypeConstraintDecl();
        break;
      }

      case ExpressParser::TYPE: {
        enterOuterAlt(_localctx, 5);
        setState(650);
        typeDecl();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DerivedAttrContext ------------------------------------------------------------------

ExpressParser::DerivedAttrContext::DerivedAttrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::AttributeDeclContext* ExpressParser::DerivedAttrContext::attributeDecl() {
  return getRuleContext<ExpressParser::AttributeDeclContext>(0);
}

ExpressParser::ParameterTypeContext* ExpressParser::DerivedAttrContext::parameterType() {
  return getRuleContext<ExpressParser::ParameterTypeContext>(0);
}

ExpressParser::ExpressionContext* ExpressParser::DerivedAttrContext::expression() {
  return getRuleContext<ExpressParser::ExpressionContext>(0);
}


size_t ExpressParser::DerivedAttrContext::getRuleIndex() const {
  return ExpressParser::RuleDerivedAttr;
}

void ExpressParser::DerivedAttrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDerivedAttr(this);
}

void ExpressParser::DerivedAttrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDerivedAttr(this);
}


std::any ExpressParser::DerivedAttrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitDerivedAttr(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::DerivedAttrContext* ExpressParser::derivedAttr() {
  DerivedAttrContext *_localctx = _tracker.createInstance<DerivedAttrContext>(_ctx, getState());
  enterRule(_localctx, 100, ExpressParser::RuleDerivedAttr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(653);
    attributeDecl();
    setState(654);
    match(ExpressParser::T__8);
    setState(655);
    parameterType();
    setState(656);
    match(ExpressParser::T__9);
    setState(657);
    expression();
    setState(658);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeriveClauseContext ------------------------------------------------------------------

ExpressParser::DeriveClauseContext::DeriveClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::DeriveClauseContext::DERIVE() {
  return getToken(ExpressParser::DERIVE, 0);
}

std::vector<ExpressParser::DerivedAttrContext *> ExpressParser::DeriveClauseContext::derivedAttr() {
  return getRuleContexts<ExpressParser::DerivedAttrContext>();
}

ExpressParser::DerivedAttrContext* ExpressParser::DeriveClauseContext::derivedAttr(size_t i) {
  return getRuleContext<ExpressParser::DerivedAttrContext>(i);
}


size_t ExpressParser::DeriveClauseContext::getRuleIndex() const {
  return ExpressParser::RuleDeriveClause;
}

void ExpressParser::DeriveClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeriveClause(this);
}

void ExpressParser::DeriveClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeriveClause(this);
}


std::any ExpressParser::DeriveClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitDeriveClause(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::DeriveClauseContext* ExpressParser::deriveClause() {
  DeriveClauseContext *_localctx = _tracker.createInstance<DeriveClauseContext>(_ctx, getState());
  enterRule(_localctx, 102, ExpressParser::RuleDeriveClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(660);
    match(ExpressParser::DERIVE);
    setState(661);
    derivedAttr();
    setState(665);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExpressParser::SELF

    || _la == ExpressParser::SimpleId) {
      setState(662);
      derivedAttr();
      setState(667);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DomainRuleContext ------------------------------------------------------------------

ExpressParser::DomainRuleContext::DomainRuleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::ExpressionContext* ExpressParser::DomainRuleContext::expression() {
  return getRuleContext<ExpressParser::ExpressionContext>(0);
}

ExpressParser::RuleLabelIdContext* ExpressParser::DomainRuleContext::ruleLabelId() {
  return getRuleContext<ExpressParser::RuleLabelIdContext>(0);
}


size_t ExpressParser::DomainRuleContext::getRuleIndex() const {
  return ExpressParser::RuleDomainRule;
}

void ExpressParser::DomainRuleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDomainRule(this);
}

void ExpressParser::DomainRuleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDomainRule(this);
}


std::any ExpressParser::DomainRuleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitDomainRule(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::DomainRuleContext* ExpressParser::domainRule() {
  DomainRuleContext *_localctx = _tracker.createInstance<DomainRuleContext>(_ctx, getState());
  enterRule(_localctx, 104, ExpressParser::RuleDomainRule);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(671);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
    case 1: {
      setState(668);
      ruleLabelId();
      setState(669);
      match(ExpressParser::T__8);
      break;
    }

    default:
      break;
    }
    setState(673);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElementContext ------------------------------------------------------------------

ExpressParser::ElementContext::ElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::ExpressionContext* ExpressParser::ElementContext::expression() {
  return getRuleContext<ExpressParser::ExpressionContext>(0);
}

ExpressParser::RepetitionContext* ExpressParser::ElementContext::repetition() {
  return getRuleContext<ExpressParser::RepetitionContext>(0);
}


size_t ExpressParser::ElementContext::getRuleIndex() const {
  return ExpressParser::RuleElement;
}

void ExpressParser::ElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElement(this);
}

void ExpressParser::ElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElement(this);
}


std::any ExpressParser::ElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitElement(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ElementContext* ExpressParser::element() {
  ElementContext *_localctx = _tracker.createInstance<ElementContext>(_ctx, getState());
  enterRule(_localctx, 106, ExpressParser::RuleElement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(675);
    expression();
    setState(678);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::T__8) {
      setState(676);
      match(ExpressParser::T__8);
      setState(677);
      repetition();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EntityBodyContext ------------------------------------------------------------------

ExpressParser::EntityBodyContext::EntityBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExpressParser::ExplicitAttrContext *> ExpressParser::EntityBodyContext::explicitAttr() {
  return getRuleContexts<ExpressParser::ExplicitAttrContext>();
}

ExpressParser::ExplicitAttrContext* ExpressParser::EntityBodyContext::explicitAttr(size_t i) {
  return getRuleContext<ExpressParser::ExplicitAttrContext>(i);
}

ExpressParser::DeriveClauseContext* ExpressParser::EntityBodyContext::deriveClause() {
  return getRuleContext<ExpressParser::DeriveClauseContext>(0);
}

ExpressParser::InverseClauseContext* ExpressParser::EntityBodyContext::inverseClause() {
  return getRuleContext<ExpressParser::InverseClauseContext>(0);
}

ExpressParser::UniqueClauseContext* ExpressParser::EntityBodyContext::uniqueClause() {
  return getRuleContext<ExpressParser::UniqueClauseContext>(0);
}

ExpressParser::WhereClauseContext* ExpressParser::EntityBodyContext::whereClause() {
  return getRuleContext<ExpressParser::WhereClauseContext>(0);
}


size_t ExpressParser::EntityBodyContext::getRuleIndex() const {
  return ExpressParser::RuleEntityBody;
}

void ExpressParser::EntityBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEntityBody(this);
}

void ExpressParser::EntityBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEntityBody(this);
}


std::any ExpressParser::EntityBodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitEntityBody(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::EntityBodyContext* ExpressParser::entityBody() {
  EntityBodyContext *_localctx = _tracker.createInstance<EntityBodyContext>(_ctx, getState());
  enterRule(_localctx, 108, ExpressParser::RuleEntityBody);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(683);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExpressParser::SELF

    || _la == ExpressParser::SimpleId) {
      setState(680);
      explicitAttr();
      setState(685);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(687);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::DERIVE) {
      setState(686);
      deriveClause();
    }
    setState(690);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::INVERSE) {
      setState(689);
      inverseClause();
    }
    setState(693);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::UNIQUE) {
      setState(692);
      uniqueClause();
    }
    setState(696);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::WHERE) {
      setState(695);
      whereClause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EntityConstructorContext ------------------------------------------------------------------

ExpressParser::EntityConstructorContext::EntityConstructorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::EntityRefContext* ExpressParser::EntityConstructorContext::entityRef() {
  return getRuleContext<ExpressParser::EntityRefContext>(0);
}

std::vector<ExpressParser::ExpressionContext *> ExpressParser::EntityConstructorContext::expression() {
  return getRuleContexts<ExpressParser::ExpressionContext>();
}

ExpressParser::ExpressionContext* ExpressParser::EntityConstructorContext::expression(size_t i) {
  return getRuleContext<ExpressParser::ExpressionContext>(i);
}


size_t ExpressParser::EntityConstructorContext::getRuleIndex() const {
  return ExpressParser::RuleEntityConstructor;
}

void ExpressParser::EntityConstructorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEntityConstructor(this);
}

void ExpressParser::EntityConstructorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEntityConstructor(this);
}


std::any ExpressParser::EntityConstructorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitEntityConstructor(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::EntityConstructorContext* ExpressParser::entityConstructor() {
  EntityConstructorContext *_localctx = _tracker.createInstance<EntityConstructorContext>(_ctx, getState());
  enterRule(_localctx, 110, ExpressParser::RuleEntityConstructor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(698);
    entityRef();
    setState(699);
    match(ExpressParser::T__1);
    setState(708);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << ExpressParser::T__1)
      | (1ULL << ExpressParser::T__4)
      | (1ULL << ExpressParser::T__5)
      | (1ULL << ExpressParser::T__6)
      | (1ULL << ExpressParser::T__11)
      | (1ULL << ExpressParser::T__14)
      | (1ULL << ExpressParser::ABS)
      | (1ULL << ExpressParser::ACOS)
      | (1ULL << ExpressParser::ASIN)
      | (1ULL << ExpressParser::ATAN)
      | (1ULL << ExpressParser::BLENGTH)
      | (1ULL << ExpressParser::CONST_E)
      | (1ULL << ExpressParser::COS))) != 0) || ((((_la - 72) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 72)) & ((1ULL << (ExpressParser::EXISTS - 72))
      | (1ULL << (ExpressParser::EXP - 72))
      | (1ULL << (ExpressParser::FALSE - 72))
      | (1ULL << (ExpressParser::FORMAT - 72))
      | (1ULL << (ExpressParser::HIBOUND - 72))
      | (1ULL << (ExpressParser::HIINDEX - 72))
      | (1ULL << (ExpressParser::LENGTH - 72))
      | (1ULL << (ExpressParser::LOBOUND - 72))
      | (1ULL << (ExpressParser::LOG - 72))
      | (1ULL << (ExpressParser::LOG10 - 72))
      | (1ULL << (ExpressParser::LOG2 - 72))
      | (1ULL << (ExpressParser::LOINDEX - 72))
      | (1ULL << (ExpressParser::NOT - 72))
      | (1ULL << (ExpressParser::NVL - 72))
      | (1ULL << (ExpressParser::ODD - 72))
      | (1ULL << (ExpressParser::PI - 72))
      | (1ULL << (ExpressParser::QUERY - 72))
      | (1ULL << (ExpressParser::ROLESOF - 72))
      | (1ULL << (ExpressParser::SELF - 72))
      | (1ULL << (ExpressParser::SIN - 72))
      | (1ULL << (ExpressParser::SIZEOF - 72))
      | (1ULL << (ExpressParser::SQRT - 72))
      | (1ULL << (ExpressParser::TAN - 72)))) != 0) || ((((_la - 136) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 136)) & ((1ULL << (ExpressParser::TRUE - 136))
      | (1ULL << (ExpressParser::TYPEOF - 136))
      | (1ULL << (ExpressParser::UNKNOWN - 136))
      | (1ULL << (ExpressParser::USEDIN - 136))
      | (1ULL << (ExpressParser::VALUE_ - 136))
      | (1ULL << (ExpressParser::VALUE_IN - 136))
      | (1ULL << (ExpressParser::VALUE_UNIQUE - 136))
      | (1ULL << (ExpressParser::BinaryLiteral - 136))
      | (1ULL << (ExpressParser::EncodedStringLiteral - 136))
      | (1ULL << (ExpressParser::IntegerLiteral - 136))
      | (1ULL << (ExpressParser::RealLiteral - 136))
      | (1ULL << (ExpressParser::SimpleId - 136))
      | (1ULL << (ExpressParser::SimpleStringLiteral - 136)))) != 0)) {
      setState(700);
      expression();
      setState(705);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == ExpressParser::T__2) {
        setState(701);
        match(ExpressParser::T__2);
        setState(702);
        expression();
        setState(707);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(710);
    match(ExpressParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EntityDeclContext ------------------------------------------------------------------

ExpressParser::EntityDeclContext::EntityDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::EntityHeadContext* ExpressParser::EntityDeclContext::entityHead() {
  return getRuleContext<ExpressParser::EntityHeadContext>(0);
}

ExpressParser::EntityBodyContext* ExpressParser::EntityDeclContext::entityBody() {
  return getRuleContext<ExpressParser::EntityBodyContext>(0);
}

tree::TerminalNode* ExpressParser::EntityDeclContext::END_ENTITY() {
  return getToken(ExpressParser::END_ENTITY, 0);
}


size_t ExpressParser::EntityDeclContext::getRuleIndex() const {
  return ExpressParser::RuleEntityDecl;
}

void ExpressParser::EntityDeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEntityDecl(this);
}

void ExpressParser::EntityDeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEntityDecl(this);
}


std::any ExpressParser::EntityDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitEntityDecl(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::EntityDeclContext* ExpressParser::entityDecl() {
  EntityDeclContext *_localctx = _tracker.createInstance<EntityDeclContext>(_ctx, getState());
  enterRule(_localctx, 112, ExpressParser::RuleEntityDecl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(712);
    entityHead();
    setState(713);
    entityBody();
    setState(714);
    match(ExpressParser::END_ENTITY);
    setState(715);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EntityHeadContext ------------------------------------------------------------------

ExpressParser::EntityHeadContext::EntityHeadContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::EntityHeadContext::ENTITY() {
  return getToken(ExpressParser::ENTITY, 0);
}

ExpressParser::EntityIdContext* ExpressParser::EntityHeadContext::entityId() {
  return getRuleContext<ExpressParser::EntityIdContext>(0);
}

ExpressParser::SubsuperContext* ExpressParser::EntityHeadContext::subsuper() {
  return getRuleContext<ExpressParser::SubsuperContext>(0);
}


size_t ExpressParser::EntityHeadContext::getRuleIndex() const {
  return ExpressParser::RuleEntityHead;
}

void ExpressParser::EntityHeadContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEntityHead(this);
}

void ExpressParser::EntityHeadContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEntityHead(this);
}


std::any ExpressParser::EntityHeadContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitEntityHead(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::EntityHeadContext* ExpressParser::entityHead() {
  EntityHeadContext *_localctx = _tracker.createInstance<EntityHeadContext>(_ctx, getState());
  enterRule(_localctx, 114, ExpressParser::RuleEntityHead);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(717);
    match(ExpressParser::ENTITY);
    setState(718);
    entityId();
    setState(719);
    subsuper();
    setState(720);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EntityIdContext ------------------------------------------------------------------

ExpressParser::EntityIdContext::EntityIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::EntityIdContext::SimpleId() {
  return getToken(ExpressParser::SimpleId, 0);
}


size_t ExpressParser::EntityIdContext::getRuleIndex() const {
  return ExpressParser::RuleEntityId;
}

void ExpressParser::EntityIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEntityId(this);
}

void ExpressParser::EntityIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEntityId(this);
}


std::any ExpressParser::EntityIdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitEntityId(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::EntityIdContext* ExpressParser::entityId() {
  EntityIdContext *_localctx = _tracker.createInstance<EntityIdContext>(_ctx, getState());
  enterRule(_localctx, 116, ExpressParser::RuleEntityId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(722);
    match(ExpressParser::SimpleId);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumerationExtensionContext ------------------------------------------------------------------

ExpressParser::EnumerationExtensionContext::EnumerationExtensionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::EnumerationExtensionContext::BASED_ON() {
  return getToken(ExpressParser::BASED_ON, 0);
}

ExpressParser::TypeRefContext* ExpressParser::EnumerationExtensionContext::typeRef() {
  return getRuleContext<ExpressParser::TypeRefContext>(0);
}

tree::TerminalNode* ExpressParser::EnumerationExtensionContext::WITH() {
  return getToken(ExpressParser::WITH, 0);
}

ExpressParser::EnumerationItemsContext* ExpressParser::EnumerationExtensionContext::enumerationItems() {
  return getRuleContext<ExpressParser::EnumerationItemsContext>(0);
}


size_t ExpressParser::EnumerationExtensionContext::getRuleIndex() const {
  return ExpressParser::RuleEnumerationExtension;
}

void ExpressParser::EnumerationExtensionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumerationExtension(this);
}

void ExpressParser::EnumerationExtensionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumerationExtension(this);
}


std::any ExpressParser::EnumerationExtensionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitEnumerationExtension(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::EnumerationExtensionContext* ExpressParser::enumerationExtension() {
  EnumerationExtensionContext *_localctx = _tracker.createInstance<EnumerationExtensionContext>(_ctx, getState());
  enterRule(_localctx, 118, ExpressParser::RuleEnumerationExtension);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(724);
    match(ExpressParser::BASED_ON);
    setState(725);
    typeRef();
    setState(728);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::WITH) {
      setState(726);
      match(ExpressParser::WITH);
      setState(727);
      enumerationItems();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumerationIdContext ------------------------------------------------------------------

ExpressParser::EnumerationIdContext::EnumerationIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::EnumerationIdContext::SimpleId() {
  return getToken(ExpressParser::SimpleId, 0);
}


size_t ExpressParser::EnumerationIdContext::getRuleIndex() const {
  return ExpressParser::RuleEnumerationId;
}

void ExpressParser::EnumerationIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumerationId(this);
}

void ExpressParser::EnumerationIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumerationId(this);
}


std::any ExpressParser::EnumerationIdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitEnumerationId(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::EnumerationIdContext* ExpressParser::enumerationId() {
  EnumerationIdContext *_localctx = _tracker.createInstance<EnumerationIdContext>(_ctx, getState());
  enterRule(_localctx, 120, ExpressParser::RuleEnumerationId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(730);
    match(ExpressParser::SimpleId);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumerationItemsContext ------------------------------------------------------------------

ExpressParser::EnumerationItemsContext::EnumerationItemsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExpressParser::EnumerationItemContext *> ExpressParser::EnumerationItemsContext::enumerationItem() {
  return getRuleContexts<ExpressParser::EnumerationItemContext>();
}

ExpressParser::EnumerationItemContext* ExpressParser::EnumerationItemsContext::enumerationItem(size_t i) {
  return getRuleContext<ExpressParser::EnumerationItemContext>(i);
}


size_t ExpressParser::EnumerationItemsContext::getRuleIndex() const {
  return ExpressParser::RuleEnumerationItems;
}

void ExpressParser::EnumerationItemsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumerationItems(this);
}

void ExpressParser::EnumerationItemsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumerationItems(this);
}


std::any ExpressParser::EnumerationItemsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitEnumerationItems(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::EnumerationItemsContext* ExpressParser::enumerationItems() {
  EnumerationItemsContext *_localctx = _tracker.createInstance<EnumerationItemsContext>(_ctx, getState());
  enterRule(_localctx, 122, ExpressParser::RuleEnumerationItems);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(732);
    match(ExpressParser::T__1);
    setState(733);
    enumerationItem();
    setState(738);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExpressParser::T__2) {
      setState(734);
      match(ExpressParser::T__2);
      setState(735);
      enumerationItem();
      setState(740);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(741);
    match(ExpressParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumerationItemContext ------------------------------------------------------------------

ExpressParser::EnumerationItemContext::EnumerationItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::EnumerationIdContext* ExpressParser::EnumerationItemContext::enumerationId() {
  return getRuleContext<ExpressParser::EnumerationIdContext>(0);
}


size_t ExpressParser::EnumerationItemContext::getRuleIndex() const {
  return ExpressParser::RuleEnumerationItem;
}

void ExpressParser::EnumerationItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumerationItem(this);
}

void ExpressParser::EnumerationItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumerationItem(this);
}


std::any ExpressParser::EnumerationItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitEnumerationItem(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::EnumerationItemContext* ExpressParser::enumerationItem() {
  EnumerationItemContext *_localctx = _tracker.createInstance<EnumerationItemContext>(_ctx, getState());
  enterRule(_localctx, 124, ExpressParser::RuleEnumerationItem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(743);
    enumerationId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumerationReferenceContext ------------------------------------------------------------------

ExpressParser::EnumerationReferenceContext::EnumerationReferenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::EnumerationRefContext* ExpressParser::EnumerationReferenceContext::enumerationRef() {
  return getRuleContext<ExpressParser::EnumerationRefContext>(0);
}

ExpressParser::TypeRefContext* ExpressParser::EnumerationReferenceContext::typeRef() {
  return getRuleContext<ExpressParser::TypeRefContext>(0);
}


size_t ExpressParser::EnumerationReferenceContext::getRuleIndex() const {
  return ExpressParser::RuleEnumerationReference;
}

void ExpressParser::EnumerationReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumerationReference(this);
}

void ExpressParser::EnumerationReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumerationReference(this);
}


std::any ExpressParser::EnumerationReferenceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitEnumerationReference(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::EnumerationReferenceContext* ExpressParser::enumerationReference() {
  EnumerationReferenceContext *_localctx = _tracker.createInstance<EnumerationReferenceContext>(_ctx, getState());
  enterRule(_localctx, 126, ExpressParser::RuleEnumerationReference);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(748);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx)) {
    case 1: {
      setState(745);
      typeRef();
      setState(746);
      match(ExpressParser::T__10);
      break;
    }

    default:
      break;
    }
    setState(750);
    enumerationRef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumerationTypeContext ------------------------------------------------------------------

ExpressParser::EnumerationTypeContext::EnumerationTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::EnumerationTypeContext::ENUMERATION() {
  return getToken(ExpressParser::ENUMERATION, 0);
}

tree::TerminalNode* ExpressParser::EnumerationTypeContext::EXTENSIBLE() {
  return getToken(ExpressParser::EXTENSIBLE, 0);
}

tree::TerminalNode* ExpressParser::EnumerationTypeContext::OF() {
  return getToken(ExpressParser::OF, 0);
}

ExpressParser::EnumerationItemsContext* ExpressParser::EnumerationTypeContext::enumerationItems() {
  return getRuleContext<ExpressParser::EnumerationItemsContext>(0);
}

ExpressParser::EnumerationExtensionContext* ExpressParser::EnumerationTypeContext::enumerationExtension() {
  return getRuleContext<ExpressParser::EnumerationExtensionContext>(0);
}


size_t ExpressParser::EnumerationTypeContext::getRuleIndex() const {
  return ExpressParser::RuleEnumerationType;
}

void ExpressParser::EnumerationTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumerationType(this);
}

void ExpressParser::EnumerationTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumerationType(this);
}


std::any ExpressParser::EnumerationTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitEnumerationType(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::EnumerationTypeContext* ExpressParser::enumerationType() {
  EnumerationTypeContext *_localctx = _tracker.createInstance<EnumerationTypeContext>(_ctx, getState());
  enterRule(_localctx, 128, ExpressParser::RuleEnumerationType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(753);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::EXTENSIBLE) {
      setState(752);
      match(ExpressParser::EXTENSIBLE);
    }
    setState(755);
    match(ExpressParser::ENUMERATION);
    setState(759);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExpressParser::OF: {
        setState(756);
        match(ExpressParser::OF);
        setState(757);
        enumerationItems();
        break;
      }

      case ExpressParser::BASED_ON: {
        setState(758);
        enumerationExtension();
        break;
      }

      case ExpressParser::T__0: {
        break;
      }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EscapeStmtContext ------------------------------------------------------------------

ExpressParser::EscapeStmtContext::EscapeStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::EscapeStmtContext::ESCAPE() {
  return getToken(ExpressParser::ESCAPE, 0);
}


size_t ExpressParser::EscapeStmtContext::getRuleIndex() const {
  return ExpressParser::RuleEscapeStmt;
}

void ExpressParser::EscapeStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEscapeStmt(this);
}

void ExpressParser::EscapeStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEscapeStmt(this);
}


std::any ExpressParser::EscapeStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitEscapeStmt(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::EscapeStmtContext* ExpressParser::escapeStmt() {
  EscapeStmtContext *_localctx = _tracker.createInstance<EscapeStmtContext>(_ctx, getState());
  enterRule(_localctx, 130, ExpressParser::RuleEscapeStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(761);
    match(ExpressParser::ESCAPE);
    setState(762);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExplicitAttrContext ------------------------------------------------------------------

ExpressParser::ExplicitAttrContext::ExplicitAttrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExpressParser::AttributeDeclContext *> ExpressParser::ExplicitAttrContext::attributeDecl() {
  return getRuleContexts<ExpressParser::AttributeDeclContext>();
}

ExpressParser::AttributeDeclContext* ExpressParser::ExplicitAttrContext::attributeDecl(size_t i) {
  return getRuleContext<ExpressParser::AttributeDeclContext>(i);
}

ExpressParser::ParameterTypeContext* ExpressParser::ExplicitAttrContext::parameterType() {
  return getRuleContext<ExpressParser::ParameterTypeContext>(0);
}

tree::TerminalNode* ExpressParser::ExplicitAttrContext::OPTIONAL() {
  return getToken(ExpressParser::OPTIONAL, 0);
}


size_t ExpressParser::ExplicitAttrContext::getRuleIndex() const {
  return ExpressParser::RuleExplicitAttr;
}

void ExpressParser::ExplicitAttrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExplicitAttr(this);
}

void ExpressParser::ExplicitAttrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExplicitAttr(this);
}


std::any ExpressParser::ExplicitAttrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitExplicitAttr(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ExplicitAttrContext* ExpressParser::explicitAttr() {
  ExplicitAttrContext *_localctx = _tracker.createInstance<ExplicitAttrContext>(_ctx, getState());
  enterRule(_localctx, 132, ExpressParser::RuleExplicitAttr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(764);
    attributeDecl();
    setState(769);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExpressParser::T__2) {
      setState(765);
      match(ExpressParser::T__2);
      setState(766);
      attributeDecl();
      setState(771);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(772);
    match(ExpressParser::T__8);
    setState(774);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::OPTIONAL) {
      setState(773);
      match(ExpressParser::OPTIONAL);
    }
    setState(776);
    parameterType();
    setState(777);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

ExpressParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExpressParser::SimpleExpressionContext *> ExpressParser::ExpressionContext::simpleExpression() {
  return getRuleContexts<ExpressParser::SimpleExpressionContext>();
}

ExpressParser::SimpleExpressionContext* ExpressParser::ExpressionContext::simpleExpression(size_t i) {
  return getRuleContext<ExpressParser::SimpleExpressionContext>(i);
}

ExpressParser::RelOpExtendedContext* ExpressParser::ExpressionContext::relOpExtended() {
  return getRuleContext<ExpressParser::RelOpExtendedContext>(0);
}


size_t ExpressParser::ExpressionContext::getRuleIndex() const {
  return ExpressParser::RuleExpression;
}

void ExpressParser::ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression(this);
}

void ExpressParser::ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression(this);
}


std::any ExpressParser::ExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitExpression(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ExpressionContext* ExpressParser::expression() {
  ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, getState());
  enterRule(_localctx, 134, ExpressParser::RuleExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(779);
    simpleExpression();
    setState(783);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << ExpressParser::T__16)
      | (1ULL << ExpressParser::T__17)
      | (1ULL << ExpressParser::T__23)
      | (1ULL << ExpressParser::T__24)
      | (1ULL << ExpressParser::T__25)
      | (1ULL << ExpressParser::T__26)
      | (1ULL << ExpressParser::T__27)
      | (1ULL << ExpressParser::T__28))) != 0) || _la == ExpressParser::IN

    || _la == ExpressParser::LIKE) {
      setState(780);
      relOpExtended();
      setState(781);
      simpleExpression();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FactorContext ------------------------------------------------------------------

ExpressParser::FactorContext::FactorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExpressParser::SimpleFactorContext *> ExpressParser::FactorContext::simpleFactor() {
  return getRuleContexts<ExpressParser::SimpleFactorContext>();
}

ExpressParser::SimpleFactorContext* ExpressParser::FactorContext::simpleFactor(size_t i) {
  return getRuleContext<ExpressParser::SimpleFactorContext>(i);
}


size_t ExpressParser::FactorContext::getRuleIndex() const {
  return ExpressParser::RuleFactor;
}

void ExpressParser::FactorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFactor(this);
}

void ExpressParser::FactorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFactor(this);
}


std::any ExpressParser::FactorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitFactor(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::FactorContext* ExpressParser::factor() {
  FactorContext *_localctx = _tracker.createInstance<FactorContext>(_ctx, getState());
  enterRule(_localctx, 136, ExpressParser::RuleFactor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(785);
    simpleFactor();
    setState(788);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::T__12) {
      setState(786);
      match(ExpressParser::T__12);
      setState(787);
      simpleFactor();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FormalParameterContext ------------------------------------------------------------------

ExpressParser::FormalParameterContext::FormalParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExpressParser::ParameterIdContext *> ExpressParser::FormalParameterContext::parameterId() {
  return getRuleContexts<ExpressParser::ParameterIdContext>();
}

ExpressParser::ParameterIdContext* ExpressParser::FormalParameterContext::parameterId(size_t i) {
  return getRuleContext<ExpressParser::ParameterIdContext>(i);
}

ExpressParser::ParameterTypeContext* ExpressParser::FormalParameterContext::parameterType() {
  return getRuleContext<ExpressParser::ParameterTypeContext>(0);
}


size_t ExpressParser::FormalParameterContext::getRuleIndex() const {
  return ExpressParser::RuleFormalParameter;
}

void ExpressParser::FormalParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFormalParameter(this);
}

void ExpressParser::FormalParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFormalParameter(this);
}


std::any ExpressParser::FormalParameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitFormalParameter(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::FormalParameterContext* ExpressParser::formalParameter() {
  FormalParameterContext *_localctx = _tracker.createInstance<FormalParameterContext>(_ctx, getState());
  enterRule(_localctx, 138, ExpressParser::RuleFormalParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(790);
    parameterId();
    setState(795);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExpressParser::T__2) {
      setState(791);
      match(ExpressParser::T__2);
      setState(792);
      parameterId();
      setState(797);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(798);
    match(ExpressParser::T__8);
    setState(799);
    parameterType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionCallContext ------------------------------------------------------------------

ExpressParser::FunctionCallContext::FunctionCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::BuiltInFunctionContext* ExpressParser::FunctionCallContext::builtInFunction() {
  return getRuleContext<ExpressParser::BuiltInFunctionContext>(0);
}

ExpressParser::FunctionRefContext* ExpressParser::FunctionCallContext::functionRef() {
  return getRuleContext<ExpressParser::FunctionRefContext>(0);
}

ExpressParser::ActualParameterListContext* ExpressParser::FunctionCallContext::actualParameterList() {
  return getRuleContext<ExpressParser::ActualParameterListContext>(0);
}


size_t ExpressParser::FunctionCallContext::getRuleIndex() const {
  return ExpressParser::RuleFunctionCall;
}

void ExpressParser::FunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionCall(this);
}

void ExpressParser::FunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionCall(this);
}


std::any ExpressParser::FunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitFunctionCall(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::FunctionCallContext* ExpressParser::functionCall() {
  FunctionCallContext *_localctx = _tracker.createInstance<FunctionCallContext>(_ctx, getState());
  enterRule(_localctx, 140, ExpressParser::RuleFunctionCall);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(803);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExpressParser::ABS:
      case ExpressParser::ACOS:
      case ExpressParser::ASIN:
      case ExpressParser::ATAN:
      case ExpressParser::BLENGTH:
      case ExpressParser::COS:
      case ExpressParser::EXISTS:
      case ExpressParser::EXP:
      case ExpressParser::FORMAT:
      case ExpressParser::HIBOUND:
      case ExpressParser::HIINDEX:
      case ExpressParser::LENGTH:
      case ExpressParser::LOBOUND:
      case ExpressParser::LOG:
      case ExpressParser::LOG10:
      case ExpressParser::LOG2:
      case ExpressParser::LOINDEX:
      case ExpressParser::NVL:
      case ExpressParser::ODD:
      case ExpressParser::ROLESOF:
      case ExpressParser::SIN:
      case ExpressParser::SIZEOF:
      case ExpressParser::SQRT:
      case ExpressParser::TAN:
      case ExpressParser::TYPEOF:
      case ExpressParser::USEDIN:
      case ExpressParser::VALUE_:
      case ExpressParser::VALUE_IN:
      case ExpressParser::VALUE_UNIQUE: {
        setState(801);
        builtInFunction();
        break;
      }

      case ExpressParser::SimpleId: {
        setState(802);
        functionRef();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(806);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::T__1) {
      setState(805);
      actualParameterList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionDeclContext ------------------------------------------------------------------

ExpressParser::FunctionDeclContext::FunctionDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::FunctionHeadContext* ExpressParser::FunctionDeclContext::functionHead() {
  return getRuleContext<ExpressParser::FunctionHeadContext>(0);
}

ExpressParser::AlgorithmHeadContext* ExpressParser::FunctionDeclContext::algorithmHead() {
  return getRuleContext<ExpressParser::AlgorithmHeadContext>(0);
}

std::vector<ExpressParser::StmtContext *> ExpressParser::FunctionDeclContext::stmt() {
  return getRuleContexts<ExpressParser::StmtContext>();
}

ExpressParser::StmtContext* ExpressParser::FunctionDeclContext::stmt(size_t i) {
  return getRuleContext<ExpressParser::StmtContext>(i);
}

tree::TerminalNode* ExpressParser::FunctionDeclContext::END_FUNCTION() {
  return getToken(ExpressParser::END_FUNCTION, 0);
}


size_t ExpressParser::FunctionDeclContext::getRuleIndex() const {
  return ExpressParser::RuleFunctionDecl;
}

void ExpressParser::FunctionDeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionDecl(this);
}

void ExpressParser::FunctionDeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionDecl(this);
}


std::any ExpressParser::FunctionDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitFunctionDecl(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::FunctionDeclContext* ExpressParser::functionDecl() {
  FunctionDeclContext *_localctx = _tracker.createInstance<FunctionDeclContext>(_ctx, getState());
  enterRule(_localctx, 142, ExpressParser::RuleFunctionDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(808);
    functionHead();
    setState(809);
    algorithmHead();
    setState(810);
    stmt();
    setState(814);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << ExpressParser::T__0)
      | (1ULL << ExpressParser::ALIAS)
      | (1ULL << ExpressParser::BEGIN_)
      | (1ULL << ExpressParser::CASE))) != 0) || ((((_la - 71) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 71)) & ((1ULL << (ExpressParser::ESCAPE - 71))
      | (1ULL << (ExpressParser::IF - 71))
      | (1ULL << (ExpressParser::INSERT - 71))
      | (1ULL << (ExpressParser::REMOVE - 71))
      | (1ULL << (ExpressParser::REPEAT - 71))
      | (1ULL << (ExpressParser::RETURN - 71))
      | (1ULL << (ExpressParser::SKIP_ - 71)))) != 0) || _la == ExpressParser::SimpleId) {
      setState(811);
      stmt();
      setState(816);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(817);
    match(ExpressParser::END_FUNCTION);
    setState(818);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionHeadContext ------------------------------------------------------------------

ExpressParser::FunctionHeadContext::FunctionHeadContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::FunctionHeadContext::FUNCTION() {
  return getToken(ExpressParser::FUNCTION, 0);
}

ExpressParser::FunctionIdContext* ExpressParser::FunctionHeadContext::functionId() {
  return getRuleContext<ExpressParser::FunctionIdContext>(0);
}

ExpressParser::ParameterTypeContext* ExpressParser::FunctionHeadContext::parameterType() {
  return getRuleContext<ExpressParser::ParameterTypeContext>(0);
}

std::vector<ExpressParser::FormalParameterContext *> ExpressParser::FunctionHeadContext::formalParameter() {
  return getRuleContexts<ExpressParser::FormalParameterContext>();
}

ExpressParser::FormalParameterContext* ExpressParser::FunctionHeadContext::formalParameter(size_t i) {
  return getRuleContext<ExpressParser::FormalParameterContext>(i);
}


size_t ExpressParser::FunctionHeadContext::getRuleIndex() const {
  return ExpressParser::RuleFunctionHead;
}

void ExpressParser::FunctionHeadContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionHead(this);
}

void ExpressParser::FunctionHeadContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionHead(this);
}


std::any ExpressParser::FunctionHeadContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitFunctionHead(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::FunctionHeadContext* ExpressParser::functionHead() {
  FunctionHeadContext *_localctx = _tracker.createInstance<FunctionHeadContext>(_ctx, getState());
  enterRule(_localctx, 144, ExpressParser::RuleFunctionHead);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(820);
    match(ExpressParser::FUNCTION);
    setState(821);
    functionId();
    setState(833);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::T__1) {
      setState(822);
      match(ExpressParser::T__1);
      setState(823);
      formalParameter();
      setState(828);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == ExpressParser::T__0) {
        setState(824);
        match(ExpressParser::T__0);
        setState(825);
        formalParameter();
        setState(830);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(831);
      match(ExpressParser::T__3);
    }
    setState(835);
    match(ExpressParser::T__8);
    setState(836);
    parameterType();
    setState(837);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionIdContext ------------------------------------------------------------------

ExpressParser::FunctionIdContext::FunctionIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::FunctionIdContext::SimpleId() {
  return getToken(ExpressParser::SimpleId, 0);
}


size_t ExpressParser::FunctionIdContext::getRuleIndex() const {
  return ExpressParser::RuleFunctionId;
}

void ExpressParser::FunctionIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionId(this);
}

void ExpressParser::FunctionIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionId(this);
}


std::any ExpressParser::FunctionIdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitFunctionId(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::FunctionIdContext* ExpressParser::functionId() {
  FunctionIdContext *_localctx = _tracker.createInstance<FunctionIdContext>(_ctx, getState());
  enterRule(_localctx, 146, ExpressParser::RuleFunctionId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(839);
    match(ExpressParser::SimpleId);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GeneralizedTypesContext ------------------------------------------------------------------

ExpressParser::GeneralizedTypesContext::GeneralizedTypesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::AggregateTypeContext* ExpressParser::GeneralizedTypesContext::aggregateType() {
  return getRuleContext<ExpressParser::AggregateTypeContext>(0);
}

ExpressParser::GeneralAggregationTypesContext* ExpressParser::GeneralizedTypesContext::generalAggregationTypes() {
  return getRuleContext<ExpressParser::GeneralAggregationTypesContext>(0);
}

ExpressParser::GenericEntityTypeContext* ExpressParser::GeneralizedTypesContext::genericEntityType() {
  return getRuleContext<ExpressParser::GenericEntityTypeContext>(0);
}

ExpressParser::GenericTypeContext* ExpressParser::GeneralizedTypesContext::genericType() {
  return getRuleContext<ExpressParser::GenericTypeContext>(0);
}


size_t ExpressParser::GeneralizedTypesContext::getRuleIndex() const {
  return ExpressParser::RuleGeneralizedTypes;
}

void ExpressParser::GeneralizedTypesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneralizedTypes(this);
}

void ExpressParser::GeneralizedTypesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneralizedTypes(this);
}


std::any ExpressParser::GeneralizedTypesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitGeneralizedTypes(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::GeneralizedTypesContext* ExpressParser::generalizedTypes() {
  GeneralizedTypesContext *_localctx = _tracker.createInstance<GeneralizedTypesContext>(_ctx, getState());
  enterRule(_localctx, 148, ExpressParser::RuleGeneralizedTypes);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(845);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExpressParser::AGGREGATE: {
        enterOuterAlt(_localctx, 1);
        setState(841);
        aggregateType();
        break;
      }

      case ExpressParser::ARRAY:
      case ExpressParser::BAG:
      case ExpressParser::LIST:
      case ExpressParser::SET: {
        enterOuterAlt(_localctx, 2);
        setState(842);
        generalAggregationTypes();
        break;
      }

      case ExpressParser::GENERIC_ENTITY: {
        enterOuterAlt(_localctx, 3);
        setState(843);
        genericEntityType();
        break;
      }

      case ExpressParser::GENERIC: {
        enterOuterAlt(_localctx, 4);
        setState(844);
        genericType();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GeneralAggregationTypesContext ------------------------------------------------------------------

ExpressParser::GeneralAggregationTypesContext::GeneralAggregationTypesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::GeneralArrayTypeContext* ExpressParser::GeneralAggregationTypesContext::generalArrayType() {
  return getRuleContext<ExpressParser::GeneralArrayTypeContext>(0);
}

ExpressParser::GeneralBagTypeContext* ExpressParser::GeneralAggregationTypesContext::generalBagType() {
  return getRuleContext<ExpressParser::GeneralBagTypeContext>(0);
}

ExpressParser::GeneralListTypeContext* ExpressParser::GeneralAggregationTypesContext::generalListType() {
  return getRuleContext<ExpressParser::GeneralListTypeContext>(0);
}

ExpressParser::GeneralSetTypeContext* ExpressParser::GeneralAggregationTypesContext::generalSetType() {
  return getRuleContext<ExpressParser::GeneralSetTypeContext>(0);
}


size_t ExpressParser::GeneralAggregationTypesContext::getRuleIndex() const {
  return ExpressParser::RuleGeneralAggregationTypes;
}

void ExpressParser::GeneralAggregationTypesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneralAggregationTypes(this);
}

void ExpressParser::GeneralAggregationTypesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneralAggregationTypes(this);
}


std::any ExpressParser::GeneralAggregationTypesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitGeneralAggregationTypes(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::GeneralAggregationTypesContext* ExpressParser::generalAggregationTypes() {
  GeneralAggregationTypesContext *_localctx = _tracker.createInstance<GeneralAggregationTypesContext>(_ctx, getState());
  enterRule(_localctx, 150, ExpressParser::RuleGeneralAggregationTypes);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(851);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExpressParser::ARRAY: {
        enterOuterAlt(_localctx, 1);
        setState(847);
        generalArrayType();
        break;
      }

      case ExpressParser::BAG: {
        enterOuterAlt(_localctx, 2);
        setState(848);
        generalBagType();
        break;
      }

      case ExpressParser::LIST: {
        enterOuterAlt(_localctx, 3);
        setState(849);
        generalListType();
        break;
      }

      case ExpressParser::SET: {
        enterOuterAlt(_localctx, 4);
        setState(850);
        generalSetType();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GeneralArrayTypeContext ------------------------------------------------------------------

ExpressParser::GeneralArrayTypeContext::GeneralArrayTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::GeneralArrayTypeContext::ARRAY() {
  return getToken(ExpressParser::ARRAY, 0);
}

tree::TerminalNode* ExpressParser::GeneralArrayTypeContext::OF() {
  return getToken(ExpressParser::OF, 0);
}

ExpressParser::ParameterTypeContext* ExpressParser::GeneralArrayTypeContext::parameterType() {
  return getRuleContext<ExpressParser::ParameterTypeContext>(0);
}

ExpressParser::BoundSpecContext* ExpressParser::GeneralArrayTypeContext::boundSpec() {
  return getRuleContext<ExpressParser::BoundSpecContext>(0);
}

tree::TerminalNode* ExpressParser::GeneralArrayTypeContext::OPTIONAL() {
  return getToken(ExpressParser::OPTIONAL, 0);
}

tree::TerminalNode* ExpressParser::GeneralArrayTypeContext::UNIQUE() {
  return getToken(ExpressParser::UNIQUE, 0);
}


size_t ExpressParser::GeneralArrayTypeContext::getRuleIndex() const {
  return ExpressParser::RuleGeneralArrayType;
}

void ExpressParser::GeneralArrayTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneralArrayType(this);
}

void ExpressParser::GeneralArrayTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneralArrayType(this);
}


std::any ExpressParser::GeneralArrayTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitGeneralArrayType(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::GeneralArrayTypeContext* ExpressParser::generalArrayType() {
  GeneralArrayTypeContext *_localctx = _tracker.createInstance<GeneralArrayTypeContext>(_ctx, getState());
  enterRule(_localctx, 152, ExpressParser::RuleGeneralArrayType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(853);
    match(ExpressParser::ARRAY);
    setState(855);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::T__6) {
      setState(854);
      boundSpec();
    }
    setState(857);
    match(ExpressParser::OF);
    setState(859);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::OPTIONAL) {
      setState(858);
      match(ExpressParser::OPTIONAL);
    }
    setState(862);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::UNIQUE) {
      setState(861);
      match(ExpressParser::UNIQUE);
    }
    setState(864);
    parameterType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GeneralBagTypeContext ------------------------------------------------------------------

ExpressParser::GeneralBagTypeContext::GeneralBagTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::GeneralBagTypeContext::BAG() {
  return getToken(ExpressParser::BAG, 0);
}

tree::TerminalNode* ExpressParser::GeneralBagTypeContext::OF() {
  return getToken(ExpressParser::OF, 0);
}

ExpressParser::ParameterTypeContext* ExpressParser::GeneralBagTypeContext::parameterType() {
  return getRuleContext<ExpressParser::ParameterTypeContext>(0);
}

ExpressParser::BoundSpecContext* ExpressParser::GeneralBagTypeContext::boundSpec() {
  return getRuleContext<ExpressParser::BoundSpecContext>(0);
}


size_t ExpressParser::GeneralBagTypeContext::getRuleIndex() const {
  return ExpressParser::RuleGeneralBagType;
}

void ExpressParser::GeneralBagTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneralBagType(this);
}

void ExpressParser::GeneralBagTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneralBagType(this);
}


std::any ExpressParser::GeneralBagTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitGeneralBagType(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::GeneralBagTypeContext* ExpressParser::generalBagType() {
  GeneralBagTypeContext *_localctx = _tracker.createInstance<GeneralBagTypeContext>(_ctx, getState());
  enterRule(_localctx, 154, ExpressParser::RuleGeneralBagType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(866);
    match(ExpressParser::BAG);
    setState(868);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::T__6) {
      setState(867);
      boundSpec();
    }
    setState(870);
    match(ExpressParser::OF);
    setState(871);
    parameterType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GeneralListTypeContext ------------------------------------------------------------------

ExpressParser::GeneralListTypeContext::GeneralListTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::GeneralListTypeContext::LIST() {
  return getToken(ExpressParser::LIST, 0);
}

tree::TerminalNode* ExpressParser::GeneralListTypeContext::OF() {
  return getToken(ExpressParser::OF, 0);
}

ExpressParser::ParameterTypeContext* ExpressParser::GeneralListTypeContext::parameterType() {
  return getRuleContext<ExpressParser::ParameterTypeContext>(0);
}

ExpressParser::BoundSpecContext* ExpressParser::GeneralListTypeContext::boundSpec() {
  return getRuleContext<ExpressParser::BoundSpecContext>(0);
}

tree::TerminalNode* ExpressParser::GeneralListTypeContext::UNIQUE() {
  return getToken(ExpressParser::UNIQUE, 0);
}


size_t ExpressParser::GeneralListTypeContext::getRuleIndex() const {
  return ExpressParser::RuleGeneralListType;
}

void ExpressParser::GeneralListTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneralListType(this);
}

void ExpressParser::GeneralListTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneralListType(this);
}


std::any ExpressParser::GeneralListTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitGeneralListType(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::GeneralListTypeContext* ExpressParser::generalListType() {
  GeneralListTypeContext *_localctx = _tracker.createInstance<GeneralListTypeContext>(_ctx, getState());
  enterRule(_localctx, 156, ExpressParser::RuleGeneralListType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(873);
    match(ExpressParser::LIST);
    setState(875);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::T__6) {
      setState(874);
      boundSpec();
    }
    setState(877);
    match(ExpressParser::OF);
    setState(879);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::UNIQUE) {
      setState(878);
      match(ExpressParser::UNIQUE);
    }
    setState(881);
    parameterType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GeneralRefContext ------------------------------------------------------------------

ExpressParser::GeneralRefContext::GeneralRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::ParameterRefContext* ExpressParser::GeneralRefContext::parameterRef() {
  return getRuleContext<ExpressParser::ParameterRefContext>(0);
}

ExpressParser::VariableIdContext* ExpressParser::GeneralRefContext::variableId() {
  return getRuleContext<ExpressParser::VariableIdContext>(0);
}


size_t ExpressParser::GeneralRefContext::getRuleIndex() const {
  return ExpressParser::RuleGeneralRef;
}

void ExpressParser::GeneralRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneralRef(this);
}

void ExpressParser::GeneralRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneralRef(this);
}


std::any ExpressParser::GeneralRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitGeneralRef(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::GeneralRefContext* ExpressParser::generalRef() {
  GeneralRefContext *_localctx = _tracker.createInstance<GeneralRefContext>(_ctx, getState());
  enterRule(_localctx, 158, ExpressParser::RuleGeneralRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(885);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(883);
      parameterRef();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(884);
      variableId();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GeneralSetTypeContext ------------------------------------------------------------------

ExpressParser::GeneralSetTypeContext::GeneralSetTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::GeneralSetTypeContext::SET() {
  return getToken(ExpressParser::SET, 0);
}

tree::TerminalNode* ExpressParser::GeneralSetTypeContext::OF() {
  return getToken(ExpressParser::OF, 0);
}

ExpressParser::ParameterTypeContext* ExpressParser::GeneralSetTypeContext::parameterType() {
  return getRuleContext<ExpressParser::ParameterTypeContext>(0);
}

ExpressParser::BoundSpecContext* ExpressParser::GeneralSetTypeContext::boundSpec() {
  return getRuleContext<ExpressParser::BoundSpecContext>(0);
}


size_t ExpressParser::GeneralSetTypeContext::getRuleIndex() const {
  return ExpressParser::RuleGeneralSetType;
}

void ExpressParser::GeneralSetTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneralSetType(this);
}

void ExpressParser::GeneralSetTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneralSetType(this);
}


std::any ExpressParser::GeneralSetTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitGeneralSetType(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::GeneralSetTypeContext* ExpressParser::generalSetType() {
  GeneralSetTypeContext *_localctx = _tracker.createInstance<GeneralSetTypeContext>(_ctx, getState());
  enterRule(_localctx, 160, ExpressParser::RuleGeneralSetType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(887);
    match(ExpressParser::SET);
    setState(889);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::T__6) {
      setState(888);
      boundSpec();
    }
    setState(891);
    match(ExpressParser::OF);
    setState(892);
    parameterType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GenericEntityTypeContext ------------------------------------------------------------------

ExpressParser::GenericEntityTypeContext::GenericEntityTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::GenericEntityTypeContext::GENERIC_ENTITY() {
  return getToken(ExpressParser::GENERIC_ENTITY, 0);
}

ExpressParser::TypeLabelContext* ExpressParser::GenericEntityTypeContext::typeLabel() {
  return getRuleContext<ExpressParser::TypeLabelContext>(0);
}


size_t ExpressParser::GenericEntityTypeContext::getRuleIndex() const {
  return ExpressParser::RuleGenericEntityType;
}

void ExpressParser::GenericEntityTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenericEntityType(this);
}

void ExpressParser::GenericEntityTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenericEntityType(this);
}


std::any ExpressParser::GenericEntityTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitGenericEntityType(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::GenericEntityTypeContext* ExpressParser::genericEntityType() {
  GenericEntityTypeContext *_localctx = _tracker.createInstance<GenericEntityTypeContext>(_ctx, getState());
  enterRule(_localctx, 162, ExpressParser::RuleGenericEntityType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(894);
    match(ExpressParser::GENERIC_ENTITY);
    setState(897);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::T__8) {
      setState(895);
      match(ExpressParser::T__8);
      setState(896);
      typeLabel();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GenericTypeContext ------------------------------------------------------------------

ExpressParser::GenericTypeContext::GenericTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::GenericTypeContext::GENERIC() {
  return getToken(ExpressParser::GENERIC, 0);
}

ExpressParser::TypeLabelContext* ExpressParser::GenericTypeContext::typeLabel() {
  return getRuleContext<ExpressParser::TypeLabelContext>(0);
}


size_t ExpressParser::GenericTypeContext::getRuleIndex() const {
  return ExpressParser::RuleGenericType;
}

void ExpressParser::GenericTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGenericType(this);
}

void ExpressParser::GenericTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGenericType(this);
}


std::any ExpressParser::GenericTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitGenericType(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::GenericTypeContext* ExpressParser::genericType() {
  GenericTypeContext *_localctx = _tracker.createInstance<GenericTypeContext>(_ctx, getState());
  enterRule(_localctx, 164, ExpressParser::RuleGenericType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(899);
    match(ExpressParser::GENERIC);
    setState(902);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::T__8) {
      setState(900);
      match(ExpressParser::T__8);
      setState(901);
      typeLabel();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupQualifierContext ------------------------------------------------------------------

ExpressParser::GroupQualifierContext::GroupQualifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::EntityRefContext* ExpressParser::GroupQualifierContext::entityRef() {
  return getRuleContext<ExpressParser::EntityRefContext>(0);
}


size_t ExpressParser::GroupQualifierContext::getRuleIndex() const {
  return ExpressParser::RuleGroupQualifier;
}

void ExpressParser::GroupQualifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupQualifier(this);
}

void ExpressParser::GroupQualifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupQualifier(this);
}


std::any ExpressParser::GroupQualifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitGroupQualifier(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::GroupQualifierContext* ExpressParser::groupQualifier() {
  GroupQualifierContext *_localctx = _tracker.createInstance<GroupQualifierContext>(_ctx, getState());
  enterRule(_localctx, 166, ExpressParser::RuleGroupQualifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(904);
    match(ExpressParser::T__13);
    setState(905);
    entityRef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfStmtContext ------------------------------------------------------------------

ExpressParser::IfStmtContext::IfStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::IfStmtContext::IF() {
  return getToken(ExpressParser::IF, 0);
}

ExpressParser::LogicalExpressionContext* ExpressParser::IfStmtContext::logicalExpression() {
  return getRuleContext<ExpressParser::LogicalExpressionContext>(0);
}

tree::TerminalNode* ExpressParser::IfStmtContext::THEN() {
  return getToken(ExpressParser::THEN, 0);
}

ExpressParser::IfStmtStatementsContext* ExpressParser::IfStmtContext::ifStmtStatements() {
  return getRuleContext<ExpressParser::IfStmtStatementsContext>(0);
}

tree::TerminalNode* ExpressParser::IfStmtContext::END_IF() {
  return getToken(ExpressParser::END_IF, 0);
}

tree::TerminalNode* ExpressParser::IfStmtContext::ELSE() {
  return getToken(ExpressParser::ELSE, 0);
}

ExpressParser::IfStmtElseStatementsContext* ExpressParser::IfStmtContext::ifStmtElseStatements() {
  return getRuleContext<ExpressParser::IfStmtElseStatementsContext>(0);
}


size_t ExpressParser::IfStmtContext::getRuleIndex() const {
  return ExpressParser::RuleIfStmt;
}

void ExpressParser::IfStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfStmt(this);
}

void ExpressParser::IfStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfStmt(this);
}


std::any ExpressParser::IfStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitIfStmt(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::IfStmtContext* ExpressParser::ifStmt() {
  IfStmtContext *_localctx = _tracker.createInstance<IfStmtContext>(_ctx, getState());
  enterRule(_localctx, 168, ExpressParser::RuleIfStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(907);
    match(ExpressParser::IF);
    setState(908);
    logicalExpression();
    setState(909);
    match(ExpressParser::THEN);
    setState(910);
    ifStmtStatements();
    setState(913);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::ELSE) {
      setState(911);
      match(ExpressParser::ELSE);
      setState(912);
      ifStmtElseStatements();
    }
    setState(915);
    match(ExpressParser::END_IF);
    setState(916);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfStmtStatementsContext ------------------------------------------------------------------

ExpressParser::IfStmtStatementsContext::IfStmtStatementsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExpressParser::StmtContext *> ExpressParser::IfStmtStatementsContext::stmt() {
  return getRuleContexts<ExpressParser::StmtContext>();
}

ExpressParser::StmtContext* ExpressParser::IfStmtStatementsContext::stmt(size_t i) {
  return getRuleContext<ExpressParser::StmtContext>(i);
}


size_t ExpressParser::IfStmtStatementsContext::getRuleIndex() const {
  return ExpressParser::RuleIfStmtStatements;
}

void ExpressParser::IfStmtStatementsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfStmtStatements(this);
}

void ExpressParser::IfStmtStatementsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfStmtStatements(this);
}


std::any ExpressParser::IfStmtStatementsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitIfStmtStatements(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::IfStmtStatementsContext* ExpressParser::ifStmtStatements() {
  IfStmtStatementsContext *_localctx = _tracker.createInstance<IfStmtStatementsContext>(_ctx, getState());
  enterRule(_localctx, 170, ExpressParser::RuleIfStmtStatements);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(918);
    stmt();
    setState(922);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << ExpressParser::T__0)
      | (1ULL << ExpressParser::ALIAS)
      | (1ULL << ExpressParser::BEGIN_)
      | (1ULL << ExpressParser::CASE))) != 0) || ((((_la - 71) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 71)) & ((1ULL << (ExpressParser::ESCAPE - 71))
      | (1ULL << (ExpressParser::IF - 71))
      | (1ULL << (ExpressParser::INSERT - 71))
      | (1ULL << (ExpressParser::REMOVE - 71))
      | (1ULL << (ExpressParser::REPEAT - 71))
      | (1ULL << (ExpressParser::RETURN - 71))
      | (1ULL << (ExpressParser::SKIP_ - 71)))) != 0) || _la == ExpressParser::SimpleId) {
      setState(919);
      stmt();
      setState(924);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfStmtElseStatementsContext ------------------------------------------------------------------

ExpressParser::IfStmtElseStatementsContext::IfStmtElseStatementsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExpressParser::StmtContext *> ExpressParser::IfStmtElseStatementsContext::stmt() {
  return getRuleContexts<ExpressParser::StmtContext>();
}

ExpressParser::StmtContext* ExpressParser::IfStmtElseStatementsContext::stmt(size_t i) {
  return getRuleContext<ExpressParser::StmtContext>(i);
}


size_t ExpressParser::IfStmtElseStatementsContext::getRuleIndex() const {
  return ExpressParser::RuleIfStmtElseStatements;
}

void ExpressParser::IfStmtElseStatementsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfStmtElseStatements(this);
}

void ExpressParser::IfStmtElseStatementsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfStmtElseStatements(this);
}


std::any ExpressParser::IfStmtElseStatementsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitIfStmtElseStatements(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::IfStmtElseStatementsContext* ExpressParser::ifStmtElseStatements() {
  IfStmtElseStatementsContext *_localctx = _tracker.createInstance<IfStmtElseStatementsContext>(_ctx, getState());
  enterRule(_localctx, 172, ExpressParser::RuleIfStmtElseStatements);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(925);
    stmt();
    setState(929);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << ExpressParser::T__0)
      | (1ULL << ExpressParser::ALIAS)
      | (1ULL << ExpressParser::BEGIN_)
      | (1ULL << ExpressParser::CASE))) != 0) || ((((_la - 71) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 71)) & ((1ULL << (ExpressParser::ESCAPE - 71))
      | (1ULL << (ExpressParser::IF - 71))
      | (1ULL << (ExpressParser::INSERT - 71))
      | (1ULL << (ExpressParser::REMOVE - 71))
      | (1ULL << (ExpressParser::REPEAT - 71))
      | (1ULL << (ExpressParser::RETURN - 71))
      | (1ULL << (ExpressParser::SKIP_ - 71)))) != 0) || _la == ExpressParser::SimpleId) {
      setState(926);
      stmt();
      setState(931);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IncrementContext ------------------------------------------------------------------

ExpressParser::IncrementContext::IncrementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::NumericExpressionContext* ExpressParser::IncrementContext::numericExpression() {
  return getRuleContext<ExpressParser::NumericExpressionContext>(0);
}


size_t ExpressParser::IncrementContext::getRuleIndex() const {
  return ExpressParser::RuleIncrement;
}

void ExpressParser::IncrementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIncrement(this);
}

void ExpressParser::IncrementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIncrement(this);
}


std::any ExpressParser::IncrementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitIncrement(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::IncrementContext* ExpressParser::increment() {
  IncrementContext *_localctx = _tracker.createInstance<IncrementContext>(_ctx, getState());
  enterRule(_localctx, 174, ExpressParser::RuleIncrement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(932);
    numericExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IncrementControlContext ------------------------------------------------------------------

ExpressParser::IncrementControlContext::IncrementControlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::VariableIdContext* ExpressParser::IncrementControlContext::variableId() {
  return getRuleContext<ExpressParser::VariableIdContext>(0);
}

ExpressParser::Bound1Context* ExpressParser::IncrementControlContext::bound1() {
  return getRuleContext<ExpressParser::Bound1Context>(0);
}

tree::TerminalNode* ExpressParser::IncrementControlContext::TO() {
  return getToken(ExpressParser::TO, 0);
}

ExpressParser::Bound2Context* ExpressParser::IncrementControlContext::bound2() {
  return getRuleContext<ExpressParser::Bound2Context>(0);
}

tree::TerminalNode* ExpressParser::IncrementControlContext::BY() {
  return getToken(ExpressParser::BY, 0);
}

ExpressParser::IncrementContext* ExpressParser::IncrementControlContext::increment() {
  return getRuleContext<ExpressParser::IncrementContext>(0);
}


size_t ExpressParser::IncrementControlContext::getRuleIndex() const {
  return ExpressParser::RuleIncrementControl;
}

void ExpressParser::IncrementControlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIncrementControl(this);
}

void ExpressParser::IncrementControlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIncrementControl(this);
}


std::any ExpressParser::IncrementControlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitIncrementControl(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::IncrementControlContext* ExpressParser::incrementControl() {
  IncrementControlContext *_localctx = _tracker.createInstance<IncrementControlContext>(_ctx, getState());
  enterRule(_localctx, 176, ExpressParser::RuleIncrementControl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(934);
    variableId();
    setState(935);
    match(ExpressParser::T__9);
    setState(936);
    bound1();
    setState(937);
    match(ExpressParser::TO);
    setState(938);
    bound2();
    setState(941);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::BY) {
      setState(939);
      match(ExpressParser::BY);
      setState(940);
      increment();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexContext ------------------------------------------------------------------

ExpressParser::IndexContext::IndexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::NumericExpressionContext* ExpressParser::IndexContext::numericExpression() {
  return getRuleContext<ExpressParser::NumericExpressionContext>(0);
}


size_t ExpressParser::IndexContext::getRuleIndex() const {
  return ExpressParser::RuleIndex;
}

void ExpressParser::IndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndex(this);
}

void ExpressParser::IndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndex(this);
}


std::any ExpressParser::IndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitIndex(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::IndexContext* ExpressParser::index() {
  IndexContext *_localctx = _tracker.createInstance<IndexContext>(_ctx, getState());
  enterRule(_localctx, 178, ExpressParser::RuleIndex);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(943);
    numericExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index1Context ------------------------------------------------------------------

ExpressParser::Index1Context::Index1Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::IndexContext* ExpressParser::Index1Context::index() {
  return getRuleContext<ExpressParser::IndexContext>(0);
}


size_t ExpressParser::Index1Context::getRuleIndex() const {
  return ExpressParser::RuleIndex1;
}

void ExpressParser::Index1Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndex1(this);
}

void ExpressParser::Index1Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndex1(this);
}


std::any ExpressParser::Index1Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitIndex1(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::Index1Context* ExpressParser::index1() {
  Index1Context *_localctx = _tracker.createInstance<Index1Context>(_ctx, getState());
  enterRule(_localctx, 180, ExpressParser::RuleIndex1);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(945);
    index();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index2Context ------------------------------------------------------------------

ExpressParser::Index2Context::Index2Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::IndexContext* ExpressParser::Index2Context::index() {
  return getRuleContext<ExpressParser::IndexContext>(0);
}


size_t ExpressParser::Index2Context::getRuleIndex() const {
  return ExpressParser::RuleIndex2;
}

void ExpressParser::Index2Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndex2(this);
}

void ExpressParser::Index2Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndex2(this);
}


std::any ExpressParser::Index2Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitIndex2(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::Index2Context* ExpressParser::index2() {
  Index2Context *_localctx = _tracker.createInstance<Index2Context>(_ctx, getState());
  enterRule(_localctx, 182, ExpressParser::RuleIndex2);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(947);
    index();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexQualifierContext ------------------------------------------------------------------

ExpressParser::IndexQualifierContext::IndexQualifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::Index1Context* ExpressParser::IndexQualifierContext::index1() {
  return getRuleContext<ExpressParser::Index1Context>(0);
}

ExpressParser::Index2Context* ExpressParser::IndexQualifierContext::index2() {
  return getRuleContext<ExpressParser::Index2Context>(0);
}


size_t ExpressParser::IndexQualifierContext::getRuleIndex() const {
  return ExpressParser::RuleIndexQualifier;
}

void ExpressParser::IndexQualifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexQualifier(this);
}

void ExpressParser::IndexQualifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexQualifier(this);
}


std::any ExpressParser::IndexQualifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitIndexQualifier(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::IndexQualifierContext* ExpressParser::indexQualifier() {
  IndexQualifierContext *_localctx = _tracker.createInstance<IndexQualifierContext>(_ctx, getState());
  enterRule(_localctx, 184, ExpressParser::RuleIndexQualifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(949);
    match(ExpressParser::T__6);
    setState(950);
    index1();
    setState(953);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::T__8) {
      setState(951);
      match(ExpressParser::T__8);
      setState(952);
      index2();
    }
    setState(955);
    match(ExpressParser::T__7);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InstantiableTypeContext ------------------------------------------------------------------

ExpressParser::InstantiableTypeContext::InstantiableTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::ConcreteTypesContext* ExpressParser::InstantiableTypeContext::concreteTypes() {
  return getRuleContext<ExpressParser::ConcreteTypesContext>(0);
}

ExpressParser::EntityRefContext* ExpressParser::InstantiableTypeContext::entityRef() {
  return getRuleContext<ExpressParser::EntityRefContext>(0);
}


size_t ExpressParser::InstantiableTypeContext::getRuleIndex() const {
  return ExpressParser::RuleInstantiableType;
}

void ExpressParser::InstantiableTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInstantiableType(this);
}

void ExpressParser::InstantiableTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInstantiableType(this);
}


std::any ExpressParser::InstantiableTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitInstantiableType(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::InstantiableTypeContext* ExpressParser::instantiableType() {
  InstantiableTypeContext *_localctx = _tracker.createInstance<InstantiableTypeContext>(_ctx, getState());
  enterRule(_localctx, 186, ExpressParser::RuleInstantiableType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(959);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 68, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(957);
      concreteTypes();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(958);
      entityRef();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntegerTypeContext ------------------------------------------------------------------

ExpressParser::IntegerTypeContext::IntegerTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::IntegerTypeContext::INTEGER() {
  return getToken(ExpressParser::INTEGER, 0);
}


size_t ExpressParser::IntegerTypeContext::getRuleIndex() const {
  return ExpressParser::RuleIntegerType;
}

void ExpressParser::IntegerTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntegerType(this);
}

void ExpressParser::IntegerTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntegerType(this);
}


std::any ExpressParser::IntegerTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitIntegerType(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::IntegerTypeContext* ExpressParser::integerType() {
  IntegerTypeContext *_localctx = _tracker.createInstance<IntegerTypeContext>(_ctx, getState());
  enterRule(_localctx, 188, ExpressParser::RuleIntegerType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(961);
    match(ExpressParser::INTEGER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InterfaceSpecificationContext ------------------------------------------------------------------

ExpressParser::InterfaceSpecificationContext::InterfaceSpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::ReferenceClauseContext* ExpressParser::InterfaceSpecificationContext::referenceClause() {
  return getRuleContext<ExpressParser::ReferenceClauseContext>(0);
}

ExpressParser::UseClauseContext* ExpressParser::InterfaceSpecificationContext::useClause() {
  return getRuleContext<ExpressParser::UseClauseContext>(0);
}


size_t ExpressParser::InterfaceSpecificationContext::getRuleIndex() const {
  return ExpressParser::RuleInterfaceSpecification;
}

void ExpressParser::InterfaceSpecificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterfaceSpecification(this);
}

void ExpressParser::InterfaceSpecificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterfaceSpecification(this);
}


std::any ExpressParser::InterfaceSpecificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitInterfaceSpecification(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::InterfaceSpecificationContext* ExpressParser::interfaceSpecification() {
  InterfaceSpecificationContext *_localctx = _tracker.createInstance<InterfaceSpecificationContext>(_ctx, getState());
  enterRule(_localctx, 190, ExpressParser::RuleInterfaceSpecification);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(965);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExpressParser::REFERENCE: {
        enterOuterAlt(_localctx, 1);
        setState(963);
        referenceClause();
        break;
      }

      case ExpressParser::USE: {
        enterOuterAlt(_localctx, 2);
        setState(964);
        useClause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntervalContext ------------------------------------------------------------------

ExpressParser::IntervalContext::IntervalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::IntervalLowContext* ExpressParser::IntervalContext::intervalLow() {
  return getRuleContext<ExpressParser::IntervalLowContext>(0);
}

std::vector<ExpressParser::IntervalOpContext *> ExpressParser::IntervalContext::intervalOp() {
  return getRuleContexts<ExpressParser::IntervalOpContext>();
}

ExpressParser::IntervalOpContext* ExpressParser::IntervalContext::intervalOp(size_t i) {
  return getRuleContext<ExpressParser::IntervalOpContext>(i);
}

ExpressParser::IntervalItemContext* ExpressParser::IntervalContext::intervalItem() {
  return getRuleContext<ExpressParser::IntervalItemContext>(0);
}

ExpressParser::IntervalHighContext* ExpressParser::IntervalContext::intervalHigh() {
  return getRuleContext<ExpressParser::IntervalHighContext>(0);
}


size_t ExpressParser::IntervalContext::getRuleIndex() const {
  return ExpressParser::RuleInterval;
}

void ExpressParser::IntervalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterval(this);
}

void ExpressParser::IntervalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterval(this);
}


std::any ExpressParser::IntervalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitInterval(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::IntervalContext* ExpressParser::interval() {
  IntervalContext *_localctx = _tracker.createInstance<IntervalContext>(_ctx, getState());
  enterRule(_localctx, 192, ExpressParser::RuleInterval);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(967);
    match(ExpressParser::T__14);
    setState(968);
    intervalLow();
    setState(969);
    intervalOp();
    setState(970);
    intervalItem();
    setState(971);
    intervalOp();
    setState(972);
    intervalHigh();
    setState(973);
    match(ExpressParser::T__15);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntervalHighContext ------------------------------------------------------------------

ExpressParser::IntervalHighContext::IntervalHighContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::SimpleExpressionContext* ExpressParser::IntervalHighContext::simpleExpression() {
  return getRuleContext<ExpressParser::SimpleExpressionContext>(0);
}


size_t ExpressParser::IntervalHighContext::getRuleIndex() const {
  return ExpressParser::RuleIntervalHigh;
}

void ExpressParser::IntervalHighContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntervalHigh(this);
}

void ExpressParser::IntervalHighContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntervalHigh(this);
}


std::any ExpressParser::IntervalHighContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitIntervalHigh(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::IntervalHighContext* ExpressParser::intervalHigh() {
  IntervalHighContext *_localctx = _tracker.createInstance<IntervalHighContext>(_ctx, getState());
  enterRule(_localctx, 194, ExpressParser::RuleIntervalHigh);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(975);
    simpleExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntervalItemContext ------------------------------------------------------------------

ExpressParser::IntervalItemContext::IntervalItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::SimpleExpressionContext* ExpressParser::IntervalItemContext::simpleExpression() {
  return getRuleContext<ExpressParser::SimpleExpressionContext>(0);
}


size_t ExpressParser::IntervalItemContext::getRuleIndex() const {
  return ExpressParser::RuleIntervalItem;
}

void ExpressParser::IntervalItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntervalItem(this);
}

void ExpressParser::IntervalItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntervalItem(this);
}


std::any ExpressParser::IntervalItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitIntervalItem(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::IntervalItemContext* ExpressParser::intervalItem() {
  IntervalItemContext *_localctx = _tracker.createInstance<IntervalItemContext>(_ctx, getState());
  enterRule(_localctx, 196, ExpressParser::RuleIntervalItem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(977);
    simpleExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntervalLowContext ------------------------------------------------------------------

ExpressParser::IntervalLowContext::IntervalLowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::SimpleExpressionContext* ExpressParser::IntervalLowContext::simpleExpression() {
  return getRuleContext<ExpressParser::SimpleExpressionContext>(0);
}


size_t ExpressParser::IntervalLowContext::getRuleIndex() const {
  return ExpressParser::RuleIntervalLow;
}

void ExpressParser::IntervalLowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntervalLow(this);
}

void ExpressParser::IntervalLowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntervalLow(this);
}


std::any ExpressParser::IntervalLowContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitIntervalLow(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::IntervalLowContext* ExpressParser::intervalLow() {
  IntervalLowContext *_localctx = _tracker.createInstance<IntervalLowContext>(_ctx, getState());
  enterRule(_localctx, 198, ExpressParser::RuleIntervalLow);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(979);
    simpleExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntervalOpContext ------------------------------------------------------------------

ExpressParser::IntervalOpContext::IntervalOpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t ExpressParser::IntervalOpContext::getRuleIndex() const {
  return ExpressParser::RuleIntervalOp;
}

void ExpressParser::IntervalOpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntervalOp(this);
}

void ExpressParser::IntervalOpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntervalOp(this);
}


std::any ExpressParser::IntervalOpContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitIntervalOp(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::IntervalOpContext* ExpressParser::intervalOp() {
  IntervalOpContext *_localctx = _tracker.createInstance<IntervalOpContext>(_ctx, getState());
  enterRule(_localctx, 200, ExpressParser::RuleIntervalOp);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(981);
    _la = _input->LA(1);
    if (!(_la == ExpressParser::T__16

    || _la == ExpressParser::T__17)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InverseAttrContext ------------------------------------------------------------------

ExpressParser::InverseAttrContext::InverseAttrContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::AttributeDeclContext* ExpressParser::InverseAttrContext::attributeDecl() {
  return getRuleContext<ExpressParser::AttributeDeclContext>(0);
}

ExpressParser::InverseAttrTypeContext* ExpressParser::InverseAttrContext::inverseAttrType() {
  return getRuleContext<ExpressParser::InverseAttrTypeContext>(0);
}

tree::TerminalNode* ExpressParser::InverseAttrContext::FOR() {
  return getToken(ExpressParser::FOR, 0);
}

ExpressParser::AttributeRefContext* ExpressParser::InverseAttrContext::attributeRef() {
  return getRuleContext<ExpressParser::AttributeRefContext>(0);
}

ExpressParser::EntityRefContext* ExpressParser::InverseAttrContext::entityRef() {
  return getRuleContext<ExpressParser::EntityRefContext>(0);
}


size_t ExpressParser::InverseAttrContext::getRuleIndex() const {
  return ExpressParser::RuleInverseAttr;
}

void ExpressParser::InverseAttrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInverseAttr(this);
}

void ExpressParser::InverseAttrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInverseAttr(this);
}


std::any ExpressParser::InverseAttrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitInverseAttr(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::InverseAttrContext* ExpressParser::inverseAttr() {
  InverseAttrContext *_localctx = _tracker.createInstance<InverseAttrContext>(_ctx, getState());
  enterRule(_localctx, 202, ExpressParser::RuleInverseAttr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(983);
    attributeDecl();
    setState(984);
    match(ExpressParser::T__8);
    setState(985);
    inverseAttrType();
    setState(986);
    match(ExpressParser::FOR);
    setState(990);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx)) {
    case 1: {
      setState(987);
      entityRef();
      setState(988);
      match(ExpressParser::T__10);
      break;
    }

    default:
      break;
    }
    setState(992);
    attributeRef();
    setState(993);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InverseAttrTypeContext ------------------------------------------------------------------

ExpressParser::InverseAttrTypeContext::InverseAttrTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::EntityRefContext* ExpressParser::InverseAttrTypeContext::entityRef() {
  return getRuleContext<ExpressParser::EntityRefContext>(0);
}

tree::TerminalNode* ExpressParser::InverseAttrTypeContext::OF() {
  return getToken(ExpressParser::OF, 0);
}

tree::TerminalNode* ExpressParser::InverseAttrTypeContext::SET() {
  return getToken(ExpressParser::SET, 0);
}

tree::TerminalNode* ExpressParser::InverseAttrTypeContext::BAG() {
  return getToken(ExpressParser::BAG, 0);
}

ExpressParser::BoundSpecContext* ExpressParser::InverseAttrTypeContext::boundSpec() {
  return getRuleContext<ExpressParser::BoundSpecContext>(0);
}


size_t ExpressParser::InverseAttrTypeContext::getRuleIndex() const {
  return ExpressParser::RuleInverseAttrType;
}

void ExpressParser::InverseAttrTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInverseAttrType(this);
}

void ExpressParser::InverseAttrTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInverseAttrType(this);
}


std::any ExpressParser::InverseAttrTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitInverseAttrType(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::InverseAttrTypeContext* ExpressParser::inverseAttrType() {
  InverseAttrTypeContext *_localctx = _tracker.createInstance<InverseAttrTypeContext>(_ctx, getState());
  enterRule(_localctx, 204, ExpressParser::RuleInverseAttrType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1000);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::BAG || _la == ExpressParser::SET) {
      setState(995);
      _la = _input->LA(1);
      if (!(_la == ExpressParser::BAG || _la == ExpressParser::SET)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(997);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ExpressParser::T__6) {
        setState(996);
        boundSpec();
      }
      setState(999);
      match(ExpressParser::OF);
    }
    setState(1002);
    entityRef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InverseClauseContext ------------------------------------------------------------------

ExpressParser::InverseClauseContext::InverseClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::InverseClauseContext::INVERSE() {
  return getToken(ExpressParser::INVERSE, 0);
}

std::vector<ExpressParser::InverseAttrContext *> ExpressParser::InverseClauseContext::inverseAttr() {
  return getRuleContexts<ExpressParser::InverseAttrContext>();
}

ExpressParser::InverseAttrContext* ExpressParser::InverseClauseContext::inverseAttr(size_t i) {
  return getRuleContext<ExpressParser::InverseAttrContext>(i);
}


size_t ExpressParser::InverseClauseContext::getRuleIndex() const {
  return ExpressParser::RuleInverseClause;
}

void ExpressParser::InverseClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInverseClause(this);
}

void ExpressParser::InverseClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInverseClause(this);
}


std::any ExpressParser::InverseClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitInverseClause(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::InverseClauseContext* ExpressParser::inverseClause() {
  InverseClauseContext *_localctx = _tracker.createInstance<InverseClauseContext>(_ctx, getState());
  enterRule(_localctx, 206, ExpressParser::RuleInverseClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1004);
    match(ExpressParser::INVERSE);
    setState(1005);
    inverseAttr();
    setState(1009);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExpressParser::SELF

    || _la == ExpressParser::SimpleId) {
      setState(1006);
      inverseAttr();
      setState(1011);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ListTypeContext ------------------------------------------------------------------

ExpressParser::ListTypeContext::ListTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::ListTypeContext::LIST() {
  return getToken(ExpressParser::LIST, 0);
}

tree::TerminalNode* ExpressParser::ListTypeContext::OF() {
  return getToken(ExpressParser::OF, 0);
}

ExpressParser::InstantiableTypeContext* ExpressParser::ListTypeContext::instantiableType() {
  return getRuleContext<ExpressParser::InstantiableTypeContext>(0);
}

ExpressParser::BoundSpecContext* ExpressParser::ListTypeContext::boundSpec() {
  return getRuleContext<ExpressParser::BoundSpecContext>(0);
}

tree::TerminalNode* ExpressParser::ListTypeContext::UNIQUE() {
  return getToken(ExpressParser::UNIQUE, 0);
}


size_t ExpressParser::ListTypeContext::getRuleIndex() const {
  return ExpressParser::RuleListType;
}

void ExpressParser::ListTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterListType(this);
}

void ExpressParser::ListTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitListType(this);
}


std::any ExpressParser::ListTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitListType(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ListTypeContext* ExpressParser::listType() {
  ListTypeContext *_localctx = _tracker.createInstance<ListTypeContext>(_ctx, getState());
  enterRule(_localctx, 208, ExpressParser::RuleListType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1012);
    match(ExpressParser::LIST);
    setState(1014);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::T__6) {
      setState(1013);
      boundSpec();
    }
    setState(1016);
    match(ExpressParser::OF);
    setState(1018);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::UNIQUE) {
      setState(1017);
      match(ExpressParser::UNIQUE);
    }
    setState(1020);
    instantiableType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

ExpressParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::LiteralContext::BinaryLiteral() {
  return getToken(ExpressParser::BinaryLiteral, 0);
}

tree::TerminalNode* ExpressParser::LiteralContext::IntegerLiteral() {
  return getToken(ExpressParser::IntegerLiteral, 0);
}

ExpressParser::LogicalLiteralContext* ExpressParser::LiteralContext::logicalLiteral() {
  return getRuleContext<ExpressParser::LogicalLiteralContext>(0);
}

tree::TerminalNode* ExpressParser::LiteralContext::RealLiteral() {
  return getToken(ExpressParser::RealLiteral, 0);
}

ExpressParser::StringLiteralContext* ExpressParser::LiteralContext::stringLiteral() {
  return getRuleContext<ExpressParser::StringLiteralContext>(0);
}


size_t ExpressParser::LiteralContext::getRuleIndex() const {
  return ExpressParser::RuleLiteral;
}

void ExpressParser::LiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral(this);
}

void ExpressParser::LiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral(this);
}


std::any ExpressParser::LiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitLiteral(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::LiteralContext* ExpressParser::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 210, ExpressParser::RuleLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1027);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExpressParser::BinaryLiteral: {
        enterOuterAlt(_localctx, 1);
        setState(1022);
        match(ExpressParser::BinaryLiteral);
        break;
      }

      case ExpressParser::IntegerLiteral: {
        enterOuterAlt(_localctx, 2);
        setState(1023);
        match(ExpressParser::IntegerLiteral);
        break;
      }

      case ExpressParser::FALSE:
      case ExpressParser::TRUE:
      case ExpressParser::UNKNOWN: {
        enterOuterAlt(_localctx, 3);
        setState(1024);
        logicalLiteral();
        break;
      }

      case ExpressParser::RealLiteral: {
        enterOuterAlt(_localctx, 4);
        setState(1025);
        match(ExpressParser::RealLiteral);
        break;
      }

      case ExpressParser::EncodedStringLiteral:
      case ExpressParser::SimpleStringLiteral: {
        enterOuterAlt(_localctx, 5);
        setState(1026);
        stringLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LocalDeclContext ------------------------------------------------------------------

ExpressParser::LocalDeclContext::LocalDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::LocalDeclContext::LOCAL() {
  return getToken(ExpressParser::LOCAL, 0);
}

std::vector<ExpressParser::LocalVariableContext *> ExpressParser::LocalDeclContext::localVariable() {
  return getRuleContexts<ExpressParser::LocalVariableContext>();
}

ExpressParser::LocalVariableContext* ExpressParser::LocalDeclContext::localVariable(size_t i) {
  return getRuleContext<ExpressParser::LocalVariableContext>(i);
}

tree::TerminalNode* ExpressParser::LocalDeclContext::END_LOCAL() {
  return getToken(ExpressParser::END_LOCAL, 0);
}


size_t ExpressParser::LocalDeclContext::getRuleIndex() const {
  return ExpressParser::RuleLocalDecl;
}

void ExpressParser::LocalDeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLocalDecl(this);
}

void ExpressParser::LocalDeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLocalDecl(this);
}


std::any ExpressParser::LocalDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitLocalDecl(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::LocalDeclContext* ExpressParser::localDecl() {
  LocalDeclContext *_localctx = _tracker.createInstance<LocalDeclContext>(_ctx, getState());
  enterRule(_localctx, 212, ExpressParser::RuleLocalDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1029);
    match(ExpressParser::LOCAL);
    setState(1030);
    localVariable();
    setState(1034);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExpressParser::SimpleId) {
      setState(1031);
      localVariable();
      setState(1036);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1037);
    match(ExpressParser::END_LOCAL);
    setState(1038);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LocalVariableContext ------------------------------------------------------------------

ExpressParser::LocalVariableContext::LocalVariableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExpressParser::VariableIdContext *> ExpressParser::LocalVariableContext::variableId() {
  return getRuleContexts<ExpressParser::VariableIdContext>();
}

ExpressParser::VariableIdContext* ExpressParser::LocalVariableContext::variableId(size_t i) {
  return getRuleContext<ExpressParser::VariableIdContext>(i);
}

ExpressParser::ParameterTypeContext* ExpressParser::LocalVariableContext::parameterType() {
  return getRuleContext<ExpressParser::ParameterTypeContext>(0);
}

ExpressParser::ExpressionContext* ExpressParser::LocalVariableContext::expression() {
  return getRuleContext<ExpressParser::ExpressionContext>(0);
}


size_t ExpressParser::LocalVariableContext::getRuleIndex() const {
  return ExpressParser::RuleLocalVariable;
}

void ExpressParser::LocalVariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLocalVariable(this);
}

void ExpressParser::LocalVariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLocalVariable(this);
}


std::any ExpressParser::LocalVariableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitLocalVariable(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::LocalVariableContext* ExpressParser::localVariable() {
  LocalVariableContext *_localctx = _tracker.createInstance<LocalVariableContext>(_ctx, getState());
  enterRule(_localctx, 214, ExpressParser::RuleLocalVariable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1040);
    variableId();
    setState(1045);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExpressParser::T__2) {
      setState(1041);
      match(ExpressParser::T__2);
      setState(1042);
      variableId();
      setState(1047);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1048);
    match(ExpressParser::T__8);
    setState(1049);
    parameterType();
    setState(1052);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::T__9) {
      setState(1050);
      match(ExpressParser::T__9);
      setState(1051);
      expression();
    }
    setState(1054);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogicalExpressionContext ------------------------------------------------------------------

ExpressParser::LogicalExpressionContext::LogicalExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::ExpressionContext* ExpressParser::LogicalExpressionContext::expression() {
  return getRuleContext<ExpressParser::ExpressionContext>(0);
}


size_t ExpressParser::LogicalExpressionContext::getRuleIndex() const {
  return ExpressParser::RuleLogicalExpression;
}

void ExpressParser::LogicalExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogicalExpression(this);
}

void ExpressParser::LogicalExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogicalExpression(this);
}


std::any ExpressParser::LogicalExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitLogicalExpression(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::LogicalExpressionContext* ExpressParser::logicalExpression() {
  LogicalExpressionContext *_localctx = _tracker.createInstance<LogicalExpressionContext>(_ctx, getState());
  enterRule(_localctx, 216, ExpressParser::RuleLogicalExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1056);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogicalLiteralContext ------------------------------------------------------------------

ExpressParser::LogicalLiteralContext::LogicalLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::LogicalLiteralContext::FALSE() {
  return getToken(ExpressParser::FALSE, 0);
}

tree::TerminalNode* ExpressParser::LogicalLiteralContext::TRUE() {
  return getToken(ExpressParser::TRUE, 0);
}

tree::TerminalNode* ExpressParser::LogicalLiteralContext::UNKNOWN() {
  return getToken(ExpressParser::UNKNOWN, 0);
}


size_t ExpressParser::LogicalLiteralContext::getRuleIndex() const {
  return ExpressParser::RuleLogicalLiteral;
}

void ExpressParser::LogicalLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogicalLiteral(this);
}

void ExpressParser::LogicalLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogicalLiteral(this);
}


std::any ExpressParser::LogicalLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitLogicalLiteral(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::LogicalLiteralContext* ExpressParser::logicalLiteral() {
  LogicalLiteralContext *_localctx = _tracker.createInstance<LogicalLiteralContext>(_ctx, getState());
  enterRule(_localctx, 218, ExpressParser::RuleLogicalLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1058);
    _la = _input->LA(1);
    if (!(_la == ExpressParser::FALSE

    || _la == ExpressParser::TRUE || _la == ExpressParser::UNKNOWN)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogicalTypeContext ------------------------------------------------------------------

ExpressParser::LogicalTypeContext::LogicalTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::LogicalTypeContext::LOGICAL() {
  return getToken(ExpressParser::LOGICAL, 0);
}


size_t ExpressParser::LogicalTypeContext::getRuleIndex() const {
  return ExpressParser::RuleLogicalType;
}

void ExpressParser::LogicalTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogicalType(this);
}

void ExpressParser::LogicalTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogicalType(this);
}


std::any ExpressParser::LogicalTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitLogicalType(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::LogicalTypeContext* ExpressParser::logicalType() {
  LogicalTypeContext *_localctx = _tracker.createInstance<LogicalTypeContext>(_ctx, getState());
  enterRule(_localctx, 220, ExpressParser::RuleLogicalType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1060);
    match(ExpressParser::LOGICAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultiplicationLikeOpContext ------------------------------------------------------------------

ExpressParser::MultiplicationLikeOpContext::MultiplicationLikeOpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::MultiplicationLikeOpContext::DIV() {
  return getToken(ExpressParser::DIV, 0);
}

tree::TerminalNode* ExpressParser::MultiplicationLikeOpContext::MOD() {
  return getToken(ExpressParser::MOD, 0);
}

tree::TerminalNode* ExpressParser::MultiplicationLikeOpContext::AND() {
  return getToken(ExpressParser::AND, 0);
}


size_t ExpressParser::MultiplicationLikeOpContext::getRuleIndex() const {
  return ExpressParser::RuleMultiplicationLikeOp;
}

void ExpressParser::MultiplicationLikeOpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultiplicationLikeOp(this);
}

void ExpressParser::MultiplicationLikeOpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultiplicationLikeOp(this);
}


std::any ExpressParser::MultiplicationLikeOpContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitMultiplicationLikeOp(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::MultiplicationLikeOpContext* ExpressParser::multiplicationLikeOp() {
  MultiplicationLikeOpContext *_localctx = _tracker.createInstance<MultiplicationLikeOpContext>(_ctx, getState());
  enterRule(_localctx, 222, ExpressParser::RuleMultiplicationLikeOp);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1062);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << ExpressParser::T__18)
      | (1ULL << ExpressParser::T__19)
      | (1ULL << ExpressParser::T__20)
      | (1ULL << ExpressParser::AND)
      | (1ULL << ExpressParser::DIV))) != 0) || _la == ExpressParser::MOD)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamedTypesContext ------------------------------------------------------------------

ExpressParser::NamedTypesContext::NamedTypesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::EntityRefContext* ExpressParser::NamedTypesContext::entityRef() {
  return getRuleContext<ExpressParser::EntityRefContext>(0);
}

ExpressParser::TypeRefContext* ExpressParser::NamedTypesContext::typeRef() {
  return getRuleContext<ExpressParser::TypeRefContext>(0);
}


size_t ExpressParser::NamedTypesContext::getRuleIndex() const {
  return ExpressParser::RuleNamedTypes;
}

void ExpressParser::NamedTypesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamedTypes(this);
}

void ExpressParser::NamedTypesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamedTypes(this);
}


std::any ExpressParser::NamedTypesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitNamedTypes(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::NamedTypesContext* ExpressParser::namedTypes() {
  NamedTypesContext *_localctx = _tracker.createInstance<NamedTypesContext>(_ctx, getState());
  enterRule(_localctx, 224, ExpressParser::RuleNamedTypes);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1066);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1064);
      entityRef();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1065);
      typeRef();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamedTypeOrRenameContext ------------------------------------------------------------------

ExpressParser::NamedTypeOrRenameContext::NamedTypeOrRenameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::NamedTypesContext* ExpressParser::NamedTypeOrRenameContext::namedTypes() {
  return getRuleContext<ExpressParser::NamedTypesContext>(0);
}

tree::TerminalNode* ExpressParser::NamedTypeOrRenameContext::AS() {
  return getToken(ExpressParser::AS, 0);
}

ExpressParser::EntityIdContext* ExpressParser::NamedTypeOrRenameContext::entityId() {
  return getRuleContext<ExpressParser::EntityIdContext>(0);
}

ExpressParser::TypeIdContext* ExpressParser::NamedTypeOrRenameContext::typeId() {
  return getRuleContext<ExpressParser::TypeIdContext>(0);
}


size_t ExpressParser::NamedTypeOrRenameContext::getRuleIndex() const {
  return ExpressParser::RuleNamedTypeOrRename;
}

void ExpressParser::NamedTypeOrRenameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamedTypeOrRename(this);
}

void ExpressParser::NamedTypeOrRenameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamedTypeOrRename(this);
}


std::any ExpressParser::NamedTypeOrRenameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitNamedTypeOrRename(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::NamedTypeOrRenameContext* ExpressParser::namedTypeOrRename() {
  NamedTypeOrRenameContext *_localctx = _tracker.createInstance<NamedTypeOrRenameContext>(_ctx, getState());
  enterRule(_localctx, 226, ExpressParser::RuleNamedTypeOrRename);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1068);
    namedTypes();
    setState(1074);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::AS) {
      setState(1069);
      match(ExpressParser::AS);
      setState(1072);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx)) {
      case 1: {
        setState(1070);
        entityId();
        break;
      }

      case 2: {
        setState(1071);
        typeId();
        break;
      }

      default:
        break;
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NullStmtContext ------------------------------------------------------------------

ExpressParser::NullStmtContext::NullStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t ExpressParser::NullStmtContext::getRuleIndex() const {
  return ExpressParser::RuleNullStmt;
}

void ExpressParser::NullStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullStmt(this);
}

void ExpressParser::NullStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullStmt(this);
}


std::any ExpressParser::NullStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitNullStmt(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::NullStmtContext* ExpressParser::nullStmt() {
  NullStmtContext *_localctx = _tracker.createInstance<NullStmtContext>(_ctx, getState());
  enterRule(_localctx, 228, ExpressParser::RuleNullStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1076);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumberTypeContext ------------------------------------------------------------------

ExpressParser::NumberTypeContext::NumberTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::NumberTypeContext::NUMBER() {
  return getToken(ExpressParser::NUMBER, 0);
}


size_t ExpressParser::NumberTypeContext::getRuleIndex() const {
  return ExpressParser::RuleNumberType;
}

void ExpressParser::NumberTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumberType(this);
}

void ExpressParser::NumberTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumberType(this);
}


std::any ExpressParser::NumberTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitNumberType(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::NumberTypeContext* ExpressParser::numberType() {
  NumberTypeContext *_localctx = _tracker.createInstance<NumberTypeContext>(_ctx, getState());
  enterRule(_localctx, 230, ExpressParser::RuleNumberType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1078);
    match(ExpressParser::NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericExpressionContext ------------------------------------------------------------------

ExpressParser::NumericExpressionContext::NumericExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::SimpleExpressionContext* ExpressParser::NumericExpressionContext::simpleExpression() {
  return getRuleContext<ExpressParser::SimpleExpressionContext>(0);
}


size_t ExpressParser::NumericExpressionContext::getRuleIndex() const {
  return ExpressParser::RuleNumericExpression;
}

void ExpressParser::NumericExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericExpression(this);
}

void ExpressParser::NumericExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericExpression(this);
}


std::any ExpressParser::NumericExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitNumericExpression(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::NumericExpressionContext* ExpressParser::numericExpression() {
  NumericExpressionContext *_localctx = _tracker.createInstance<NumericExpressionContext>(_ctx, getState());
  enterRule(_localctx, 232, ExpressParser::RuleNumericExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1080);
    simpleExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OneOfContext ------------------------------------------------------------------

ExpressParser::OneOfContext::OneOfContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::OneOfContext::ONEOF() {
  return getToken(ExpressParser::ONEOF, 0);
}

std::vector<ExpressParser::SupertypeExpressionContext *> ExpressParser::OneOfContext::supertypeExpression() {
  return getRuleContexts<ExpressParser::SupertypeExpressionContext>();
}

ExpressParser::SupertypeExpressionContext* ExpressParser::OneOfContext::supertypeExpression(size_t i) {
  return getRuleContext<ExpressParser::SupertypeExpressionContext>(i);
}


size_t ExpressParser::OneOfContext::getRuleIndex() const {
  return ExpressParser::RuleOneOf;
}

void ExpressParser::OneOfContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOneOf(this);
}

void ExpressParser::OneOfContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOneOf(this);
}


std::any ExpressParser::OneOfContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitOneOf(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::OneOfContext* ExpressParser::oneOf() {
  OneOfContext *_localctx = _tracker.createInstance<OneOfContext>(_ctx, getState());
  enterRule(_localctx, 234, ExpressParser::RuleOneOf);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1082);
    match(ExpressParser::ONEOF);
    setState(1083);
    match(ExpressParser::T__1);
    setState(1084);
    supertypeExpression();
    setState(1089);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExpressParser::T__2) {
      setState(1085);
      match(ExpressParser::T__2);
      setState(1086);
      supertypeExpression();
      setState(1091);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1092);
    match(ExpressParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterContext ------------------------------------------------------------------

ExpressParser::ParameterContext::ParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::ExpressionContext* ExpressParser::ParameterContext::expression() {
  return getRuleContext<ExpressParser::ExpressionContext>(0);
}


size_t ExpressParser::ParameterContext::getRuleIndex() const {
  return ExpressParser::RuleParameter;
}

void ExpressParser::ParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameter(this);
}

void ExpressParser::ParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameter(this);
}


std::any ExpressParser::ParameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitParameter(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ParameterContext* ExpressParser::parameter() {
  ParameterContext *_localctx = _tracker.createInstance<ParameterContext>(_ctx, getState());
  enterRule(_localctx, 236, ExpressParser::RuleParameter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1094);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterIdContext ------------------------------------------------------------------

ExpressParser::ParameterIdContext::ParameterIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::ParameterIdContext::SimpleId() {
  return getToken(ExpressParser::SimpleId, 0);
}


size_t ExpressParser::ParameterIdContext::getRuleIndex() const {
  return ExpressParser::RuleParameterId;
}

void ExpressParser::ParameterIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameterId(this);
}

void ExpressParser::ParameterIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameterId(this);
}


std::any ExpressParser::ParameterIdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitParameterId(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ParameterIdContext* ExpressParser::parameterId() {
  ParameterIdContext *_localctx = _tracker.createInstance<ParameterIdContext>(_ctx, getState());
  enterRule(_localctx, 238, ExpressParser::RuleParameterId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1096);
    match(ExpressParser::SimpleId);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterTypeContext ------------------------------------------------------------------

ExpressParser::ParameterTypeContext::ParameterTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::GeneralizedTypesContext* ExpressParser::ParameterTypeContext::generalizedTypes() {
  return getRuleContext<ExpressParser::GeneralizedTypesContext>(0);
}

ExpressParser::NamedTypesContext* ExpressParser::ParameterTypeContext::namedTypes() {
  return getRuleContext<ExpressParser::NamedTypesContext>(0);
}

ExpressParser::SimpleTypesContext* ExpressParser::ParameterTypeContext::simpleTypes() {
  return getRuleContext<ExpressParser::SimpleTypesContext>(0);
}


size_t ExpressParser::ParameterTypeContext::getRuleIndex() const {
  return ExpressParser::RuleParameterType;
}

void ExpressParser::ParameterTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameterType(this);
}

void ExpressParser::ParameterTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameterType(this);
}


std::any ExpressParser::ParameterTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitParameterType(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ParameterTypeContext* ExpressParser::parameterType() {
  ParameterTypeContext *_localctx = _tracker.createInstance<ParameterTypeContext>(_ctx, getState());
  enterRule(_localctx, 240, ExpressParser::RuleParameterType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1101);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExpressParser::AGGREGATE:
      case ExpressParser::ARRAY:
      case ExpressParser::BAG:
      case ExpressParser::GENERIC:
      case ExpressParser::GENERIC_ENTITY:
      case ExpressParser::LIST:
      case ExpressParser::SET: {
        enterOuterAlt(_localctx, 1);
        setState(1098);
        generalizedTypes();
        break;
      }

      case ExpressParser::SimpleId: {
        enterOuterAlt(_localctx, 2);
        setState(1099);
        namedTypes();
        break;
      }

      case ExpressParser::BINARY:
      case ExpressParser::BOOLEAN:
      case ExpressParser::INTEGER:
      case ExpressParser::LOGICAL:
      case ExpressParser::NUMBER:
      case ExpressParser::REAL:
      case ExpressParser::STRING: {
        enterOuterAlt(_localctx, 3);
        setState(1100);
        simpleTypes();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PopulationContext ------------------------------------------------------------------

ExpressParser::PopulationContext::PopulationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::EntityRefContext* ExpressParser::PopulationContext::entityRef() {
  return getRuleContext<ExpressParser::EntityRefContext>(0);
}


size_t ExpressParser::PopulationContext::getRuleIndex() const {
  return ExpressParser::RulePopulation;
}

void ExpressParser::PopulationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPopulation(this);
}

void ExpressParser::PopulationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPopulation(this);
}


std::any ExpressParser::PopulationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitPopulation(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::PopulationContext* ExpressParser::population() {
  PopulationContext *_localctx = _tracker.createInstance<PopulationContext>(_ctx, getState());
  enterRule(_localctx, 242, ExpressParser::RulePopulation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1103);
    entityRef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrecisionSpecContext ------------------------------------------------------------------

ExpressParser::PrecisionSpecContext::PrecisionSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::NumericExpressionContext* ExpressParser::PrecisionSpecContext::numericExpression() {
  return getRuleContext<ExpressParser::NumericExpressionContext>(0);
}


size_t ExpressParser::PrecisionSpecContext::getRuleIndex() const {
  return ExpressParser::RulePrecisionSpec;
}

void ExpressParser::PrecisionSpecContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrecisionSpec(this);
}

void ExpressParser::PrecisionSpecContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrecisionSpec(this);
}


std::any ExpressParser::PrecisionSpecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitPrecisionSpec(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::PrecisionSpecContext* ExpressParser::precisionSpec() {
  PrecisionSpecContext *_localctx = _tracker.createInstance<PrecisionSpecContext>(_ctx, getState());
  enterRule(_localctx, 244, ExpressParser::RulePrecisionSpec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1105);
    numericExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrimaryContext ------------------------------------------------------------------

ExpressParser::PrimaryContext::PrimaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::LiteralContext* ExpressParser::PrimaryContext::literal() {
  return getRuleContext<ExpressParser::LiteralContext>(0);
}

ExpressParser::QualifiableFactorContext* ExpressParser::PrimaryContext::qualifiableFactor() {
  return getRuleContext<ExpressParser::QualifiableFactorContext>(0);
}

std::vector<ExpressParser::QualifierContext *> ExpressParser::PrimaryContext::qualifier() {
  return getRuleContexts<ExpressParser::QualifierContext>();
}

ExpressParser::QualifierContext* ExpressParser::PrimaryContext::qualifier(size_t i) {
  return getRuleContext<ExpressParser::QualifierContext>(i);
}


size_t ExpressParser::PrimaryContext::getRuleIndex() const {
  return ExpressParser::RulePrimary;
}

void ExpressParser::PrimaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimary(this);
}

void ExpressParser::PrimaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimary(this);
}


std::any ExpressParser::PrimaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitPrimary(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::PrimaryContext* ExpressParser::primary() {
  PrimaryContext *_localctx = _tracker.createInstance<PrimaryContext>(_ctx, getState());
  enterRule(_localctx, 246, ExpressParser::RulePrimary);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1115);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExpressParser::FALSE:
      case ExpressParser::TRUE:
      case ExpressParser::UNKNOWN:
      case ExpressParser::BinaryLiteral:
      case ExpressParser::EncodedStringLiteral:
      case ExpressParser::IntegerLiteral:
      case ExpressParser::RealLiteral:
      case ExpressParser::SimpleStringLiteral: {
        enterOuterAlt(_localctx, 1);
        setState(1107);
        literal();
        break;
      }

      case ExpressParser::T__11:
      case ExpressParser::ABS:
      case ExpressParser::ACOS:
      case ExpressParser::ASIN:
      case ExpressParser::ATAN:
      case ExpressParser::BLENGTH:
      case ExpressParser::CONST_E:
      case ExpressParser::COS:
      case ExpressParser::EXISTS:
      case ExpressParser::EXP:
      case ExpressParser::FORMAT:
      case ExpressParser::HIBOUND:
      case ExpressParser::HIINDEX:
      case ExpressParser::LENGTH:
      case ExpressParser::LOBOUND:
      case ExpressParser::LOG:
      case ExpressParser::LOG10:
      case ExpressParser::LOG2:
      case ExpressParser::LOINDEX:
      case ExpressParser::NVL:
      case ExpressParser::ODD:
      case ExpressParser::PI:
      case ExpressParser::ROLESOF:
      case ExpressParser::SELF:
      case ExpressParser::SIN:
      case ExpressParser::SIZEOF:
      case ExpressParser::SQRT:
      case ExpressParser::TAN:
      case ExpressParser::TYPEOF:
      case ExpressParser::USEDIN:
      case ExpressParser::VALUE_:
      case ExpressParser::VALUE_IN:
      case ExpressParser::VALUE_UNIQUE:
      case ExpressParser::SimpleId: {
        enterOuterAlt(_localctx, 2);
        setState(1108);
        qualifiableFactor();
        setState(1112);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & ((1ULL << ExpressParser::T__6)
          | (1ULL << ExpressParser::T__10)
          | (1ULL << ExpressParser::T__13))) != 0)) {
          setState(1109);
          qualifier();
          setState(1114);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcedureCallStmtContext ------------------------------------------------------------------

ExpressParser::ProcedureCallStmtContext::ProcedureCallStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::BuiltInProcedureContext* ExpressParser::ProcedureCallStmtContext::builtInProcedure() {
  return getRuleContext<ExpressParser::BuiltInProcedureContext>(0);
}

ExpressParser::ProcedureRefContext* ExpressParser::ProcedureCallStmtContext::procedureRef() {
  return getRuleContext<ExpressParser::ProcedureRefContext>(0);
}

ExpressParser::ActualParameterListContext* ExpressParser::ProcedureCallStmtContext::actualParameterList() {
  return getRuleContext<ExpressParser::ActualParameterListContext>(0);
}


size_t ExpressParser::ProcedureCallStmtContext::getRuleIndex() const {
  return ExpressParser::RuleProcedureCallStmt;
}

void ExpressParser::ProcedureCallStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedureCallStmt(this);
}

void ExpressParser::ProcedureCallStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedureCallStmt(this);
}


std::any ExpressParser::ProcedureCallStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitProcedureCallStmt(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ProcedureCallStmtContext* ExpressParser::procedureCallStmt() {
  ProcedureCallStmtContext *_localctx = _tracker.createInstance<ProcedureCallStmtContext>(_ctx, getState());
  enterRule(_localctx, 248, ExpressParser::RuleProcedureCallStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1119);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExpressParser::INSERT:
      case ExpressParser::REMOVE: {
        setState(1117);
        builtInProcedure();
        break;
      }

      case ExpressParser::SimpleId: {
        setState(1118);
        procedureRef();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1122);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::T__1) {
      setState(1121);
      actualParameterList();
    }
    setState(1124);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcedureDeclContext ------------------------------------------------------------------

ExpressParser::ProcedureDeclContext::ProcedureDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::ProcedureHeadContext* ExpressParser::ProcedureDeclContext::procedureHead() {
  return getRuleContext<ExpressParser::ProcedureHeadContext>(0);
}

ExpressParser::AlgorithmHeadContext* ExpressParser::ProcedureDeclContext::algorithmHead() {
  return getRuleContext<ExpressParser::AlgorithmHeadContext>(0);
}

tree::TerminalNode* ExpressParser::ProcedureDeclContext::END_PROCEDURE() {
  return getToken(ExpressParser::END_PROCEDURE, 0);
}

std::vector<ExpressParser::StmtContext *> ExpressParser::ProcedureDeclContext::stmt() {
  return getRuleContexts<ExpressParser::StmtContext>();
}

ExpressParser::StmtContext* ExpressParser::ProcedureDeclContext::stmt(size_t i) {
  return getRuleContext<ExpressParser::StmtContext>(i);
}


size_t ExpressParser::ProcedureDeclContext::getRuleIndex() const {
  return ExpressParser::RuleProcedureDecl;
}

void ExpressParser::ProcedureDeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedureDecl(this);
}

void ExpressParser::ProcedureDeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedureDecl(this);
}


std::any ExpressParser::ProcedureDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitProcedureDecl(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ProcedureDeclContext* ExpressParser::procedureDecl() {
  ProcedureDeclContext *_localctx = _tracker.createInstance<ProcedureDeclContext>(_ctx, getState());
  enterRule(_localctx, 250, ExpressParser::RuleProcedureDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1126);
    procedureHead();
    setState(1127);
    algorithmHead();
    setState(1131);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << ExpressParser::T__0)
      | (1ULL << ExpressParser::ALIAS)
      | (1ULL << ExpressParser::BEGIN_)
      | (1ULL << ExpressParser::CASE))) != 0) || ((((_la - 71) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 71)) & ((1ULL << (ExpressParser::ESCAPE - 71))
      | (1ULL << (ExpressParser::IF - 71))
      | (1ULL << (ExpressParser::INSERT - 71))
      | (1ULL << (ExpressParser::REMOVE - 71))
      | (1ULL << (ExpressParser::REPEAT - 71))
      | (1ULL << (ExpressParser::RETURN - 71))
      | (1ULL << (ExpressParser::SKIP_ - 71)))) != 0) || _la == ExpressParser::SimpleId) {
      setState(1128);
      stmt();
      setState(1133);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1134);
    match(ExpressParser::END_PROCEDURE);
    setState(1135);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcedureHeadContext ------------------------------------------------------------------

ExpressParser::ProcedureHeadContext::ProcedureHeadContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::ProcedureHeadContext::PROCEDURE() {
  return getToken(ExpressParser::PROCEDURE, 0);
}

ExpressParser::ProcedureIdContext* ExpressParser::ProcedureHeadContext::procedureId() {
  return getRuleContext<ExpressParser::ProcedureIdContext>(0);
}

std::vector<ExpressParser::ProcedureHeadParameterContext *> ExpressParser::ProcedureHeadContext::procedureHeadParameter() {
  return getRuleContexts<ExpressParser::ProcedureHeadParameterContext>();
}

ExpressParser::ProcedureHeadParameterContext* ExpressParser::ProcedureHeadContext::procedureHeadParameter(size_t i) {
  return getRuleContext<ExpressParser::ProcedureHeadParameterContext>(i);
}


size_t ExpressParser::ProcedureHeadContext::getRuleIndex() const {
  return ExpressParser::RuleProcedureHead;
}

void ExpressParser::ProcedureHeadContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedureHead(this);
}

void ExpressParser::ProcedureHeadContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedureHead(this);
}


std::any ExpressParser::ProcedureHeadContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitProcedureHead(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ProcedureHeadContext* ExpressParser::procedureHead() {
  ProcedureHeadContext *_localctx = _tracker.createInstance<ProcedureHeadContext>(_ctx, getState());
  enterRule(_localctx, 252, ExpressParser::RuleProcedureHead);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1137);
    match(ExpressParser::PROCEDURE);
    setState(1138);
    procedureId();
    setState(1150);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::T__1) {
      setState(1139);
      match(ExpressParser::T__1);
      setState(1140);
      procedureHeadParameter();
      setState(1145);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == ExpressParser::T__0) {
        setState(1141);
        match(ExpressParser::T__0);
        setState(1142);
        procedureHeadParameter();
        setState(1147);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1148);
      match(ExpressParser::T__3);
    }
    setState(1152);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcedureHeadParameterContext ------------------------------------------------------------------

ExpressParser::ProcedureHeadParameterContext::ProcedureHeadParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::FormalParameterContext* ExpressParser::ProcedureHeadParameterContext::formalParameter() {
  return getRuleContext<ExpressParser::FormalParameterContext>(0);
}

tree::TerminalNode* ExpressParser::ProcedureHeadParameterContext::VAR() {
  return getToken(ExpressParser::VAR, 0);
}


size_t ExpressParser::ProcedureHeadParameterContext::getRuleIndex() const {
  return ExpressParser::RuleProcedureHeadParameter;
}

void ExpressParser::ProcedureHeadParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedureHeadParameter(this);
}

void ExpressParser::ProcedureHeadParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedureHeadParameter(this);
}


std::any ExpressParser::ProcedureHeadParameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitProcedureHeadParameter(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ProcedureHeadParameterContext* ExpressParser::procedureHeadParameter() {
  ProcedureHeadParameterContext *_localctx = _tracker.createInstance<ProcedureHeadParameterContext>(_ctx, getState());
  enterRule(_localctx, 254, ExpressParser::RuleProcedureHeadParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1155);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::VAR) {
      setState(1154);
      match(ExpressParser::VAR);
    }
    setState(1157);
    formalParameter();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcedureIdContext ------------------------------------------------------------------

ExpressParser::ProcedureIdContext::ProcedureIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::ProcedureIdContext::SimpleId() {
  return getToken(ExpressParser::SimpleId, 0);
}


size_t ExpressParser::ProcedureIdContext::getRuleIndex() const {
  return ExpressParser::RuleProcedureId;
}

void ExpressParser::ProcedureIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedureId(this);
}

void ExpressParser::ProcedureIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedureId(this);
}


std::any ExpressParser::ProcedureIdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitProcedureId(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ProcedureIdContext* ExpressParser::procedureId() {
  ProcedureIdContext *_localctx = _tracker.createInstance<ProcedureIdContext>(_ctx, getState());
  enterRule(_localctx, 256, ExpressParser::RuleProcedureId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1159);
    match(ExpressParser::SimpleId);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiableFactorContext ------------------------------------------------------------------

ExpressParser::QualifiableFactorContext::QualifiableFactorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::AttributeRefContext* ExpressParser::QualifiableFactorContext::attributeRef() {
  return getRuleContext<ExpressParser::AttributeRefContext>(0);
}

ExpressParser::ConstantFactorContext* ExpressParser::QualifiableFactorContext::constantFactor() {
  return getRuleContext<ExpressParser::ConstantFactorContext>(0);
}

ExpressParser::FunctionCallContext* ExpressParser::QualifiableFactorContext::functionCall() {
  return getRuleContext<ExpressParser::FunctionCallContext>(0);
}

ExpressParser::GeneralRefContext* ExpressParser::QualifiableFactorContext::generalRef() {
  return getRuleContext<ExpressParser::GeneralRefContext>(0);
}

ExpressParser::PopulationContext* ExpressParser::QualifiableFactorContext::population() {
  return getRuleContext<ExpressParser::PopulationContext>(0);
}


size_t ExpressParser::QualifiableFactorContext::getRuleIndex() const {
  return ExpressParser::RuleQualifiableFactor;
}

void ExpressParser::QualifiableFactorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualifiableFactor(this);
}

void ExpressParser::QualifiableFactorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualifiableFactor(this);
}


std::any ExpressParser::QualifiableFactorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitQualifiableFactor(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::QualifiableFactorContext* ExpressParser::qualifiableFactor() {
  QualifiableFactorContext *_localctx = _tracker.createInstance<QualifiableFactorContext>(_ctx, getState());
  enterRule(_localctx, 258, ExpressParser::RuleQualifiableFactor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1166);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 93, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1161);
      attributeRef();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1162);
      constantFactor();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1163);
      functionCall();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1164);
      generalRef();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1165);
      population();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiedAttributeContext ------------------------------------------------------------------

ExpressParser::QualifiedAttributeContext::QualifiedAttributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::QualifiedAttributeContext::SELF() {
  return getToken(ExpressParser::SELF, 0);
}

ExpressParser::GroupQualifierContext* ExpressParser::QualifiedAttributeContext::groupQualifier() {
  return getRuleContext<ExpressParser::GroupQualifierContext>(0);
}

ExpressParser::AttributeQualifierContext* ExpressParser::QualifiedAttributeContext::attributeQualifier() {
  return getRuleContext<ExpressParser::AttributeQualifierContext>(0);
}


size_t ExpressParser::QualifiedAttributeContext::getRuleIndex() const {
  return ExpressParser::RuleQualifiedAttribute;
}

void ExpressParser::QualifiedAttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualifiedAttribute(this);
}

void ExpressParser::QualifiedAttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualifiedAttribute(this);
}


std::any ExpressParser::QualifiedAttributeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitQualifiedAttribute(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::QualifiedAttributeContext* ExpressParser::qualifiedAttribute() {
  QualifiedAttributeContext *_localctx = _tracker.createInstance<QualifiedAttributeContext>(_ctx, getState());
  enterRule(_localctx, 260, ExpressParser::RuleQualifiedAttribute);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1168);
    match(ExpressParser::SELF);
    setState(1169);
    groupQualifier();
    setState(1170);
    attributeQualifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifierContext ------------------------------------------------------------------

ExpressParser::QualifierContext::QualifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::AttributeQualifierContext* ExpressParser::QualifierContext::attributeQualifier() {
  return getRuleContext<ExpressParser::AttributeQualifierContext>(0);
}

ExpressParser::GroupQualifierContext* ExpressParser::QualifierContext::groupQualifier() {
  return getRuleContext<ExpressParser::GroupQualifierContext>(0);
}

ExpressParser::IndexQualifierContext* ExpressParser::QualifierContext::indexQualifier() {
  return getRuleContext<ExpressParser::IndexQualifierContext>(0);
}


size_t ExpressParser::QualifierContext::getRuleIndex() const {
  return ExpressParser::RuleQualifier;
}

void ExpressParser::QualifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualifier(this);
}

void ExpressParser::QualifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualifier(this);
}


std::any ExpressParser::QualifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitQualifier(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::QualifierContext* ExpressParser::qualifier() {
  QualifierContext *_localctx = _tracker.createInstance<QualifierContext>(_ctx, getState());
  enterRule(_localctx, 262, ExpressParser::RuleQualifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1175);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExpressParser::T__10: {
        enterOuterAlt(_localctx, 1);
        setState(1172);
        attributeQualifier();
        break;
      }

      case ExpressParser::T__13: {
        enterOuterAlt(_localctx, 2);
        setState(1173);
        groupQualifier();
        break;
      }

      case ExpressParser::T__6: {
        enterOuterAlt(_localctx, 3);
        setState(1174);
        indexQualifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryExpressionContext ------------------------------------------------------------------

ExpressParser::QueryExpressionContext::QueryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::QueryExpressionContext::QUERY() {
  return getToken(ExpressParser::QUERY, 0);
}

ExpressParser::VariableIdContext* ExpressParser::QueryExpressionContext::variableId() {
  return getRuleContext<ExpressParser::VariableIdContext>(0);
}

ExpressParser::AggregateSourceContext* ExpressParser::QueryExpressionContext::aggregateSource() {
  return getRuleContext<ExpressParser::AggregateSourceContext>(0);
}

ExpressParser::LogicalExpressionContext* ExpressParser::QueryExpressionContext::logicalExpression() {
  return getRuleContext<ExpressParser::LogicalExpressionContext>(0);
}


size_t ExpressParser::QueryExpressionContext::getRuleIndex() const {
  return ExpressParser::RuleQueryExpression;
}

void ExpressParser::QueryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryExpression(this);
}

void ExpressParser::QueryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryExpression(this);
}


std::any ExpressParser::QueryExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitQueryExpression(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::QueryExpressionContext* ExpressParser::queryExpression() {
  QueryExpressionContext *_localctx = _tracker.createInstance<QueryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 264, ExpressParser::RuleQueryExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1177);
    match(ExpressParser::QUERY);
    setState(1178);
    match(ExpressParser::T__1);
    setState(1179);
    variableId();
    setState(1180);
    match(ExpressParser::T__21);
    setState(1181);
    aggregateSource();
    setState(1182);
    match(ExpressParser::T__22);
    setState(1183);
    logicalExpression();
    setState(1184);
    match(ExpressParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RealTypeContext ------------------------------------------------------------------

ExpressParser::RealTypeContext::RealTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::RealTypeContext::REAL() {
  return getToken(ExpressParser::REAL, 0);
}

ExpressParser::PrecisionSpecContext* ExpressParser::RealTypeContext::precisionSpec() {
  return getRuleContext<ExpressParser::PrecisionSpecContext>(0);
}


size_t ExpressParser::RealTypeContext::getRuleIndex() const {
  return ExpressParser::RuleRealType;
}

void ExpressParser::RealTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRealType(this);
}

void ExpressParser::RealTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRealType(this);
}


std::any ExpressParser::RealTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitRealType(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::RealTypeContext* ExpressParser::realType() {
  RealTypeContext *_localctx = _tracker.createInstance<RealTypeContext>(_ctx, getState());
  enterRule(_localctx, 266, ExpressParser::RuleRealType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1186);
    match(ExpressParser::REAL);
    setState(1191);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::T__1) {
      setState(1187);
      match(ExpressParser::T__1);
      setState(1188);
      precisionSpec();
      setState(1189);
      match(ExpressParser::T__3);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RedeclaredAttributeContext ------------------------------------------------------------------

ExpressParser::RedeclaredAttributeContext::RedeclaredAttributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::QualifiedAttributeContext* ExpressParser::RedeclaredAttributeContext::qualifiedAttribute() {
  return getRuleContext<ExpressParser::QualifiedAttributeContext>(0);
}

tree::TerminalNode* ExpressParser::RedeclaredAttributeContext::RENAMED() {
  return getToken(ExpressParser::RENAMED, 0);
}

ExpressParser::AttributeIdContext* ExpressParser::RedeclaredAttributeContext::attributeId() {
  return getRuleContext<ExpressParser::AttributeIdContext>(0);
}


size_t ExpressParser::RedeclaredAttributeContext::getRuleIndex() const {
  return ExpressParser::RuleRedeclaredAttribute;
}

void ExpressParser::RedeclaredAttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRedeclaredAttribute(this);
}

void ExpressParser::RedeclaredAttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRedeclaredAttribute(this);
}


std::any ExpressParser::RedeclaredAttributeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitRedeclaredAttribute(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::RedeclaredAttributeContext* ExpressParser::redeclaredAttribute() {
  RedeclaredAttributeContext *_localctx = _tracker.createInstance<RedeclaredAttributeContext>(_ctx, getState());
  enterRule(_localctx, 268, ExpressParser::RuleRedeclaredAttribute);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1193);
    qualifiedAttribute();
    setState(1196);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::RENAMED) {
      setState(1194);
      match(ExpressParser::RENAMED);
      setState(1195);
      attributeId();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReferencedAttributeContext ------------------------------------------------------------------

ExpressParser::ReferencedAttributeContext::ReferencedAttributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::AttributeRefContext* ExpressParser::ReferencedAttributeContext::attributeRef() {
  return getRuleContext<ExpressParser::AttributeRefContext>(0);
}

ExpressParser::QualifiedAttributeContext* ExpressParser::ReferencedAttributeContext::qualifiedAttribute() {
  return getRuleContext<ExpressParser::QualifiedAttributeContext>(0);
}


size_t ExpressParser::ReferencedAttributeContext::getRuleIndex() const {
  return ExpressParser::RuleReferencedAttribute;
}

void ExpressParser::ReferencedAttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReferencedAttribute(this);
}

void ExpressParser::ReferencedAttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReferencedAttribute(this);
}


std::any ExpressParser::ReferencedAttributeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitReferencedAttribute(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ReferencedAttributeContext* ExpressParser::referencedAttribute() {
  ReferencedAttributeContext *_localctx = _tracker.createInstance<ReferencedAttributeContext>(_ctx, getState());
  enterRule(_localctx, 270, ExpressParser::RuleReferencedAttribute);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1200);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExpressParser::SimpleId: {
        enterOuterAlt(_localctx, 1);
        setState(1198);
        attributeRef();
        break;
      }

      case ExpressParser::SELF: {
        enterOuterAlt(_localctx, 2);
        setState(1199);
        qualifiedAttribute();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReferenceClauseContext ------------------------------------------------------------------

ExpressParser::ReferenceClauseContext::ReferenceClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::ReferenceClauseContext::REFERENCE() {
  return getToken(ExpressParser::REFERENCE, 0);
}

tree::TerminalNode* ExpressParser::ReferenceClauseContext::FROM() {
  return getToken(ExpressParser::FROM, 0);
}

ExpressParser::SchemaRefContext* ExpressParser::ReferenceClauseContext::schemaRef() {
  return getRuleContext<ExpressParser::SchemaRefContext>(0);
}

std::vector<ExpressParser::ResourceOrRenameContext *> ExpressParser::ReferenceClauseContext::resourceOrRename() {
  return getRuleContexts<ExpressParser::ResourceOrRenameContext>();
}

ExpressParser::ResourceOrRenameContext* ExpressParser::ReferenceClauseContext::resourceOrRename(size_t i) {
  return getRuleContext<ExpressParser::ResourceOrRenameContext>(i);
}


size_t ExpressParser::ReferenceClauseContext::getRuleIndex() const {
  return ExpressParser::RuleReferenceClause;
}

void ExpressParser::ReferenceClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReferenceClause(this);
}

void ExpressParser::ReferenceClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReferenceClause(this);
}


std::any ExpressParser::ReferenceClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitReferenceClause(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ReferenceClauseContext* ExpressParser::referenceClause() {
  ReferenceClauseContext *_localctx = _tracker.createInstance<ReferenceClauseContext>(_ctx, getState());
  enterRule(_localctx, 272, ExpressParser::RuleReferenceClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1202);
    match(ExpressParser::REFERENCE);
    setState(1203);
    match(ExpressParser::FROM);
    setState(1204);
    schemaRef();
    setState(1216);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::T__1) {
      setState(1205);
      match(ExpressParser::T__1);
      setState(1206);
      resourceOrRename();
      setState(1211);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == ExpressParser::T__2) {
        setState(1207);
        match(ExpressParser::T__2);
        setState(1208);
        resourceOrRename();
        setState(1213);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1214);
      match(ExpressParser::T__3);
    }
    setState(1218);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelOpContext ------------------------------------------------------------------

ExpressParser::RelOpContext::RelOpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t ExpressParser::RelOpContext::getRuleIndex() const {
  return ExpressParser::RuleRelOp;
}

void ExpressParser::RelOpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelOp(this);
}

void ExpressParser::RelOpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelOp(this);
}


std::any ExpressParser::RelOpContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitRelOp(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::RelOpContext* ExpressParser::relOp() {
  RelOpContext *_localctx = _tracker.createInstance<RelOpContext>(_ctx, getState());
  enterRule(_localctx, 274, ExpressParser::RuleRelOp);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1220);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << ExpressParser::T__16)
      | (1ULL << ExpressParser::T__17)
      | (1ULL << ExpressParser::T__23)
      | (1ULL << ExpressParser::T__24)
      | (1ULL << ExpressParser::T__25)
      | (1ULL << ExpressParser::T__26)
      | (1ULL << ExpressParser::T__27)
      | (1ULL << ExpressParser::T__28))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelOpExtendedContext ------------------------------------------------------------------

ExpressParser::RelOpExtendedContext::RelOpExtendedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::RelOpContext* ExpressParser::RelOpExtendedContext::relOp() {
  return getRuleContext<ExpressParser::RelOpContext>(0);
}

tree::TerminalNode* ExpressParser::RelOpExtendedContext::IN() {
  return getToken(ExpressParser::IN, 0);
}

tree::TerminalNode* ExpressParser::RelOpExtendedContext::LIKE() {
  return getToken(ExpressParser::LIKE, 0);
}


size_t ExpressParser::RelOpExtendedContext::getRuleIndex() const {
  return ExpressParser::RuleRelOpExtended;
}

void ExpressParser::RelOpExtendedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelOpExtended(this);
}

void ExpressParser::RelOpExtendedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelOpExtended(this);
}


std::any ExpressParser::RelOpExtendedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitRelOpExtended(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::RelOpExtendedContext* ExpressParser::relOpExtended() {
  RelOpExtendedContext *_localctx = _tracker.createInstance<RelOpExtendedContext>(_ctx, getState());
  enterRule(_localctx, 276, ExpressParser::RuleRelOpExtended);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1225);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExpressParser::T__16:
      case ExpressParser::T__17:
      case ExpressParser::T__23:
      case ExpressParser::T__24:
      case ExpressParser::T__25:
      case ExpressParser::T__26:
      case ExpressParser::T__27:
      case ExpressParser::T__28: {
        enterOuterAlt(_localctx, 1);
        setState(1222);
        relOp();
        break;
      }

      case ExpressParser::IN: {
        enterOuterAlt(_localctx, 2);
        setState(1223);
        match(ExpressParser::IN);
        break;
      }

      case ExpressParser::LIKE: {
        enterOuterAlt(_localctx, 3);
        setState(1224);
        match(ExpressParser::LIKE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RenameIdContext ------------------------------------------------------------------

ExpressParser::RenameIdContext::RenameIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::ConstantIdContext* ExpressParser::RenameIdContext::constantId() {
  return getRuleContext<ExpressParser::ConstantIdContext>(0);
}

ExpressParser::EntityIdContext* ExpressParser::RenameIdContext::entityId() {
  return getRuleContext<ExpressParser::EntityIdContext>(0);
}

ExpressParser::FunctionIdContext* ExpressParser::RenameIdContext::functionId() {
  return getRuleContext<ExpressParser::FunctionIdContext>(0);
}

ExpressParser::ProcedureIdContext* ExpressParser::RenameIdContext::procedureId() {
  return getRuleContext<ExpressParser::ProcedureIdContext>(0);
}

ExpressParser::TypeIdContext* ExpressParser::RenameIdContext::typeId() {
  return getRuleContext<ExpressParser::TypeIdContext>(0);
}


size_t ExpressParser::RenameIdContext::getRuleIndex() const {
  return ExpressParser::RuleRenameId;
}

void ExpressParser::RenameIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRenameId(this);
}

void ExpressParser::RenameIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRenameId(this);
}


std::any ExpressParser::RenameIdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitRenameId(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::RenameIdContext* ExpressParser::renameId() {
  RenameIdContext *_localctx = _tracker.createInstance<RenameIdContext>(_ctx, getState());
  enterRule(_localctx, 278, ExpressParser::RuleRenameId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1232);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1227);
      constantId();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1228);
      entityId();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1229);
      functionId();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1230);
      procedureId();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1231);
      typeId();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RepeatControlContext ------------------------------------------------------------------

ExpressParser::RepeatControlContext::RepeatControlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::IncrementControlContext* ExpressParser::RepeatControlContext::incrementControl() {
  return getRuleContext<ExpressParser::IncrementControlContext>(0);
}

ExpressParser::WhileControlContext* ExpressParser::RepeatControlContext::whileControl() {
  return getRuleContext<ExpressParser::WhileControlContext>(0);
}

ExpressParser::UntilControlContext* ExpressParser::RepeatControlContext::untilControl() {
  return getRuleContext<ExpressParser::UntilControlContext>(0);
}


size_t ExpressParser::RepeatControlContext::getRuleIndex() const {
  return ExpressParser::RuleRepeatControl;
}

void ExpressParser::RepeatControlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRepeatControl(this);
}

void ExpressParser::RepeatControlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRepeatControl(this);
}


std::any ExpressParser::RepeatControlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitRepeatControl(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::RepeatControlContext* ExpressParser::repeatControl() {
  RepeatControlContext *_localctx = _tracker.createInstance<RepeatControlContext>(_ctx, getState());
  enterRule(_localctx, 280, ExpressParser::RuleRepeatControl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1235);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::SimpleId) {
      setState(1234);
      incrementControl();
    }
    setState(1238);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::WHILE) {
      setState(1237);
      whileControl();
    }
    setState(1241);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::UNTIL) {
      setState(1240);
      untilControl();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RepeatStmtContext ------------------------------------------------------------------

ExpressParser::RepeatStmtContext::RepeatStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::RepeatStmtContext::REPEAT() {
  return getToken(ExpressParser::REPEAT, 0);
}

ExpressParser::RepeatControlContext* ExpressParser::RepeatStmtContext::repeatControl() {
  return getRuleContext<ExpressParser::RepeatControlContext>(0);
}

std::vector<ExpressParser::StmtContext *> ExpressParser::RepeatStmtContext::stmt() {
  return getRuleContexts<ExpressParser::StmtContext>();
}

ExpressParser::StmtContext* ExpressParser::RepeatStmtContext::stmt(size_t i) {
  return getRuleContext<ExpressParser::StmtContext>(i);
}

tree::TerminalNode* ExpressParser::RepeatStmtContext::END_REPEAT() {
  return getToken(ExpressParser::END_REPEAT, 0);
}


size_t ExpressParser::RepeatStmtContext::getRuleIndex() const {
  return ExpressParser::RuleRepeatStmt;
}

void ExpressParser::RepeatStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRepeatStmt(this);
}

void ExpressParser::RepeatStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRepeatStmt(this);
}


std::any ExpressParser::RepeatStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitRepeatStmt(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::RepeatStmtContext* ExpressParser::repeatStmt() {
  RepeatStmtContext *_localctx = _tracker.createInstance<RepeatStmtContext>(_ctx, getState());
  enterRule(_localctx, 282, ExpressParser::RuleRepeatStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1243);
    match(ExpressParser::REPEAT);
    setState(1244);
    repeatControl();
    setState(1245);
    match(ExpressParser::T__0);
    setState(1246);
    stmt();
    setState(1250);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << ExpressParser::T__0)
      | (1ULL << ExpressParser::ALIAS)
      | (1ULL << ExpressParser::BEGIN_)
      | (1ULL << ExpressParser::CASE))) != 0) || ((((_la - 71) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 71)) & ((1ULL << (ExpressParser::ESCAPE - 71))
      | (1ULL << (ExpressParser::IF - 71))
      | (1ULL << (ExpressParser::INSERT - 71))
      | (1ULL << (ExpressParser::REMOVE - 71))
      | (1ULL << (ExpressParser::REPEAT - 71))
      | (1ULL << (ExpressParser::RETURN - 71))
      | (1ULL << (ExpressParser::SKIP_ - 71)))) != 0) || _la == ExpressParser::SimpleId) {
      setState(1247);
      stmt();
      setState(1252);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1253);
    match(ExpressParser::END_REPEAT);
    setState(1254);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RepetitionContext ------------------------------------------------------------------

ExpressParser::RepetitionContext::RepetitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::NumericExpressionContext* ExpressParser::RepetitionContext::numericExpression() {
  return getRuleContext<ExpressParser::NumericExpressionContext>(0);
}


size_t ExpressParser::RepetitionContext::getRuleIndex() const {
  return ExpressParser::RuleRepetition;
}

void ExpressParser::RepetitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRepetition(this);
}

void ExpressParser::RepetitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRepetition(this);
}


std::any ExpressParser::RepetitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitRepetition(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::RepetitionContext* ExpressParser::repetition() {
  RepetitionContext *_localctx = _tracker.createInstance<RepetitionContext>(_ctx, getState());
  enterRule(_localctx, 284, ExpressParser::RuleRepetition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1256);
    numericExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResourceOrRenameContext ------------------------------------------------------------------

ExpressParser::ResourceOrRenameContext::ResourceOrRenameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::ResourceRefContext* ExpressParser::ResourceOrRenameContext::resourceRef() {
  return getRuleContext<ExpressParser::ResourceRefContext>(0);
}

tree::TerminalNode* ExpressParser::ResourceOrRenameContext::AS() {
  return getToken(ExpressParser::AS, 0);
}

ExpressParser::RenameIdContext* ExpressParser::ResourceOrRenameContext::renameId() {
  return getRuleContext<ExpressParser::RenameIdContext>(0);
}


size_t ExpressParser::ResourceOrRenameContext::getRuleIndex() const {
  return ExpressParser::RuleResourceOrRename;
}

void ExpressParser::ResourceOrRenameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResourceOrRename(this);
}

void ExpressParser::ResourceOrRenameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResourceOrRename(this);
}


std::any ExpressParser::ResourceOrRenameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitResourceOrRename(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ResourceOrRenameContext* ExpressParser::resourceOrRename() {
  ResourceOrRenameContext *_localctx = _tracker.createInstance<ResourceOrRenameContext>(_ctx, getState());
  enterRule(_localctx, 286, ExpressParser::RuleResourceOrRename);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1258);
    resourceRef();
    setState(1261);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::AS) {
      setState(1259);
      match(ExpressParser::AS);
      setState(1260);
      renameId();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResourceRefContext ------------------------------------------------------------------

ExpressParser::ResourceRefContext::ResourceRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::ConstantRefContext* ExpressParser::ResourceRefContext::constantRef() {
  return getRuleContext<ExpressParser::ConstantRefContext>(0);
}

ExpressParser::EntityRefContext* ExpressParser::ResourceRefContext::entityRef() {
  return getRuleContext<ExpressParser::EntityRefContext>(0);
}

ExpressParser::FunctionRefContext* ExpressParser::ResourceRefContext::functionRef() {
  return getRuleContext<ExpressParser::FunctionRefContext>(0);
}

ExpressParser::ProcedureRefContext* ExpressParser::ResourceRefContext::procedureRef() {
  return getRuleContext<ExpressParser::ProcedureRefContext>(0);
}

ExpressParser::TypeRefContext* ExpressParser::ResourceRefContext::typeRef() {
  return getRuleContext<ExpressParser::TypeRefContext>(0);
}


size_t ExpressParser::ResourceRefContext::getRuleIndex() const {
  return ExpressParser::RuleResourceRef;
}

void ExpressParser::ResourceRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResourceRef(this);
}

void ExpressParser::ResourceRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResourceRef(this);
}


std::any ExpressParser::ResourceRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitResourceRef(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ResourceRefContext* ExpressParser::resourceRef() {
  ResourceRefContext *_localctx = _tracker.createInstance<ResourceRefContext>(_ctx, getState());
  enterRule(_localctx, 288, ExpressParser::RuleResourceRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1268);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1263);
      constantRef();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1264);
      entityRef();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1265);
      functionRef();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1266);
      procedureRef();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1267);
      typeRef();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnStmtContext ------------------------------------------------------------------

ExpressParser::ReturnStmtContext::ReturnStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::ReturnStmtContext::RETURN() {
  return getToken(ExpressParser::RETURN, 0);
}

ExpressParser::ExpressionContext* ExpressParser::ReturnStmtContext::expression() {
  return getRuleContext<ExpressParser::ExpressionContext>(0);
}


size_t ExpressParser::ReturnStmtContext::getRuleIndex() const {
  return ExpressParser::RuleReturnStmt;
}

void ExpressParser::ReturnStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturnStmt(this);
}

void ExpressParser::ReturnStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturnStmt(this);
}


std::any ExpressParser::ReturnStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitReturnStmt(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::ReturnStmtContext* ExpressParser::returnStmt() {
  ReturnStmtContext *_localctx = _tracker.createInstance<ReturnStmtContext>(_ctx, getState());
  enterRule(_localctx, 290, ExpressParser::RuleReturnStmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1270);
    match(ExpressParser::RETURN);
    setState(1275);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::T__1) {
      setState(1271);
      match(ExpressParser::T__1);
      setState(1272);
      expression();
      setState(1273);
      match(ExpressParser::T__3);
    }
    setState(1277);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RuleDeclContext ------------------------------------------------------------------

ExpressParser::RuleDeclContext::RuleDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::RuleHeadContext* ExpressParser::RuleDeclContext::ruleHead() {
  return getRuleContext<ExpressParser::RuleHeadContext>(0);
}

ExpressParser::AlgorithmHeadContext* ExpressParser::RuleDeclContext::algorithmHead() {
  return getRuleContext<ExpressParser::AlgorithmHeadContext>(0);
}

ExpressParser::WhereClauseContext* ExpressParser::RuleDeclContext::whereClause() {
  return getRuleContext<ExpressParser::WhereClauseContext>(0);
}

tree::TerminalNode* ExpressParser::RuleDeclContext::END_RULE() {
  return getToken(ExpressParser::END_RULE, 0);
}

std::vector<ExpressParser::StmtContext *> ExpressParser::RuleDeclContext::stmt() {
  return getRuleContexts<ExpressParser::StmtContext>();
}

ExpressParser::StmtContext* ExpressParser::RuleDeclContext::stmt(size_t i) {
  return getRuleContext<ExpressParser::StmtContext>(i);
}


size_t ExpressParser::RuleDeclContext::getRuleIndex() const {
  return ExpressParser::RuleRuleDecl;
}

void ExpressParser::RuleDeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRuleDecl(this);
}

void ExpressParser::RuleDeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRuleDecl(this);
}


std::any ExpressParser::RuleDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitRuleDecl(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::RuleDeclContext* ExpressParser::ruleDecl() {
  RuleDeclContext *_localctx = _tracker.createInstance<RuleDeclContext>(_ctx, getState());
  enterRule(_localctx, 292, ExpressParser::RuleRuleDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1279);
    ruleHead();
    setState(1280);
    algorithmHead();
    setState(1284);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << ExpressParser::T__0)
      | (1ULL << ExpressParser::ALIAS)
      | (1ULL << ExpressParser::BEGIN_)
      | (1ULL << ExpressParser::CASE))) != 0) || ((((_la - 71) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 71)) & ((1ULL << (ExpressParser::ESCAPE - 71))
      | (1ULL << (ExpressParser::IF - 71))
      | (1ULL << (ExpressParser::INSERT - 71))
      | (1ULL << (ExpressParser::REMOVE - 71))
      | (1ULL << (ExpressParser::REPEAT - 71))
      | (1ULL << (ExpressParser::RETURN - 71))
      | (1ULL << (ExpressParser::SKIP_ - 71)))) != 0) || _la == ExpressParser::SimpleId) {
      setState(1281);
      stmt();
      setState(1286);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1287);
    whereClause();
    setState(1288);
    match(ExpressParser::END_RULE);
    setState(1289);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RuleHeadContext ------------------------------------------------------------------

ExpressParser::RuleHeadContext::RuleHeadContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::RuleHeadContext::RULE() {
  return getToken(ExpressParser::RULE, 0);
}

ExpressParser::RuleIdContext* ExpressParser::RuleHeadContext::ruleId() {
  return getRuleContext<ExpressParser::RuleIdContext>(0);
}

tree::TerminalNode* ExpressParser::RuleHeadContext::FOR() {
  return getToken(ExpressParser::FOR, 0);
}

std::vector<ExpressParser::EntityRefContext *> ExpressParser::RuleHeadContext::entityRef() {
  return getRuleContexts<ExpressParser::EntityRefContext>();
}

ExpressParser::EntityRefContext* ExpressParser::RuleHeadContext::entityRef(size_t i) {
  return getRuleContext<ExpressParser::EntityRefContext>(i);
}


size_t ExpressParser::RuleHeadContext::getRuleIndex() const {
  return ExpressParser::RuleRuleHead;
}

void ExpressParser::RuleHeadContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRuleHead(this);
}

void ExpressParser::RuleHeadContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRuleHead(this);
}


std::any ExpressParser::RuleHeadContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitRuleHead(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::RuleHeadContext* ExpressParser::ruleHead() {
  RuleHeadContext *_localctx = _tracker.createInstance<RuleHeadContext>(_ctx, getState());
  enterRule(_localctx, 294, ExpressParser::RuleRuleHead);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1291);
    match(ExpressParser::RULE);
    setState(1292);
    ruleId();
    setState(1293);
    match(ExpressParser::FOR);
    setState(1294);
    match(ExpressParser::T__1);
    setState(1295);
    entityRef();
    setState(1300);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExpressParser::T__2) {
      setState(1296);
      match(ExpressParser::T__2);
      setState(1297);
      entityRef();
      setState(1302);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1303);
    match(ExpressParser::T__3);
    setState(1304);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RuleIdContext ------------------------------------------------------------------

ExpressParser::RuleIdContext::RuleIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::RuleIdContext::SimpleId() {
  return getToken(ExpressParser::SimpleId, 0);
}


size_t ExpressParser::RuleIdContext::getRuleIndex() const {
  return ExpressParser::RuleRuleId;
}

void ExpressParser::RuleIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRuleId(this);
}

void ExpressParser::RuleIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRuleId(this);
}


std::any ExpressParser::RuleIdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitRuleId(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::RuleIdContext* ExpressParser::ruleId() {
  RuleIdContext *_localctx = _tracker.createInstance<RuleIdContext>(_ctx, getState());
  enterRule(_localctx, 296, ExpressParser::RuleRuleId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1306);
    match(ExpressParser::SimpleId);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RuleLabelIdContext ------------------------------------------------------------------

ExpressParser::RuleLabelIdContext::RuleLabelIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::RuleLabelIdContext::SimpleId() {
  return getToken(ExpressParser::SimpleId, 0);
}


size_t ExpressParser::RuleLabelIdContext::getRuleIndex() const {
  return ExpressParser::RuleRuleLabelId;
}

void ExpressParser::RuleLabelIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRuleLabelId(this);
}

void ExpressParser::RuleLabelIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRuleLabelId(this);
}


std::any ExpressParser::RuleLabelIdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitRuleLabelId(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::RuleLabelIdContext* ExpressParser::ruleLabelId() {
  RuleLabelIdContext *_localctx = _tracker.createInstance<RuleLabelIdContext>(_ctx, getState());
  enterRule(_localctx, 298, ExpressParser::RuleRuleLabelId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1308);
    match(ExpressParser::SimpleId);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SchemaBodyContext ------------------------------------------------------------------

ExpressParser::SchemaBodyContext::SchemaBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExpressParser::InterfaceSpecificationContext *> ExpressParser::SchemaBodyContext::interfaceSpecification() {
  return getRuleContexts<ExpressParser::InterfaceSpecificationContext>();
}

ExpressParser::InterfaceSpecificationContext* ExpressParser::SchemaBodyContext::interfaceSpecification(size_t i) {
  return getRuleContext<ExpressParser::InterfaceSpecificationContext>(i);
}

ExpressParser::ConstantDeclContext* ExpressParser::SchemaBodyContext::constantDecl() {
  return getRuleContext<ExpressParser::ConstantDeclContext>(0);
}

std::vector<ExpressParser::SchemaBodyDeclarationContext *> ExpressParser::SchemaBodyContext::schemaBodyDeclaration() {
  return getRuleContexts<ExpressParser::SchemaBodyDeclarationContext>();
}

ExpressParser::SchemaBodyDeclarationContext* ExpressParser::SchemaBodyContext::schemaBodyDeclaration(size_t i) {
  return getRuleContext<ExpressParser::SchemaBodyDeclarationContext>(i);
}


size_t ExpressParser::SchemaBodyContext::getRuleIndex() const {
  return ExpressParser::RuleSchemaBody;
}

void ExpressParser::SchemaBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchemaBody(this);
}

void ExpressParser::SchemaBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchemaBody(this);
}


std::any ExpressParser::SchemaBodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSchemaBody(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SchemaBodyContext* ExpressParser::schemaBody() {
  SchemaBodyContext *_localctx = _tracker.createInstance<SchemaBodyContext>(_ctx, getState());
  enterRule(_localctx, 300, ExpressParser::RuleSchemaBody);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1313);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExpressParser::REFERENCE

    || _la == ExpressParser::USE) {
      setState(1310);
      interfaceSpecification();
      setState(1315);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1317);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::CONSTANT) {
      setState(1316);
      constantDecl();
    }
    setState(1322);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 69) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 69)) & ((1ULL << (ExpressParser::ENTITY - 69))
      | (1ULL << (ExpressParser::FUNCTION - 69))
      | (1ULL << (ExpressParser::PROCEDURE - 69))
      | (1ULL << (ExpressParser::RULE - 69))
      | (1ULL << (ExpressParser::SUBTYPE_CONSTRAINT - 69)))) != 0) || _la == ExpressParser::TYPE) {
      setState(1319);
      schemaBodyDeclaration();
      setState(1324);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SchemaBodyDeclarationContext ------------------------------------------------------------------

ExpressParser::SchemaBodyDeclarationContext::SchemaBodyDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::DeclarationContext* ExpressParser::SchemaBodyDeclarationContext::declaration() {
  return getRuleContext<ExpressParser::DeclarationContext>(0);
}

ExpressParser::RuleDeclContext* ExpressParser::SchemaBodyDeclarationContext::ruleDecl() {
  return getRuleContext<ExpressParser::RuleDeclContext>(0);
}


size_t ExpressParser::SchemaBodyDeclarationContext::getRuleIndex() const {
  return ExpressParser::RuleSchemaBodyDeclaration;
}

void ExpressParser::SchemaBodyDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchemaBodyDeclaration(this);
}

void ExpressParser::SchemaBodyDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchemaBodyDeclaration(this);
}


std::any ExpressParser::SchemaBodyDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSchemaBodyDeclaration(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SchemaBodyDeclarationContext* ExpressParser::schemaBodyDeclaration() {
  SchemaBodyDeclarationContext *_localctx = _tracker.createInstance<SchemaBodyDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 302, ExpressParser::RuleSchemaBodyDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1327);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExpressParser::ENTITY:
      case ExpressParser::FUNCTION:
      case ExpressParser::PROCEDURE:
      case ExpressParser::SUBTYPE_CONSTRAINT:
      case ExpressParser::TYPE: {
        enterOuterAlt(_localctx, 1);
        setState(1325);
        declaration();
        break;
      }

      case ExpressParser::RULE: {
        enterOuterAlt(_localctx, 2);
        setState(1326);
        ruleDecl();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SchemaDeclContext ------------------------------------------------------------------

ExpressParser::SchemaDeclContext::SchemaDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::SchemaDeclContext::SCHEMA() {
  return getToken(ExpressParser::SCHEMA, 0);
}

ExpressParser::SchemaIdContext* ExpressParser::SchemaDeclContext::schemaId() {
  return getRuleContext<ExpressParser::SchemaIdContext>(0);
}

ExpressParser::SchemaBodyContext* ExpressParser::SchemaDeclContext::schemaBody() {
  return getRuleContext<ExpressParser::SchemaBodyContext>(0);
}

tree::TerminalNode* ExpressParser::SchemaDeclContext::END_SCHEMA() {
  return getToken(ExpressParser::END_SCHEMA, 0);
}

ExpressParser::SchemaVersionIdContext* ExpressParser::SchemaDeclContext::schemaVersionId() {
  return getRuleContext<ExpressParser::SchemaVersionIdContext>(0);
}


size_t ExpressParser::SchemaDeclContext::getRuleIndex() const {
  return ExpressParser::RuleSchemaDecl;
}

void ExpressParser::SchemaDeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchemaDecl(this);
}

void ExpressParser::SchemaDeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchemaDecl(this);
}


std::any ExpressParser::SchemaDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSchemaDecl(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SchemaDeclContext* ExpressParser::schemaDecl() {
  SchemaDeclContext *_localctx = _tracker.createInstance<SchemaDeclContext>(_ctx, getState());
  enterRule(_localctx, 304, ExpressParser::RuleSchemaDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1329);
    match(ExpressParser::SCHEMA);
    setState(1330);
    schemaId();
    setState(1332);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::EncodedStringLiteral

    || _la == ExpressParser::SimpleStringLiteral) {
      setState(1331);
      schemaVersionId();
    }
    setState(1334);
    match(ExpressParser::T__0);
    setState(1335);
    schemaBody();
    setState(1336);
    match(ExpressParser::END_SCHEMA);
    setState(1337);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SchemaIdContext ------------------------------------------------------------------

ExpressParser::SchemaIdContext::SchemaIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::SchemaIdContext::SimpleId() {
  return getToken(ExpressParser::SimpleId, 0);
}


size_t ExpressParser::SchemaIdContext::getRuleIndex() const {
  return ExpressParser::RuleSchemaId;
}

void ExpressParser::SchemaIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchemaId(this);
}

void ExpressParser::SchemaIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchemaId(this);
}


std::any ExpressParser::SchemaIdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSchemaId(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SchemaIdContext* ExpressParser::schemaId() {
  SchemaIdContext *_localctx = _tracker.createInstance<SchemaIdContext>(_ctx, getState());
  enterRule(_localctx, 306, ExpressParser::RuleSchemaId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1339);
    match(ExpressParser::SimpleId);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SchemaVersionIdContext ------------------------------------------------------------------

ExpressParser::SchemaVersionIdContext::SchemaVersionIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::StringLiteralContext* ExpressParser::SchemaVersionIdContext::stringLiteral() {
  return getRuleContext<ExpressParser::StringLiteralContext>(0);
}


size_t ExpressParser::SchemaVersionIdContext::getRuleIndex() const {
  return ExpressParser::RuleSchemaVersionId;
}

void ExpressParser::SchemaVersionIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchemaVersionId(this);
}

void ExpressParser::SchemaVersionIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchemaVersionId(this);
}


std::any ExpressParser::SchemaVersionIdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSchemaVersionId(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SchemaVersionIdContext* ExpressParser::schemaVersionId() {
  SchemaVersionIdContext *_localctx = _tracker.createInstance<SchemaVersionIdContext>(_ctx, getState());
  enterRule(_localctx, 308, ExpressParser::RuleSchemaVersionId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1341);
    stringLiteral();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectorContext ------------------------------------------------------------------

ExpressParser::SelectorContext::SelectorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::ExpressionContext* ExpressParser::SelectorContext::expression() {
  return getRuleContext<ExpressParser::ExpressionContext>(0);
}


size_t ExpressParser::SelectorContext::getRuleIndex() const {
  return ExpressParser::RuleSelector;
}

void ExpressParser::SelectorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelector(this);
}

void ExpressParser::SelectorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelector(this);
}


std::any ExpressParser::SelectorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSelector(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SelectorContext* ExpressParser::selector() {
  SelectorContext *_localctx = _tracker.createInstance<SelectorContext>(_ctx, getState());
  enterRule(_localctx, 310, ExpressParser::RuleSelector);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1343);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectExtensionContext ------------------------------------------------------------------

ExpressParser::SelectExtensionContext::SelectExtensionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::SelectExtensionContext::BASED_ON() {
  return getToken(ExpressParser::BASED_ON, 0);
}

ExpressParser::TypeRefContext* ExpressParser::SelectExtensionContext::typeRef() {
  return getRuleContext<ExpressParser::TypeRefContext>(0);
}

tree::TerminalNode* ExpressParser::SelectExtensionContext::WITH() {
  return getToken(ExpressParser::WITH, 0);
}

ExpressParser::SelectListContext* ExpressParser::SelectExtensionContext::selectList() {
  return getRuleContext<ExpressParser::SelectListContext>(0);
}


size_t ExpressParser::SelectExtensionContext::getRuleIndex() const {
  return ExpressParser::RuleSelectExtension;
}

void ExpressParser::SelectExtensionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectExtension(this);
}

void ExpressParser::SelectExtensionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectExtension(this);
}


std::any ExpressParser::SelectExtensionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSelectExtension(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SelectExtensionContext* ExpressParser::selectExtension() {
  SelectExtensionContext *_localctx = _tracker.createInstance<SelectExtensionContext>(_ctx, getState());
  enterRule(_localctx, 312, ExpressParser::RuleSelectExtension);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1345);
    match(ExpressParser::BASED_ON);
    setState(1346);
    typeRef();
    setState(1349);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::WITH) {
      setState(1347);
      match(ExpressParser::WITH);
      setState(1348);
      selectList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectListContext ------------------------------------------------------------------

ExpressParser::SelectListContext::SelectListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExpressParser::NamedTypesContext *> ExpressParser::SelectListContext::namedTypes() {
  return getRuleContexts<ExpressParser::NamedTypesContext>();
}

ExpressParser::NamedTypesContext* ExpressParser::SelectListContext::namedTypes(size_t i) {
  return getRuleContext<ExpressParser::NamedTypesContext>(i);
}


size_t ExpressParser::SelectListContext::getRuleIndex() const {
  return ExpressParser::RuleSelectList;
}

void ExpressParser::SelectListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectList(this);
}

void ExpressParser::SelectListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectList(this);
}


std::any ExpressParser::SelectListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSelectList(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SelectListContext* ExpressParser::selectList() {
  SelectListContext *_localctx = _tracker.createInstance<SelectListContext>(_ctx, getState());
  enterRule(_localctx, 314, ExpressParser::RuleSelectList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1351);
    match(ExpressParser::T__1);
    setState(1352);
    namedTypes();
    setState(1357);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExpressParser::T__2) {
      setState(1353);
      match(ExpressParser::T__2);
      setState(1354);
      namedTypes();
      setState(1359);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1360);
    match(ExpressParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectTypeContext ------------------------------------------------------------------

ExpressParser::SelectTypeContext::SelectTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::SelectTypeContext::SELECT() {
  return getToken(ExpressParser::SELECT, 0);
}

tree::TerminalNode* ExpressParser::SelectTypeContext::EXTENSIBLE() {
  return getToken(ExpressParser::EXTENSIBLE, 0);
}

ExpressParser::SelectListContext* ExpressParser::SelectTypeContext::selectList() {
  return getRuleContext<ExpressParser::SelectListContext>(0);
}

ExpressParser::SelectExtensionContext* ExpressParser::SelectTypeContext::selectExtension() {
  return getRuleContext<ExpressParser::SelectExtensionContext>(0);
}

tree::TerminalNode* ExpressParser::SelectTypeContext::GENERIC_ENTITY() {
  return getToken(ExpressParser::GENERIC_ENTITY, 0);
}


size_t ExpressParser::SelectTypeContext::getRuleIndex() const {
  return ExpressParser::RuleSelectType;
}

void ExpressParser::SelectTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectType(this);
}

void ExpressParser::SelectTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectType(this);
}


std::any ExpressParser::SelectTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSelectType(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SelectTypeContext* ExpressParser::selectType() {
  SelectTypeContext *_localctx = _tracker.createInstance<SelectTypeContext>(_ctx, getState());
  enterRule(_localctx, 316, ExpressParser::RuleSelectType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1366);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::EXTENSIBLE) {
      setState(1362);
      match(ExpressParser::EXTENSIBLE);
      setState(1364);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ExpressParser::GENERIC_ENTITY) {
        setState(1363);
        match(ExpressParser::GENERIC_ENTITY);
      }
    }
    setState(1368);
    match(ExpressParser::SELECT);
    setState(1371);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExpressParser::T__1: {
        setState(1369);
        selectList();
        break;
      }

      case ExpressParser::BASED_ON: {
        setState(1370);
        selectExtension();
        break;
      }

      case ExpressParser::T__0: {
        break;
      }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetTypeContext ------------------------------------------------------------------

ExpressParser::SetTypeContext::SetTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::SetTypeContext::SET() {
  return getToken(ExpressParser::SET, 0);
}

tree::TerminalNode* ExpressParser::SetTypeContext::OF() {
  return getToken(ExpressParser::OF, 0);
}

ExpressParser::InstantiableTypeContext* ExpressParser::SetTypeContext::instantiableType() {
  return getRuleContext<ExpressParser::InstantiableTypeContext>(0);
}

ExpressParser::BoundSpecContext* ExpressParser::SetTypeContext::boundSpec() {
  return getRuleContext<ExpressParser::BoundSpecContext>(0);
}


size_t ExpressParser::SetTypeContext::getRuleIndex() const {
  return ExpressParser::RuleSetType;
}

void ExpressParser::SetTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetType(this);
}

void ExpressParser::SetTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetType(this);
}


std::any ExpressParser::SetTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSetType(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SetTypeContext* ExpressParser::setType() {
  SetTypeContext *_localctx = _tracker.createInstance<SetTypeContext>(_ctx, getState());
  enterRule(_localctx, 318, ExpressParser::RuleSetType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1373);
    match(ExpressParser::SET);
    setState(1375);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::T__6) {
      setState(1374);
      boundSpec();
    }
    setState(1377);
    match(ExpressParser::OF);
    setState(1378);
    instantiableType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleExpressionContext ------------------------------------------------------------------

ExpressParser::SimpleExpressionContext::SimpleExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExpressParser::TermContext *> ExpressParser::SimpleExpressionContext::term() {
  return getRuleContexts<ExpressParser::TermContext>();
}

ExpressParser::TermContext* ExpressParser::SimpleExpressionContext::term(size_t i) {
  return getRuleContext<ExpressParser::TermContext>(i);
}

std::vector<ExpressParser::AddLikeOpContext *> ExpressParser::SimpleExpressionContext::addLikeOp() {
  return getRuleContexts<ExpressParser::AddLikeOpContext>();
}

ExpressParser::AddLikeOpContext* ExpressParser::SimpleExpressionContext::addLikeOp(size_t i) {
  return getRuleContext<ExpressParser::AddLikeOpContext>(i);
}


size_t ExpressParser::SimpleExpressionContext::getRuleIndex() const {
  return ExpressParser::RuleSimpleExpression;
}

void ExpressParser::SimpleExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExpression(this);
}

void ExpressParser::SimpleExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExpression(this);
}


std::any ExpressParser::SimpleExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSimpleExpression(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SimpleExpressionContext* ExpressParser::simpleExpression() {
  SimpleExpressionContext *_localctx = _tracker.createInstance<SimpleExpressionContext>(_ctx, getState());
  enterRule(_localctx, 320, ExpressParser::RuleSimpleExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1380);
    term();
    setState(1386);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExpressParser::T__4

    || _la == ExpressParser::T__5 || _la == ExpressParser::OR

    || _la == ExpressParser::XOR) {
      setState(1381);
      addLikeOp();
      setState(1382);
      term();
      setState(1388);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleFactorContext ------------------------------------------------------------------

ExpressParser::SimpleFactorContext::SimpleFactorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::AggregateInitializerContext* ExpressParser::SimpleFactorContext::aggregateInitializer() {
  return getRuleContext<ExpressParser::AggregateInitializerContext>(0);
}

ExpressParser::EntityConstructorContext* ExpressParser::SimpleFactorContext::entityConstructor() {
  return getRuleContext<ExpressParser::EntityConstructorContext>(0);
}

ExpressParser::EnumerationReferenceContext* ExpressParser::SimpleFactorContext::enumerationReference() {
  return getRuleContext<ExpressParser::EnumerationReferenceContext>(0);
}

ExpressParser::IntervalContext* ExpressParser::SimpleFactorContext::interval() {
  return getRuleContext<ExpressParser::IntervalContext>(0);
}

ExpressParser::QueryExpressionContext* ExpressParser::SimpleFactorContext::queryExpression() {
  return getRuleContext<ExpressParser::QueryExpressionContext>(0);
}

ExpressParser::SimpleFactorExpressionContext* ExpressParser::SimpleFactorContext::simpleFactorExpression() {
  return getRuleContext<ExpressParser::SimpleFactorExpressionContext>(0);
}

ExpressParser::SimpleFactorUnaryExpressionContext* ExpressParser::SimpleFactorContext::simpleFactorUnaryExpression() {
  return getRuleContext<ExpressParser::SimpleFactorUnaryExpressionContext>(0);
}


size_t ExpressParser::SimpleFactorContext::getRuleIndex() const {
  return ExpressParser::RuleSimpleFactor;
}

void ExpressParser::SimpleFactorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleFactor(this);
}

void ExpressParser::SimpleFactorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleFactor(this);
}


std::any ExpressParser::SimpleFactorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSimpleFactor(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SimpleFactorContext* ExpressParser::simpleFactor() {
  SimpleFactorContext *_localctx = _tracker.createInstance<SimpleFactorContext>(_ctx, getState());
  enterRule(_localctx, 322, ExpressParser::RuleSimpleFactor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1396);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 123, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1389);
      aggregateInitializer();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1390);
      entityConstructor();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1391);
      enumerationReference();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1392);
      interval();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1393);
      queryExpression();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1394);
      simpleFactorExpression();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1395);
      simpleFactorUnaryExpression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleFactorExpressionContext ------------------------------------------------------------------

ExpressParser::SimpleFactorExpressionContext::SimpleFactorExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::ExpressionContext* ExpressParser::SimpleFactorExpressionContext::expression() {
  return getRuleContext<ExpressParser::ExpressionContext>(0);
}

ExpressParser::PrimaryContext* ExpressParser::SimpleFactorExpressionContext::primary() {
  return getRuleContext<ExpressParser::PrimaryContext>(0);
}


size_t ExpressParser::SimpleFactorExpressionContext::getRuleIndex() const {
  return ExpressParser::RuleSimpleFactorExpression;
}

void ExpressParser::SimpleFactorExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleFactorExpression(this);
}

void ExpressParser::SimpleFactorExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleFactorExpression(this);
}


std::any ExpressParser::SimpleFactorExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSimpleFactorExpression(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SimpleFactorExpressionContext* ExpressParser::simpleFactorExpression() {
  SimpleFactorExpressionContext *_localctx = _tracker.createInstance<SimpleFactorExpressionContext>(_ctx, getState());
  enterRule(_localctx, 324, ExpressParser::RuleSimpleFactorExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1403);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExpressParser::T__1: {
        enterOuterAlt(_localctx, 1);
        setState(1398);
        match(ExpressParser::T__1);
        setState(1399);
        expression();
        setState(1400);
        match(ExpressParser::T__3);
        break;
      }

      case ExpressParser::T__11:
      case ExpressParser::ABS:
      case ExpressParser::ACOS:
      case ExpressParser::ASIN:
      case ExpressParser::ATAN:
      case ExpressParser::BLENGTH:
      case ExpressParser::CONST_E:
      case ExpressParser::COS:
      case ExpressParser::EXISTS:
      case ExpressParser::EXP:
      case ExpressParser::FALSE:
      case ExpressParser::FORMAT:
      case ExpressParser::HIBOUND:
      case ExpressParser::HIINDEX:
      case ExpressParser::LENGTH:
      case ExpressParser::LOBOUND:
      case ExpressParser::LOG:
      case ExpressParser::LOG10:
      case ExpressParser::LOG2:
      case ExpressParser::LOINDEX:
      case ExpressParser::NVL:
      case ExpressParser::ODD:
      case ExpressParser::PI:
      case ExpressParser::ROLESOF:
      case ExpressParser::SELF:
      case ExpressParser::SIN:
      case ExpressParser::SIZEOF:
      case ExpressParser::SQRT:
      case ExpressParser::TAN:
      case ExpressParser::TRUE:
      case ExpressParser::TYPEOF:
      case ExpressParser::UNKNOWN:
      case ExpressParser::USEDIN:
      case ExpressParser::VALUE_:
      case ExpressParser::VALUE_IN:
      case ExpressParser::VALUE_UNIQUE:
      case ExpressParser::BinaryLiteral:
      case ExpressParser::EncodedStringLiteral:
      case ExpressParser::IntegerLiteral:
      case ExpressParser::RealLiteral:
      case ExpressParser::SimpleId:
      case ExpressParser::SimpleStringLiteral: {
        enterOuterAlt(_localctx, 2);
        setState(1402);
        primary();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleFactorUnaryExpressionContext ------------------------------------------------------------------

ExpressParser::SimpleFactorUnaryExpressionContext::SimpleFactorUnaryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::UnaryOpContext* ExpressParser::SimpleFactorUnaryExpressionContext::unaryOp() {
  return getRuleContext<ExpressParser::UnaryOpContext>(0);
}

ExpressParser::SimpleFactorExpressionContext* ExpressParser::SimpleFactorUnaryExpressionContext::simpleFactorExpression() {
  return getRuleContext<ExpressParser::SimpleFactorExpressionContext>(0);
}


size_t ExpressParser::SimpleFactorUnaryExpressionContext::getRuleIndex() const {
  return ExpressParser::RuleSimpleFactorUnaryExpression;
}

void ExpressParser::SimpleFactorUnaryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleFactorUnaryExpression(this);
}

void ExpressParser::SimpleFactorUnaryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleFactorUnaryExpression(this);
}


std::any ExpressParser::SimpleFactorUnaryExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSimpleFactorUnaryExpression(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SimpleFactorUnaryExpressionContext* ExpressParser::simpleFactorUnaryExpression() {
  SimpleFactorUnaryExpressionContext *_localctx = _tracker.createInstance<SimpleFactorUnaryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 326, ExpressParser::RuleSimpleFactorUnaryExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1405);
    unaryOp();
    setState(1406);
    simpleFactorExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleTypesContext ------------------------------------------------------------------

ExpressParser::SimpleTypesContext::SimpleTypesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::BinaryTypeContext* ExpressParser::SimpleTypesContext::binaryType() {
  return getRuleContext<ExpressParser::BinaryTypeContext>(0);
}

ExpressParser::BooleanTypeContext* ExpressParser::SimpleTypesContext::booleanType() {
  return getRuleContext<ExpressParser::BooleanTypeContext>(0);
}

ExpressParser::IntegerTypeContext* ExpressParser::SimpleTypesContext::integerType() {
  return getRuleContext<ExpressParser::IntegerTypeContext>(0);
}

ExpressParser::LogicalTypeContext* ExpressParser::SimpleTypesContext::logicalType() {
  return getRuleContext<ExpressParser::LogicalTypeContext>(0);
}

ExpressParser::NumberTypeContext* ExpressParser::SimpleTypesContext::numberType() {
  return getRuleContext<ExpressParser::NumberTypeContext>(0);
}

ExpressParser::RealTypeContext* ExpressParser::SimpleTypesContext::realType() {
  return getRuleContext<ExpressParser::RealTypeContext>(0);
}

ExpressParser::StringTypeContext* ExpressParser::SimpleTypesContext::stringType() {
  return getRuleContext<ExpressParser::StringTypeContext>(0);
}


size_t ExpressParser::SimpleTypesContext::getRuleIndex() const {
  return ExpressParser::RuleSimpleTypes;
}

void ExpressParser::SimpleTypesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleTypes(this);
}

void ExpressParser::SimpleTypesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleTypes(this);
}


std::any ExpressParser::SimpleTypesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSimpleTypes(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SimpleTypesContext* ExpressParser::simpleTypes() {
  SimpleTypesContext *_localctx = _tracker.createInstance<SimpleTypesContext>(_ctx, getState());
  enterRule(_localctx, 328, ExpressParser::RuleSimpleTypes);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1415);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExpressParser::BINARY: {
        enterOuterAlt(_localctx, 1);
        setState(1408);
        binaryType();
        break;
      }

      case ExpressParser::BOOLEAN: {
        enterOuterAlt(_localctx, 2);
        setState(1409);
        booleanType();
        break;
      }

      case ExpressParser::INTEGER: {
        enterOuterAlt(_localctx, 3);
        setState(1410);
        integerType();
        break;
      }

      case ExpressParser::LOGICAL: {
        enterOuterAlt(_localctx, 4);
        setState(1411);
        logicalType();
        break;
      }

      case ExpressParser::NUMBER: {
        enterOuterAlt(_localctx, 5);
        setState(1412);
        numberType();
        break;
      }

      case ExpressParser::REAL: {
        enterOuterAlt(_localctx, 6);
        setState(1413);
        realType();
        break;
      }

      case ExpressParser::STRING: {
        enterOuterAlt(_localctx, 7);
        setState(1414);
        stringType();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SkipStmtContext ------------------------------------------------------------------

ExpressParser::SkipStmtContext::SkipStmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::SkipStmtContext::SKIP_() {
  return getToken(ExpressParser::SKIP_, 0);
}


size_t ExpressParser::SkipStmtContext::getRuleIndex() const {
  return ExpressParser::RuleSkipStmt;
}

void ExpressParser::SkipStmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSkipStmt(this);
}

void ExpressParser::SkipStmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSkipStmt(this);
}


std::any ExpressParser::SkipStmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSkipStmt(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SkipStmtContext* ExpressParser::skipStmt() {
  SkipStmtContext *_localctx = _tracker.createInstance<SkipStmtContext>(_ctx, getState());
  enterRule(_localctx, 330, ExpressParser::RuleSkipStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1417);
    match(ExpressParser::SKIP_);
    setState(1418);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StmtContext ------------------------------------------------------------------

ExpressParser::StmtContext::StmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::AliasStmtContext* ExpressParser::StmtContext::aliasStmt() {
  return getRuleContext<ExpressParser::AliasStmtContext>(0);
}

ExpressParser::AssignmentStmtContext* ExpressParser::StmtContext::assignmentStmt() {
  return getRuleContext<ExpressParser::AssignmentStmtContext>(0);
}

ExpressParser::CaseStmtContext* ExpressParser::StmtContext::caseStmt() {
  return getRuleContext<ExpressParser::CaseStmtContext>(0);
}

ExpressParser::CompoundStmtContext* ExpressParser::StmtContext::compoundStmt() {
  return getRuleContext<ExpressParser::CompoundStmtContext>(0);
}

ExpressParser::EscapeStmtContext* ExpressParser::StmtContext::escapeStmt() {
  return getRuleContext<ExpressParser::EscapeStmtContext>(0);
}

ExpressParser::IfStmtContext* ExpressParser::StmtContext::ifStmt() {
  return getRuleContext<ExpressParser::IfStmtContext>(0);
}

ExpressParser::NullStmtContext* ExpressParser::StmtContext::nullStmt() {
  return getRuleContext<ExpressParser::NullStmtContext>(0);
}

ExpressParser::ProcedureCallStmtContext* ExpressParser::StmtContext::procedureCallStmt() {
  return getRuleContext<ExpressParser::ProcedureCallStmtContext>(0);
}

ExpressParser::RepeatStmtContext* ExpressParser::StmtContext::repeatStmt() {
  return getRuleContext<ExpressParser::RepeatStmtContext>(0);
}

ExpressParser::ReturnStmtContext* ExpressParser::StmtContext::returnStmt() {
  return getRuleContext<ExpressParser::ReturnStmtContext>(0);
}

ExpressParser::SkipStmtContext* ExpressParser::StmtContext::skipStmt() {
  return getRuleContext<ExpressParser::SkipStmtContext>(0);
}


size_t ExpressParser::StmtContext::getRuleIndex() const {
  return ExpressParser::RuleStmt;
}

void ExpressParser::StmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStmt(this);
}

void ExpressParser::StmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStmt(this);
}


std::any ExpressParser::StmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitStmt(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::StmtContext* ExpressParser::stmt() {
  StmtContext *_localctx = _tracker.createInstance<StmtContext>(_ctx, getState());
  enterRule(_localctx, 332, ExpressParser::RuleStmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1431);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 126, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1420);
      aliasStmt();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1421);
      assignmentStmt();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1422);
      caseStmt();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1423);
      compoundStmt();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1424);
      escapeStmt();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1425);
      ifStmt();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1426);
      nullStmt();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1427);
      procedureCallStmt();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1428);
      repeatStmt();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1429);
      returnStmt();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1430);
      skipStmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringLiteralContext ------------------------------------------------------------------

ExpressParser::StringLiteralContext::StringLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::StringLiteralContext::SimpleStringLiteral() {
  return getToken(ExpressParser::SimpleStringLiteral, 0);
}

tree::TerminalNode* ExpressParser::StringLiteralContext::EncodedStringLiteral() {
  return getToken(ExpressParser::EncodedStringLiteral, 0);
}


size_t ExpressParser::StringLiteralContext::getRuleIndex() const {
  return ExpressParser::RuleStringLiteral;
}

void ExpressParser::StringLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStringLiteral(this);
}

void ExpressParser::StringLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStringLiteral(this);
}


std::any ExpressParser::StringLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitStringLiteral(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::StringLiteralContext* ExpressParser::stringLiteral() {
  StringLiteralContext *_localctx = _tracker.createInstance<StringLiteralContext>(_ctx, getState());
  enterRule(_localctx, 334, ExpressParser::RuleStringLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1433);
    _la = _input->LA(1);
    if (!(_la == ExpressParser::EncodedStringLiteral

    || _la == ExpressParser::SimpleStringLiteral)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringTypeContext ------------------------------------------------------------------

ExpressParser::StringTypeContext::StringTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::StringTypeContext::STRING() {
  return getToken(ExpressParser::STRING, 0);
}

ExpressParser::WidthSpecContext* ExpressParser::StringTypeContext::widthSpec() {
  return getRuleContext<ExpressParser::WidthSpecContext>(0);
}


size_t ExpressParser::StringTypeContext::getRuleIndex() const {
  return ExpressParser::RuleStringType;
}

void ExpressParser::StringTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStringType(this);
}

void ExpressParser::StringTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStringType(this);
}


std::any ExpressParser::StringTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitStringType(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::StringTypeContext* ExpressParser::stringType() {
  StringTypeContext *_localctx = _tracker.createInstance<StringTypeContext>(_ctx, getState());
  enterRule(_localctx, 336, ExpressParser::RuleStringType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1435);
    match(ExpressParser::STRING);
    setState(1437);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::T__1) {
      setState(1436);
      widthSpec();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubsuperContext ------------------------------------------------------------------

ExpressParser::SubsuperContext::SubsuperContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::SupertypeConstraintContext* ExpressParser::SubsuperContext::supertypeConstraint() {
  return getRuleContext<ExpressParser::SupertypeConstraintContext>(0);
}

ExpressParser::SubtypeDeclarationContext* ExpressParser::SubsuperContext::subtypeDeclaration() {
  return getRuleContext<ExpressParser::SubtypeDeclarationContext>(0);
}


size_t ExpressParser::SubsuperContext::getRuleIndex() const {
  return ExpressParser::RuleSubsuper;
}

void ExpressParser::SubsuperContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubsuper(this);
}

void ExpressParser::SubsuperContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubsuper(this);
}


std::any ExpressParser::SubsuperContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSubsuper(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SubsuperContext* ExpressParser::subsuper() {
  SubsuperContext *_localctx = _tracker.createInstance<SubsuperContext>(_ctx, getState());
  enterRule(_localctx, 338, ExpressParser::RuleSubsuper);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1440);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::ABSTRACT || _la == ExpressParser::SUPERTYPE) {
      setState(1439);
      supertypeConstraint();
    }
    setState(1443);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::SUBTYPE) {
      setState(1442);
      subtypeDeclaration();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubtypeConstraintContext ------------------------------------------------------------------

ExpressParser::SubtypeConstraintContext::SubtypeConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::SubtypeConstraintContext::OF() {
  return getToken(ExpressParser::OF, 0);
}

ExpressParser::SupertypeExpressionContext* ExpressParser::SubtypeConstraintContext::supertypeExpression() {
  return getRuleContext<ExpressParser::SupertypeExpressionContext>(0);
}


size_t ExpressParser::SubtypeConstraintContext::getRuleIndex() const {
  return ExpressParser::RuleSubtypeConstraint;
}

void ExpressParser::SubtypeConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubtypeConstraint(this);
}

void ExpressParser::SubtypeConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubtypeConstraint(this);
}


std::any ExpressParser::SubtypeConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSubtypeConstraint(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SubtypeConstraintContext* ExpressParser::subtypeConstraint() {
  SubtypeConstraintContext *_localctx = _tracker.createInstance<SubtypeConstraintContext>(_ctx, getState());
  enterRule(_localctx, 340, ExpressParser::RuleSubtypeConstraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1445);
    match(ExpressParser::OF);
    setState(1446);
    match(ExpressParser::T__1);
    setState(1447);
    supertypeExpression();
    setState(1448);
    match(ExpressParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubtypeConstraintBodyContext ------------------------------------------------------------------

ExpressParser::SubtypeConstraintBodyContext::SubtypeConstraintBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::AbstractSupertypeContext* ExpressParser::SubtypeConstraintBodyContext::abstractSupertype() {
  return getRuleContext<ExpressParser::AbstractSupertypeContext>(0);
}

ExpressParser::TotalOverContext* ExpressParser::SubtypeConstraintBodyContext::totalOver() {
  return getRuleContext<ExpressParser::TotalOverContext>(0);
}

ExpressParser::SupertypeExpressionContext* ExpressParser::SubtypeConstraintBodyContext::supertypeExpression() {
  return getRuleContext<ExpressParser::SupertypeExpressionContext>(0);
}


size_t ExpressParser::SubtypeConstraintBodyContext::getRuleIndex() const {
  return ExpressParser::RuleSubtypeConstraintBody;
}

void ExpressParser::SubtypeConstraintBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubtypeConstraintBody(this);
}

void ExpressParser::SubtypeConstraintBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubtypeConstraintBody(this);
}


std::any ExpressParser::SubtypeConstraintBodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSubtypeConstraintBody(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SubtypeConstraintBodyContext* ExpressParser::subtypeConstraintBody() {
  SubtypeConstraintBodyContext *_localctx = _tracker.createInstance<SubtypeConstraintBodyContext>(_ctx, getState());
  enterRule(_localctx, 342, ExpressParser::RuleSubtypeConstraintBody);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1451);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::ABSTRACT) {
      setState(1450);
      abstractSupertype();
    }
    setState(1454);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::TOTAL_OVER) {
      setState(1453);
      totalOver();
    }
    setState(1459);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::T__1 || _la == ExpressParser::ONEOF

    || _la == ExpressParser::SimpleId) {
      setState(1456);
      supertypeExpression();
      setState(1457);
      match(ExpressParser::T__0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubtypeConstraintDeclContext ------------------------------------------------------------------

ExpressParser::SubtypeConstraintDeclContext::SubtypeConstraintDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::SubtypeConstraintHeadContext* ExpressParser::SubtypeConstraintDeclContext::subtypeConstraintHead() {
  return getRuleContext<ExpressParser::SubtypeConstraintHeadContext>(0);
}

ExpressParser::SubtypeConstraintBodyContext* ExpressParser::SubtypeConstraintDeclContext::subtypeConstraintBody() {
  return getRuleContext<ExpressParser::SubtypeConstraintBodyContext>(0);
}

tree::TerminalNode* ExpressParser::SubtypeConstraintDeclContext::END_SUBTYPE_CONSTRAINT() {
  return getToken(ExpressParser::END_SUBTYPE_CONSTRAINT, 0);
}


size_t ExpressParser::SubtypeConstraintDeclContext::getRuleIndex() const {
  return ExpressParser::RuleSubtypeConstraintDecl;
}

void ExpressParser::SubtypeConstraintDeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubtypeConstraintDecl(this);
}

void ExpressParser::SubtypeConstraintDeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubtypeConstraintDecl(this);
}


std::any ExpressParser::SubtypeConstraintDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSubtypeConstraintDecl(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SubtypeConstraintDeclContext* ExpressParser::subtypeConstraintDecl() {
  SubtypeConstraintDeclContext *_localctx = _tracker.createInstance<SubtypeConstraintDeclContext>(_ctx, getState());
  enterRule(_localctx, 344, ExpressParser::RuleSubtypeConstraintDecl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1461);
    subtypeConstraintHead();
    setState(1462);
    subtypeConstraintBody();
    setState(1463);
    match(ExpressParser::END_SUBTYPE_CONSTRAINT);
    setState(1464);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubtypeConstraintHeadContext ------------------------------------------------------------------

ExpressParser::SubtypeConstraintHeadContext::SubtypeConstraintHeadContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::SubtypeConstraintHeadContext::SUBTYPE_CONSTRAINT() {
  return getToken(ExpressParser::SUBTYPE_CONSTRAINT, 0);
}

ExpressParser::SubtypeConstraintIdContext* ExpressParser::SubtypeConstraintHeadContext::subtypeConstraintId() {
  return getRuleContext<ExpressParser::SubtypeConstraintIdContext>(0);
}

tree::TerminalNode* ExpressParser::SubtypeConstraintHeadContext::FOR() {
  return getToken(ExpressParser::FOR, 0);
}

ExpressParser::EntityRefContext* ExpressParser::SubtypeConstraintHeadContext::entityRef() {
  return getRuleContext<ExpressParser::EntityRefContext>(0);
}


size_t ExpressParser::SubtypeConstraintHeadContext::getRuleIndex() const {
  return ExpressParser::RuleSubtypeConstraintHead;
}

void ExpressParser::SubtypeConstraintHeadContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubtypeConstraintHead(this);
}

void ExpressParser::SubtypeConstraintHeadContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubtypeConstraintHead(this);
}


std::any ExpressParser::SubtypeConstraintHeadContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSubtypeConstraintHead(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SubtypeConstraintHeadContext* ExpressParser::subtypeConstraintHead() {
  SubtypeConstraintHeadContext *_localctx = _tracker.createInstance<SubtypeConstraintHeadContext>(_ctx, getState());
  enterRule(_localctx, 346, ExpressParser::RuleSubtypeConstraintHead);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1466);
    match(ExpressParser::SUBTYPE_CONSTRAINT);
    setState(1467);
    subtypeConstraintId();
    setState(1468);
    match(ExpressParser::FOR);
    setState(1469);
    entityRef();
    setState(1470);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubtypeConstraintIdContext ------------------------------------------------------------------

ExpressParser::SubtypeConstraintIdContext::SubtypeConstraintIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::SubtypeConstraintIdContext::SimpleId() {
  return getToken(ExpressParser::SimpleId, 0);
}


size_t ExpressParser::SubtypeConstraintIdContext::getRuleIndex() const {
  return ExpressParser::RuleSubtypeConstraintId;
}

void ExpressParser::SubtypeConstraintIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubtypeConstraintId(this);
}

void ExpressParser::SubtypeConstraintIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubtypeConstraintId(this);
}


std::any ExpressParser::SubtypeConstraintIdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSubtypeConstraintId(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SubtypeConstraintIdContext* ExpressParser::subtypeConstraintId() {
  SubtypeConstraintIdContext *_localctx = _tracker.createInstance<SubtypeConstraintIdContext>(_ctx, getState());
  enterRule(_localctx, 348, ExpressParser::RuleSubtypeConstraintId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1472);
    match(ExpressParser::SimpleId);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubtypeDeclarationContext ------------------------------------------------------------------

ExpressParser::SubtypeDeclarationContext::SubtypeDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::SubtypeDeclarationContext::SUBTYPE() {
  return getToken(ExpressParser::SUBTYPE, 0);
}

tree::TerminalNode* ExpressParser::SubtypeDeclarationContext::OF() {
  return getToken(ExpressParser::OF, 0);
}

std::vector<ExpressParser::EntityRefContext *> ExpressParser::SubtypeDeclarationContext::entityRef() {
  return getRuleContexts<ExpressParser::EntityRefContext>();
}

ExpressParser::EntityRefContext* ExpressParser::SubtypeDeclarationContext::entityRef(size_t i) {
  return getRuleContext<ExpressParser::EntityRefContext>(i);
}


size_t ExpressParser::SubtypeDeclarationContext::getRuleIndex() const {
  return ExpressParser::RuleSubtypeDeclaration;
}

void ExpressParser::SubtypeDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubtypeDeclaration(this);
}

void ExpressParser::SubtypeDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubtypeDeclaration(this);
}


std::any ExpressParser::SubtypeDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSubtypeDeclaration(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SubtypeDeclarationContext* ExpressParser::subtypeDeclaration() {
  SubtypeDeclarationContext *_localctx = _tracker.createInstance<SubtypeDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 350, ExpressParser::RuleSubtypeDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1474);
    match(ExpressParser::SUBTYPE);
    setState(1475);
    match(ExpressParser::OF);
    setState(1476);
    match(ExpressParser::T__1);
    setState(1477);
    entityRef();
    setState(1482);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExpressParser::T__2) {
      setState(1478);
      match(ExpressParser::T__2);
      setState(1479);
      entityRef();
      setState(1484);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1485);
    match(ExpressParser::T__3);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SupertypeConstraintContext ------------------------------------------------------------------

ExpressParser::SupertypeConstraintContext::SupertypeConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::AbstractEntityDeclarationContext* ExpressParser::SupertypeConstraintContext::abstractEntityDeclaration() {
  return getRuleContext<ExpressParser::AbstractEntityDeclarationContext>(0);
}

ExpressParser::AbstractSupertypeDeclarationContext* ExpressParser::SupertypeConstraintContext::abstractSupertypeDeclaration() {
  return getRuleContext<ExpressParser::AbstractSupertypeDeclarationContext>(0);
}

ExpressParser::SupertypeRuleContext* ExpressParser::SupertypeConstraintContext::supertypeRule() {
  return getRuleContext<ExpressParser::SupertypeRuleContext>(0);
}


size_t ExpressParser::SupertypeConstraintContext::getRuleIndex() const {
  return ExpressParser::RuleSupertypeConstraint;
}

void ExpressParser::SupertypeConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSupertypeConstraint(this);
}

void ExpressParser::SupertypeConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSupertypeConstraint(this);
}


std::any ExpressParser::SupertypeConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSupertypeConstraint(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SupertypeConstraintContext* ExpressParser::supertypeConstraint() {
  SupertypeConstraintContext *_localctx = _tracker.createInstance<SupertypeConstraintContext>(_ctx, getState());
  enterRule(_localctx, 352, ExpressParser::RuleSupertypeConstraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1490);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 134, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1487);
      abstractEntityDeclaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1488);
      abstractSupertypeDeclaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1489);
      supertypeRule();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SupertypeExpressionContext ------------------------------------------------------------------

ExpressParser::SupertypeExpressionContext::SupertypeExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExpressParser::SupertypeFactorContext *> ExpressParser::SupertypeExpressionContext::supertypeFactor() {
  return getRuleContexts<ExpressParser::SupertypeFactorContext>();
}

ExpressParser::SupertypeFactorContext* ExpressParser::SupertypeExpressionContext::supertypeFactor(size_t i) {
  return getRuleContext<ExpressParser::SupertypeFactorContext>(i);
}

std::vector<tree::TerminalNode *> ExpressParser::SupertypeExpressionContext::ANDOR() {
  return getTokens(ExpressParser::ANDOR);
}

tree::TerminalNode* ExpressParser::SupertypeExpressionContext::ANDOR(size_t i) {
  return getToken(ExpressParser::ANDOR, i);
}


size_t ExpressParser::SupertypeExpressionContext::getRuleIndex() const {
  return ExpressParser::RuleSupertypeExpression;
}

void ExpressParser::SupertypeExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSupertypeExpression(this);
}

void ExpressParser::SupertypeExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSupertypeExpression(this);
}


std::any ExpressParser::SupertypeExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSupertypeExpression(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SupertypeExpressionContext* ExpressParser::supertypeExpression() {
  SupertypeExpressionContext *_localctx = _tracker.createInstance<SupertypeExpressionContext>(_ctx, getState());
  enterRule(_localctx, 354, ExpressParser::RuleSupertypeExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1492);
    supertypeFactor();
    setState(1497);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExpressParser::ANDOR) {
      setState(1493);
      match(ExpressParser::ANDOR);
      setState(1494);
      supertypeFactor();
      setState(1499);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SupertypeFactorContext ------------------------------------------------------------------

ExpressParser::SupertypeFactorContext::SupertypeFactorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExpressParser::SupertypeTermContext *> ExpressParser::SupertypeFactorContext::supertypeTerm() {
  return getRuleContexts<ExpressParser::SupertypeTermContext>();
}

ExpressParser::SupertypeTermContext* ExpressParser::SupertypeFactorContext::supertypeTerm(size_t i) {
  return getRuleContext<ExpressParser::SupertypeTermContext>(i);
}

std::vector<tree::TerminalNode *> ExpressParser::SupertypeFactorContext::AND() {
  return getTokens(ExpressParser::AND);
}

tree::TerminalNode* ExpressParser::SupertypeFactorContext::AND(size_t i) {
  return getToken(ExpressParser::AND, i);
}


size_t ExpressParser::SupertypeFactorContext::getRuleIndex() const {
  return ExpressParser::RuleSupertypeFactor;
}

void ExpressParser::SupertypeFactorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSupertypeFactor(this);
}

void ExpressParser::SupertypeFactorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSupertypeFactor(this);
}


std::any ExpressParser::SupertypeFactorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSupertypeFactor(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SupertypeFactorContext* ExpressParser::supertypeFactor() {
  SupertypeFactorContext *_localctx = _tracker.createInstance<SupertypeFactorContext>(_ctx, getState());
  enterRule(_localctx, 356, ExpressParser::RuleSupertypeFactor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1500);
    supertypeTerm();
    setState(1505);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExpressParser::AND) {
      setState(1501);
      match(ExpressParser::AND);
      setState(1502);
      supertypeTerm();
      setState(1507);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SupertypeRuleContext ------------------------------------------------------------------

ExpressParser::SupertypeRuleContext::SupertypeRuleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::SupertypeRuleContext::SUPERTYPE() {
  return getToken(ExpressParser::SUPERTYPE, 0);
}

ExpressParser::SubtypeConstraintContext* ExpressParser::SupertypeRuleContext::subtypeConstraint() {
  return getRuleContext<ExpressParser::SubtypeConstraintContext>(0);
}


size_t ExpressParser::SupertypeRuleContext::getRuleIndex() const {
  return ExpressParser::RuleSupertypeRule;
}

void ExpressParser::SupertypeRuleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSupertypeRule(this);
}

void ExpressParser::SupertypeRuleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSupertypeRule(this);
}


std::any ExpressParser::SupertypeRuleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSupertypeRule(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SupertypeRuleContext* ExpressParser::supertypeRule() {
  SupertypeRuleContext *_localctx = _tracker.createInstance<SupertypeRuleContext>(_ctx, getState());
  enterRule(_localctx, 358, ExpressParser::RuleSupertypeRule);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1508);
    match(ExpressParser::SUPERTYPE);
    setState(1509);
    subtypeConstraint();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SupertypeTermContext ------------------------------------------------------------------

ExpressParser::SupertypeTermContext::SupertypeTermContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::EntityRefContext* ExpressParser::SupertypeTermContext::entityRef() {
  return getRuleContext<ExpressParser::EntityRefContext>(0);
}

ExpressParser::OneOfContext* ExpressParser::SupertypeTermContext::oneOf() {
  return getRuleContext<ExpressParser::OneOfContext>(0);
}

ExpressParser::SupertypeExpressionContext* ExpressParser::SupertypeTermContext::supertypeExpression() {
  return getRuleContext<ExpressParser::SupertypeExpressionContext>(0);
}


size_t ExpressParser::SupertypeTermContext::getRuleIndex() const {
  return ExpressParser::RuleSupertypeTerm;
}

void ExpressParser::SupertypeTermContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSupertypeTerm(this);
}

void ExpressParser::SupertypeTermContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSupertypeTerm(this);
}


std::any ExpressParser::SupertypeTermContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSupertypeTerm(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SupertypeTermContext* ExpressParser::supertypeTerm() {
  SupertypeTermContext *_localctx = _tracker.createInstance<SupertypeTermContext>(_ctx, getState());
  enterRule(_localctx, 360, ExpressParser::RuleSupertypeTerm);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1517);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExpressParser::SimpleId: {
        enterOuterAlt(_localctx, 1);
        setState(1511);
        entityRef();
        break;
      }

      case ExpressParser::ONEOF: {
        enterOuterAlt(_localctx, 2);
        setState(1512);
        oneOf();
        break;
      }

      case ExpressParser::T__1: {
        enterOuterAlt(_localctx, 3);
        setState(1513);
        match(ExpressParser::T__1);
        setState(1514);
        supertypeExpression();
        setState(1515);
        match(ExpressParser::T__3);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SyntaxContext ------------------------------------------------------------------

ExpressParser::SyntaxContext::SyntaxContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::SyntaxContext::EOF() {
  return getToken(ExpressParser::EOF, 0);
}

std::vector<ExpressParser::SchemaDeclContext *> ExpressParser::SyntaxContext::schemaDecl() {
  return getRuleContexts<ExpressParser::SchemaDeclContext>();
}

ExpressParser::SchemaDeclContext* ExpressParser::SyntaxContext::schemaDecl(size_t i) {
  return getRuleContext<ExpressParser::SchemaDeclContext>(i);
}


size_t ExpressParser::SyntaxContext::getRuleIndex() const {
  return ExpressParser::RuleSyntax;
}

void ExpressParser::SyntaxContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSyntax(this);
}

void ExpressParser::SyntaxContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSyntax(this);
}


std::any ExpressParser::SyntaxContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitSyntax(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::SyntaxContext* ExpressParser::syntax() {
  SyntaxContext *_localctx = _tracker.createInstance<SyntaxContext>(_ctx, getState());
  enterRule(_localctx, 362, ExpressParser::RuleSyntax);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1520); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1519);
      schemaDecl();
      setState(1522); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == ExpressParser::SCHEMA);
    setState(1524);
    match(ExpressParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TermContext ------------------------------------------------------------------

ExpressParser::TermContext::TermContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExpressParser::FactorContext *> ExpressParser::TermContext::factor() {
  return getRuleContexts<ExpressParser::FactorContext>();
}

ExpressParser::FactorContext* ExpressParser::TermContext::factor(size_t i) {
  return getRuleContext<ExpressParser::FactorContext>(i);
}

std::vector<ExpressParser::MultiplicationLikeOpContext *> ExpressParser::TermContext::multiplicationLikeOp() {
  return getRuleContexts<ExpressParser::MultiplicationLikeOpContext>();
}

ExpressParser::MultiplicationLikeOpContext* ExpressParser::TermContext::multiplicationLikeOp(size_t i) {
  return getRuleContext<ExpressParser::MultiplicationLikeOpContext>(i);
}


size_t ExpressParser::TermContext::getRuleIndex() const {
  return ExpressParser::RuleTerm;
}

void ExpressParser::TermContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTerm(this);
}

void ExpressParser::TermContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTerm(this);
}


std::any ExpressParser::TermContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitTerm(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::TermContext* ExpressParser::term() {
  TermContext *_localctx = _tracker.createInstance<TermContext>(_ctx, getState());
  enterRule(_localctx, 364, ExpressParser::RuleTerm);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1526);
    factor();
    setState(1532);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << ExpressParser::T__18)
      | (1ULL << ExpressParser::T__19)
      | (1ULL << ExpressParser::T__20)
      | (1ULL << ExpressParser::AND)
      | (1ULL << ExpressParser::DIV))) != 0) || _la == ExpressParser::MOD) {
      setState(1527);
      multiplicationLikeOp();
      setState(1528);
      factor();
      setState(1534);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TotalOverContext ------------------------------------------------------------------

ExpressParser::TotalOverContext::TotalOverContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::TotalOverContext::TOTAL_OVER() {
  return getToken(ExpressParser::TOTAL_OVER, 0);
}

std::vector<ExpressParser::EntityRefContext *> ExpressParser::TotalOverContext::entityRef() {
  return getRuleContexts<ExpressParser::EntityRefContext>();
}

ExpressParser::EntityRefContext* ExpressParser::TotalOverContext::entityRef(size_t i) {
  return getRuleContext<ExpressParser::EntityRefContext>(i);
}


size_t ExpressParser::TotalOverContext::getRuleIndex() const {
  return ExpressParser::RuleTotalOver;
}

void ExpressParser::TotalOverContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTotalOver(this);
}

void ExpressParser::TotalOverContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTotalOver(this);
}


std::any ExpressParser::TotalOverContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitTotalOver(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::TotalOverContext* ExpressParser::totalOver() {
  TotalOverContext *_localctx = _tracker.createInstance<TotalOverContext>(_ctx, getState());
  enterRule(_localctx, 366, ExpressParser::RuleTotalOver);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1535);
    match(ExpressParser::TOTAL_OVER);
    setState(1536);
    match(ExpressParser::T__1);
    setState(1537);
    entityRef();
    setState(1542);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExpressParser::T__2) {
      setState(1538);
      match(ExpressParser::T__2);
      setState(1539);
      entityRef();
      setState(1544);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1545);
    match(ExpressParser::T__3);
    setState(1546);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeDeclContext ------------------------------------------------------------------

ExpressParser::TypeDeclContext::TypeDeclContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::TypeDeclContext::TYPE() {
  return getToken(ExpressParser::TYPE, 0);
}

ExpressParser::TypeIdContext* ExpressParser::TypeDeclContext::typeId() {
  return getRuleContext<ExpressParser::TypeIdContext>(0);
}

ExpressParser::UnderlyingTypeContext* ExpressParser::TypeDeclContext::underlyingType() {
  return getRuleContext<ExpressParser::UnderlyingTypeContext>(0);
}

tree::TerminalNode* ExpressParser::TypeDeclContext::END_TYPE() {
  return getToken(ExpressParser::END_TYPE, 0);
}

ExpressParser::WhereClauseContext* ExpressParser::TypeDeclContext::whereClause() {
  return getRuleContext<ExpressParser::WhereClauseContext>(0);
}


size_t ExpressParser::TypeDeclContext::getRuleIndex() const {
  return ExpressParser::RuleTypeDecl;
}

void ExpressParser::TypeDeclContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeDecl(this);
}

void ExpressParser::TypeDeclContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeDecl(this);
}


std::any ExpressParser::TypeDeclContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitTypeDecl(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::TypeDeclContext* ExpressParser::typeDecl() {
  TypeDeclContext *_localctx = _tracker.createInstance<TypeDeclContext>(_ctx, getState());
  enterRule(_localctx, 368, ExpressParser::RuleTypeDecl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1548);
    match(ExpressParser::TYPE);
    setState(1549);
    typeId();
    setState(1550);
    match(ExpressParser::T__26);
    setState(1551);
    underlyingType();
    setState(1552);
    match(ExpressParser::T__0);
    setState(1554);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::WHERE) {
      setState(1553);
      whereClause();
    }
    setState(1556);
    match(ExpressParser::END_TYPE);
    setState(1557);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeIdContext ------------------------------------------------------------------

ExpressParser::TypeIdContext::TypeIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::TypeIdContext::SimpleId() {
  return getToken(ExpressParser::SimpleId, 0);
}


size_t ExpressParser::TypeIdContext::getRuleIndex() const {
  return ExpressParser::RuleTypeId;
}

void ExpressParser::TypeIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeId(this);
}

void ExpressParser::TypeIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeId(this);
}


std::any ExpressParser::TypeIdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitTypeId(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::TypeIdContext* ExpressParser::typeId() {
  TypeIdContext *_localctx = _tracker.createInstance<TypeIdContext>(_ctx, getState());
  enterRule(_localctx, 370, ExpressParser::RuleTypeId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1559);
    match(ExpressParser::SimpleId);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeLabelContext ------------------------------------------------------------------

ExpressParser::TypeLabelContext::TypeLabelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::TypeLabelIdContext* ExpressParser::TypeLabelContext::typeLabelId() {
  return getRuleContext<ExpressParser::TypeLabelIdContext>(0);
}

ExpressParser::TypeLabelRefContext* ExpressParser::TypeLabelContext::typeLabelRef() {
  return getRuleContext<ExpressParser::TypeLabelRefContext>(0);
}


size_t ExpressParser::TypeLabelContext::getRuleIndex() const {
  return ExpressParser::RuleTypeLabel;
}

void ExpressParser::TypeLabelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeLabel(this);
}

void ExpressParser::TypeLabelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeLabel(this);
}


std::any ExpressParser::TypeLabelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitTypeLabel(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::TypeLabelContext* ExpressParser::typeLabel() {
  TypeLabelContext *_localctx = _tracker.createInstance<TypeLabelContext>(_ctx, getState());
  enterRule(_localctx, 372, ExpressParser::RuleTypeLabel);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1563);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 142, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1561);
      typeLabelId();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1562);
      typeLabelRef();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeLabelIdContext ------------------------------------------------------------------

ExpressParser::TypeLabelIdContext::TypeLabelIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::TypeLabelIdContext::SimpleId() {
  return getToken(ExpressParser::SimpleId, 0);
}


size_t ExpressParser::TypeLabelIdContext::getRuleIndex() const {
  return ExpressParser::RuleTypeLabelId;
}

void ExpressParser::TypeLabelIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeLabelId(this);
}

void ExpressParser::TypeLabelIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeLabelId(this);
}


std::any ExpressParser::TypeLabelIdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitTypeLabelId(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::TypeLabelIdContext* ExpressParser::typeLabelId() {
  TypeLabelIdContext *_localctx = _tracker.createInstance<TypeLabelIdContext>(_ctx, getState());
  enterRule(_localctx, 374, ExpressParser::RuleTypeLabelId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1565);
    match(ExpressParser::SimpleId);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnaryOpContext ------------------------------------------------------------------

ExpressParser::UnaryOpContext::UnaryOpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::UnaryOpContext::NOT() {
  return getToken(ExpressParser::NOT, 0);
}


size_t ExpressParser::UnaryOpContext::getRuleIndex() const {
  return ExpressParser::RuleUnaryOp;
}

void ExpressParser::UnaryOpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryOp(this);
}

void ExpressParser::UnaryOpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryOp(this);
}


std::any ExpressParser::UnaryOpContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitUnaryOp(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::UnaryOpContext* ExpressParser::unaryOp() {
  UnaryOpContext *_localctx = _tracker.createInstance<UnaryOpContext>(_ctx, getState());
  enterRule(_localctx, 376, ExpressParser::RuleUnaryOp);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1567);
    _la = _input->LA(1);
    if (!(_la == ExpressParser::T__4

    || _la == ExpressParser::T__5 || _la == ExpressParser::NOT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnderlyingTypeContext ------------------------------------------------------------------

ExpressParser::UnderlyingTypeContext::UnderlyingTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::ConcreteTypesContext* ExpressParser::UnderlyingTypeContext::concreteTypes() {
  return getRuleContext<ExpressParser::ConcreteTypesContext>(0);
}

ExpressParser::ConstructedTypesContext* ExpressParser::UnderlyingTypeContext::constructedTypes() {
  return getRuleContext<ExpressParser::ConstructedTypesContext>(0);
}


size_t ExpressParser::UnderlyingTypeContext::getRuleIndex() const {
  return ExpressParser::RuleUnderlyingType;
}

void ExpressParser::UnderlyingTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnderlyingType(this);
}

void ExpressParser::UnderlyingTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnderlyingType(this);
}


std::any ExpressParser::UnderlyingTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitUnderlyingType(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::UnderlyingTypeContext* ExpressParser::underlyingType() {
  UnderlyingTypeContext *_localctx = _tracker.createInstance<UnderlyingTypeContext>(_ctx, getState());
  enterRule(_localctx, 378, ExpressParser::RuleUnderlyingType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1571);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ExpressParser::ARRAY:
      case ExpressParser::BAG:
      case ExpressParser::BINARY:
      case ExpressParser::BOOLEAN:
      case ExpressParser::INTEGER:
      case ExpressParser::LIST:
      case ExpressParser::LOGICAL:
      case ExpressParser::NUMBER:
      case ExpressParser::REAL:
      case ExpressParser::SET:
      case ExpressParser::STRING:
      case ExpressParser::SimpleId: {
        enterOuterAlt(_localctx, 1);
        setState(1569);
        concreteTypes();
        break;
      }

      case ExpressParser::ENUMERATION:
      case ExpressParser::EXTENSIBLE:
      case ExpressParser::SELECT: {
        enterOuterAlt(_localctx, 2);
        setState(1570);
        constructedTypes();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UniqueClauseContext ------------------------------------------------------------------

ExpressParser::UniqueClauseContext::UniqueClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::UniqueClauseContext::UNIQUE() {
  return getToken(ExpressParser::UNIQUE, 0);
}

std::vector<ExpressParser::UniqueRuleContext *> ExpressParser::UniqueClauseContext::uniqueRule() {
  return getRuleContexts<ExpressParser::UniqueRuleContext>();
}

ExpressParser::UniqueRuleContext* ExpressParser::UniqueClauseContext::uniqueRule(size_t i) {
  return getRuleContext<ExpressParser::UniqueRuleContext>(i);
}


size_t ExpressParser::UniqueClauseContext::getRuleIndex() const {
  return ExpressParser::RuleUniqueClause;
}

void ExpressParser::UniqueClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUniqueClause(this);
}

void ExpressParser::UniqueClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUniqueClause(this);
}


std::any ExpressParser::UniqueClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitUniqueClause(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::UniqueClauseContext* ExpressParser::uniqueClause() {
  UniqueClauseContext *_localctx = _tracker.createInstance<UniqueClauseContext>(_ctx, getState());
  enterRule(_localctx, 380, ExpressParser::RuleUniqueClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1573);
    match(ExpressParser::UNIQUE);
    setState(1574);
    uniqueRule();
    setState(1575);
    match(ExpressParser::T__0);
    setState(1581);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExpressParser::SELF

    || _la == ExpressParser::SimpleId) {
      setState(1576);
      uniqueRule();
      setState(1577);
      match(ExpressParser::T__0);
      setState(1583);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UniqueRuleContext ------------------------------------------------------------------

ExpressParser::UniqueRuleContext::UniqueRuleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ExpressParser::ReferencedAttributeContext *> ExpressParser::UniqueRuleContext::referencedAttribute() {
  return getRuleContexts<ExpressParser::ReferencedAttributeContext>();
}

ExpressParser::ReferencedAttributeContext* ExpressParser::UniqueRuleContext::referencedAttribute(size_t i) {
  return getRuleContext<ExpressParser::ReferencedAttributeContext>(i);
}

ExpressParser::RuleLabelIdContext* ExpressParser::UniqueRuleContext::ruleLabelId() {
  return getRuleContext<ExpressParser::RuleLabelIdContext>(0);
}


size_t ExpressParser::UniqueRuleContext::getRuleIndex() const {
  return ExpressParser::RuleUniqueRule;
}

void ExpressParser::UniqueRuleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUniqueRule(this);
}

void ExpressParser::UniqueRuleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUniqueRule(this);
}


std::any ExpressParser::UniqueRuleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitUniqueRule(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::UniqueRuleContext* ExpressParser::uniqueRule() {
  UniqueRuleContext *_localctx = _tracker.createInstance<UniqueRuleContext>(_ctx, getState());
  enterRule(_localctx, 382, ExpressParser::RuleUniqueRule);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1587);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 145, _ctx)) {
    case 1: {
      setState(1584);
      ruleLabelId();
      setState(1585);
      match(ExpressParser::T__8);
      break;
    }

    default:
      break;
    }
    setState(1589);
    referencedAttribute();
    setState(1594);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ExpressParser::T__2) {
      setState(1590);
      match(ExpressParser::T__2);
      setState(1591);
      referencedAttribute();
      setState(1596);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UntilControlContext ------------------------------------------------------------------

ExpressParser::UntilControlContext::UntilControlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::UntilControlContext::UNTIL() {
  return getToken(ExpressParser::UNTIL, 0);
}

ExpressParser::LogicalExpressionContext* ExpressParser::UntilControlContext::logicalExpression() {
  return getRuleContext<ExpressParser::LogicalExpressionContext>(0);
}


size_t ExpressParser::UntilControlContext::getRuleIndex() const {
  return ExpressParser::RuleUntilControl;
}

void ExpressParser::UntilControlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUntilControl(this);
}

void ExpressParser::UntilControlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUntilControl(this);
}


std::any ExpressParser::UntilControlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitUntilControl(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::UntilControlContext* ExpressParser::untilControl() {
  UntilControlContext *_localctx = _tracker.createInstance<UntilControlContext>(_ctx, getState());
  enterRule(_localctx, 384, ExpressParser::RuleUntilControl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1597);
    match(ExpressParser::UNTIL);
    setState(1598);
    logicalExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UseClauseContext ------------------------------------------------------------------

ExpressParser::UseClauseContext::UseClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::UseClauseContext::USE() {
  return getToken(ExpressParser::USE, 0);
}

tree::TerminalNode* ExpressParser::UseClauseContext::FROM() {
  return getToken(ExpressParser::FROM, 0);
}

ExpressParser::SchemaRefContext* ExpressParser::UseClauseContext::schemaRef() {
  return getRuleContext<ExpressParser::SchemaRefContext>(0);
}

std::vector<ExpressParser::NamedTypeOrRenameContext *> ExpressParser::UseClauseContext::namedTypeOrRename() {
  return getRuleContexts<ExpressParser::NamedTypeOrRenameContext>();
}

ExpressParser::NamedTypeOrRenameContext* ExpressParser::UseClauseContext::namedTypeOrRename(size_t i) {
  return getRuleContext<ExpressParser::NamedTypeOrRenameContext>(i);
}


size_t ExpressParser::UseClauseContext::getRuleIndex() const {
  return ExpressParser::RuleUseClause;
}

void ExpressParser::UseClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUseClause(this);
}

void ExpressParser::UseClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUseClause(this);
}


std::any ExpressParser::UseClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitUseClause(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::UseClauseContext* ExpressParser::useClause() {
  UseClauseContext *_localctx = _tracker.createInstance<UseClauseContext>(_ctx, getState());
  enterRule(_localctx, 386, ExpressParser::RuleUseClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1600);
    match(ExpressParser::USE);
    setState(1601);
    match(ExpressParser::FROM);
    setState(1602);
    schemaRef();
    setState(1614);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::T__1) {
      setState(1603);
      match(ExpressParser::T__1);
      setState(1604);
      namedTypeOrRename();
      setState(1609);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == ExpressParser::T__2) {
        setState(1605);
        match(ExpressParser::T__2);
        setState(1606);
        namedTypeOrRename();
        setState(1611);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1612);
      match(ExpressParser::T__3);
    }
    setState(1616);
    match(ExpressParser::T__0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableIdContext ------------------------------------------------------------------

ExpressParser::VariableIdContext::VariableIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::VariableIdContext::SimpleId() {
  return getToken(ExpressParser::SimpleId, 0);
}


size_t ExpressParser::VariableIdContext::getRuleIndex() const {
  return ExpressParser::RuleVariableId;
}

void ExpressParser::VariableIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableId(this);
}

void ExpressParser::VariableIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableId(this);
}


std::any ExpressParser::VariableIdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitVariableId(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::VariableIdContext* ExpressParser::variableId() {
  VariableIdContext *_localctx = _tracker.createInstance<VariableIdContext>(_ctx, getState());
  enterRule(_localctx, 388, ExpressParser::RuleVariableId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1618);
    match(ExpressParser::SimpleId);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhereClauseContext ------------------------------------------------------------------

ExpressParser::WhereClauseContext::WhereClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::WhereClauseContext::WHERE() {
  return getToken(ExpressParser::WHERE, 0);
}

std::vector<ExpressParser::DomainRuleContext *> ExpressParser::WhereClauseContext::domainRule() {
  return getRuleContexts<ExpressParser::DomainRuleContext>();
}

ExpressParser::DomainRuleContext* ExpressParser::WhereClauseContext::domainRule(size_t i) {
  return getRuleContext<ExpressParser::DomainRuleContext>(i);
}


size_t ExpressParser::WhereClauseContext::getRuleIndex() const {
  return ExpressParser::RuleWhereClause;
}

void ExpressParser::WhereClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhereClause(this);
}

void ExpressParser::WhereClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhereClause(this);
}


std::any ExpressParser::WhereClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitWhereClause(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::WhereClauseContext* ExpressParser::whereClause() {
  WhereClauseContext *_localctx = _tracker.createInstance<WhereClauseContext>(_ctx, getState());
  enterRule(_localctx, 390, ExpressParser::RuleWhereClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1620);
    match(ExpressParser::WHERE);
    setState(1621);
    domainRule();
    setState(1622);
    match(ExpressParser::T__0);
    setState(1628);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << ExpressParser::T__1)
      | (1ULL << ExpressParser::T__4)
      | (1ULL << ExpressParser::T__5)
      | (1ULL << ExpressParser::T__6)
      | (1ULL << ExpressParser::T__11)
      | (1ULL << ExpressParser::T__14)
      | (1ULL << ExpressParser::ABS)
      | (1ULL << ExpressParser::ACOS)
      | (1ULL << ExpressParser::ASIN)
      | (1ULL << ExpressParser::ATAN)
      | (1ULL << ExpressParser::BLENGTH)
      | (1ULL << ExpressParser::CONST_E)
      | (1ULL << ExpressParser::COS))) != 0) || ((((_la - 72) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 72)) & ((1ULL << (ExpressParser::EXISTS - 72))
      | (1ULL << (ExpressParser::EXP - 72))
      | (1ULL << (ExpressParser::FALSE - 72))
      | (1ULL << (ExpressParser::FORMAT - 72))
      | (1ULL << (ExpressParser::HIBOUND - 72))
      | (1ULL << (ExpressParser::HIINDEX - 72))
      | (1ULL << (ExpressParser::LENGTH - 72))
      | (1ULL << (ExpressParser::LOBOUND - 72))
      | (1ULL << (ExpressParser::LOG - 72))
      | (1ULL << (ExpressParser::LOG10 - 72))
      | (1ULL << (ExpressParser::LOG2 - 72))
      | (1ULL << (ExpressParser::LOINDEX - 72))
      | (1ULL << (ExpressParser::NOT - 72))
      | (1ULL << (ExpressParser::NVL - 72))
      | (1ULL << (ExpressParser::ODD - 72))
      | (1ULL << (ExpressParser::PI - 72))
      | (1ULL << (ExpressParser::QUERY - 72))
      | (1ULL << (ExpressParser::ROLESOF - 72))
      | (1ULL << (ExpressParser::SELF - 72))
      | (1ULL << (ExpressParser::SIN - 72))
      | (1ULL << (ExpressParser::SIZEOF - 72))
      | (1ULL << (ExpressParser::SQRT - 72))
      | (1ULL << (ExpressParser::TAN - 72)))) != 0) || ((((_la - 136) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 136)) & ((1ULL << (ExpressParser::TRUE - 136))
      | (1ULL << (ExpressParser::TYPEOF - 136))
      | (1ULL << (ExpressParser::UNKNOWN - 136))
      | (1ULL << (ExpressParser::USEDIN - 136))
      | (1ULL << (ExpressParser::VALUE_ - 136))
      | (1ULL << (ExpressParser::VALUE_IN - 136))
      | (1ULL << (ExpressParser::VALUE_UNIQUE - 136))
      | (1ULL << (ExpressParser::BinaryLiteral - 136))
      | (1ULL << (ExpressParser::EncodedStringLiteral - 136))
      | (1ULL << (ExpressParser::IntegerLiteral - 136))
      | (1ULL << (ExpressParser::RealLiteral - 136))
      | (1ULL << (ExpressParser::SimpleId - 136))
      | (1ULL << (ExpressParser::SimpleStringLiteral - 136)))) != 0)) {
      setState(1623);
      domainRule();
      setState(1624);
      match(ExpressParser::T__0);
      setState(1630);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhileControlContext ------------------------------------------------------------------

ExpressParser::WhileControlContext::WhileControlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ExpressParser::WhileControlContext::WHILE() {
  return getToken(ExpressParser::WHILE, 0);
}

ExpressParser::LogicalExpressionContext* ExpressParser::WhileControlContext::logicalExpression() {
  return getRuleContext<ExpressParser::LogicalExpressionContext>(0);
}


size_t ExpressParser::WhileControlContext::getRuleIndex() const {
  return ExpressParser::RuleWhileControl;
}

void ExpressParser::WhileControlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhileControl(this);
}

void ExpressParser::WhileControlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhileControl(this);
}


std::any ExpressParser::WhileControlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitWhileControl(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::WhileControlContext* ExpressParser::whileControl() {
  WhileControlContext *_localctx = _tracker.createInstance<WhileControlContext>(_ctx, getState());
  enterRule(_localctx, 392, ExpressParser::RuleWhileControl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1631);
    match(ExpressParser::WHILE);
    setState(1632);
    logicalExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WidthContext ------------------------------------------------------------------

ExpressParser::WidthContext::WidthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::NumericExpressionContext* ExpressParser::WidthContext::numericExpression() {
  return getRuleContext<ExpressParser::NumericExpressionContext>(0);
}


size_t ExpressParser::WidthContext::getRuleIndex() const {
  return ExpressParser::RuleWidth;
}

void ExpressParser::WidthContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWidth(this);
}

void ExpressParser::WidthContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWidth(this);
}


std::any ExpressParser::WidthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitWidth(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::WidthContext* ExpressParser::width() {
  WidthContext *_localctx = _tracker.createInstance<WidthContext>(_ctx, getState());
  enterRule(_localctx, 394, ExpressParser::RuleWidth);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1634);
    numericExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WidthSpecContext ------------------------------------------------------------------

ExpressParser::WidthSpecContext::WidthSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ExpressParser::WidthContext* ExpressParser::WidthSpecContext::width() {
  return getRuleContext<ExpressParser::WidthContext>(0);
}

tree::TerminalNode* ExpressParser::WidthSpecContext::FIXED() {
  return getToken(ExpressParser::FIXED, 0);
}


size_t ExpressParser::WidthSpecContext::getRuleIndex() const {
  return ExpressParser::RuleWidthSpec;
}

void ExpressParser::WidthSpecContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWidthSpec(this);
}

void ExpressParser::WidthSpecContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ExpressListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWidthSpec(this);
}


std::any ExpressParser::WidthSpecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<ExpressVisitor*>(visitor))
    return parserVisitor->visitWidthSpec(this);
  else
    return visitor->visitChildren(this);
}

ExpressParser::WidthSpecContext* ExpressParser::widthSpec() {
  WidthSpecContext *_localctx = _tracker.createInstance<WidthSpecContext>(_ctx, getState());
  enterRule(_localctx, 396, ExpressParser::RuleWidthSpec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1636);
    match(ExpressParser::T__1);
    setState(1637);
    width();
    setState(1638);
    match(ExpressParser::T__3);
    setState(1640);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ExpressParser::FIXED) {
      setState(1639);
      match(ExpressParser::FIXED);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

void ExpressParser::initialize() {
  std::call_once(expressParserOnceFlag, expressParserInitialize);
}
