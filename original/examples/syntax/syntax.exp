-- schema
SCHEMA syntax_schema 'version';

-- interfaces
USE FROM contract_schema;
USE FROM contract_schema (contract);
USE FROM contract_schema (contract AS contract2);
REFERENCE FROM contract_schema;
REFERENCE FROM contract_schema (contract);
REFERENCE FROM contract_schema (contract AS contract2);

-- constants
CONSTANT empty_constant : BOOLEAN := TRUE; END_CONSTANT;

-- types
TYPE empty_type = BOOLEAN; END_TYPE;
TYPE where_type = BOOLEAN; WHERE TRUE; END_TYPE;
TYPE where_label_type = BOOLEAN; WHERE WR1 : TRUE; END_TYPE;

-- entities
ENTITY empty_entity; END_ENTITY;
ENTITY abstract_entity ABSTRACT; END_ENTITY;
ENTITY abstract_supertype_entity ABSTRACT SUPERTYPE; END_ENTITY;
ENTITY abstract_supertype_constraint_entity ABSTRACT SUPERTYPE OF (empty_entity); END_ENTITY;
ENTITY supertype_constraint_entity SUPERTYPE OF (empty_entity); END_ENTITY;
ENTITY subtype_entity SUBTYPE OF (empty_entity); END_ENTITY;
ENTITY supertype_constraint_subtype_entity SUPERTYPE OF (empty_entity) SUBTYPE OF (empty_entity); END_ENTITY;
ENTITY attribute_entity; test : BOOLEAN; END_ENTITY;
ENTITY attribute_optional_entity; test : OPTIONAL BOOLEAN; END_ENTITY;
ENTITY attribute_multiple_entity; test : BOOLEAN; test2 : BOOLEAN; END_ENTITY;
ENTITY attribute_multiple_shorthand_entity; test, test2 : BOOLEAN; END_ENTITY;
ENTITY attribute_redeclared_entity; SELF\attribute_entity.test : BOOLEAN; END_ENTITY;
ENTITY attribute_redeclared_renamed_entity; SELF\attribute_entity.test RENAMED test2 : BOOLEAN; END_ENTITY;
ENTITY derived_attribute_entity; DERIVE test : BOOLEAN := TRUE; END_ENTITY;
ENTITY derived_attribute_redeclared_entity; DERIVE SELF\attribute_entity.test : BOOLEAN := TRUE; END_ENTITY;
ENTITY derived_attribute_redeclared_renamed_entity; DERIVE SELF\attribute_entity.test RENAMED test2 : BOOLEAN := TRUE; END_ENTITY;
ENTITY inverse_attribute_entity; INVERSE test : attribute_entity FOR test; END_ENTITY;
ENTITY inverse_attribute_entity_entity; INVERSE test : attribute_entity FOR attribute_entity.test; END_ENTITY;
ENTITY inverse_attribute_set_entity; INVERSE test : SET OF attribute_entity FOR test; END_ENTITY;
ENTITY inverse_attribute_set_bound_entity; INVERSE test : SET [1:9] OF attribute_entity FOR test; END_ENTITY;
ENTITY inverse_attribute_bag_entity; INVERSE test : BAG OF attribute_entity FOR test; END_ENTITY;
ENTITY inverse_attribute_bag_bound_entity; INVERSE test : BAG [1:9] OF attribute_entity FOR test; END_ENTITY;
ENTITY inverse_attribute_redeclared_entity; INVERSE SELF\attribute_entity.test : attribute_entity FOR test; END_ENTITY;
ENTITY inverse_attribute_redeclared_renamed_entity; INVERSE SELF\attribute_entity.test RENAMED test2 : attribute_entity FOR test; END_ENTITY;
ENTITY unique_entity; test : BOOLEAN; UNIQUE test; END_ENTITY;
ENTITY unique_label_entity; test : BOOLEAN; UNIQUE UR1 : test; END_ENTITY;
ENTITY unique_qualified_entity; UNIQUE SELF\attribute_entity.test; END_ENTITY;
ENTITY unique_label_qualified_entity; UNIQUE UR1 : SELF\attribute_entity.test; END_ENTITY;
ENTITY where_entity; WHERE TRUE; END_ENTITY;
ENTITY where_label_entity; WHERE WR1 : TRUE; END_ENTITY;

-- subtype constraints
SUBTYPE_CONSTRAINT empty_subtype_constraint FOR empty_entity; END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT abstract_supertype_subtype_constraint FOR empty_entity; ABSTRACT SUPERTYPE; END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT total_over_subtype_constraint FOR empty_entity; TOTAL_OVER(a); END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_subtype_constraint FOR empty_entity; a; END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_andor_subtype_constraint FOR empty_entity; a ANDOR b; END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_and_subtype_constraint FOR empty_entity; a AND b; END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_andor_and_subtype_constraint FOR empty_entity; a ANDOR b AND c; END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_and_andor_subtype_constraint FOR empty_entity; a AND b ANDOR c; END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_parenthesis_andor_and_subtype_constraint FOR empty_entity; (a ANDOR b) AND c; END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_and_parenthesis_andor_subtype_constraint FOR empty_entity; a AND (b ANDOR c); END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_oneof_subtype_constraint FOR empty_entity; ONEOF(a, b); END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_and_oneof_subtype_constraint FOR empty_entity; a AND ONEOF(b, c); END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_andor_oneof_subtype_constraint FOR empty_entity; a ANDOR ONEOF(b, c); END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_oneof_and_subtype_constraint FOR empty_entity; ONEOF(a, b) AND c; END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_oneof_andor_subtype_constraint FOR empty_entity; ONEOF(a, b) ANDOR c; END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_oneof_and_oneof_subtype_constraint FOR empty_entity; ONEOF(a, b) AND ONEOF(c, d); END_SUBTYPE_CONSTRAINT;
SUBTYPE_CONSTRAINT supertype_expression_oneof_andor_oneof_subtype_constraint FOR empty_entity; ONEOF(a, b) ANDOR ONEOF(c, d); END_SUBTYPE_CONSTRAINT;

-- functions
FUNCTION empty_function : BOOLEAN; ; END_FUNCTION;
FUNCTION parameter_function(test : BOOLEAN) : BOOLEAN; ; END_FUNCTION;
FUNCTION multiple_parameter_function(test : BOOLEAN; test2 : BOOLEAN) : BOOLEAN; ; END_FUNCTION;
FUNCTION multiple_shorthand_parameter_function(test, test2 : BOOLEAN) : BOOLEAN; ; END_FUNCTION;
FUNCTION type_function : BOOLEAN; TYPE test = BOOLEAN; END_TYPE; ; END_FUNCTION;
FUNCTION constant_function : BOOLEAN; CONSTANT test : BOOLEAN := TRUE; END_CONSTANT; ; END_FUNCTION;
FUNCTION multiple_constant_function : BOOLEAN; CONSTANT test : BOOLEAN := TRUE; test2 : BOOLEAN := TRUE; END_CONSTANT; ; END_FUNCTION;
FUNCTION variable_function : BOOLEAN; LOCAL test : BOOLEAN; END_LOCAL; ; END_FUNCTION;
FUNCTION multiple_variable_function : BOOLEAN; LOCAL test : BOOLEAN; test2 : BOOLEAN; END_LOCAL; ; END_FUNCTION;
FUNCTION multiple_shorthand_variable_function : BOOLEAN; LOCAL test, test2 : BOOLEAN; END_LOCAL; ; END_FUNCTION;
FUNCTION variable_expression_function : BOOLEAN; LOCAL test : BOOLEAN := TRUE; END_LOCAL; ; END_FUNCTION;
FUNCTION multiple_variable_expression_function : BOOLEAN; LOCAL test : BOOLEAN := TRUE; test2 : BOOLEAN := TRUE; END_LOCAL; ; END_FUNCTION;
FUNCTION multiple_shorthand_variable_expression_function : BOOLEAN; LOCAL test, test2 : BOOLEAN := TRUE; END_LOCAL; ; END_FUNCTION;

-- procedures
PROCEDURE empty_procedure; END_PROCEDURE;
PROCEDURE parameter_procedure(test : BOOLEAN); END_PROCEDURE;
PROCEDURE multiple_parameter_procedure(test : BOOLEAN; test2 : BOOLEAN); END_PROCEDURE;
PROCEDURE multiple_shorthand_parameter_procedure(test, test2 : BOOLEAN); END_PROCEDURE;
PROCEDURE variable_parameter_procedure(VAR test : BOOLEAN); END_PROCEDURE;
PROCEDURE multiple_variable_parameter_procedure(VAR test : BOOLEAN; test2 : BOOLEAN); END_PROCEDURE;
PROCEDURE multiple_variable_parameter2_procedure(test : BOOLEAN; VAR test2 : BOOLEAN); END_PROCEDURE;
PROCEDURE multiple_shorthand_variable_parameter_procedure(VAR test, test2 : BOOLEAN); END_PROCEDURE;
PROCEDURE type_procedure; TYPE test = BOOLEAN; END_TYPE; END_PROCEDURE;
PROCEDURE constant_procedure; CONSTANT test : BOOLEAN := TRUE; END_CONSTANT; END_PROCEDURE;
PROCEDURE multiple_constant_procedure; CONSTANT test : BOOLEAN := TRUE; test2 : BOOLEAN := TRUE; END_CONSTANT; END_PROCEDURE;
PROCEDURE variable_procedure; LOCAL test : BOOLEAN; END_LOCAL; END_PROCEDURE;
PROCEDURE multiple_variable_procedure; LOCAL test : BOOLEAN; test2 : BOOLEAN; END_LOCAL; END_PROCEDURE;
PROCEDURE multiple_shorthand_variable_procedure; LOCAL test, test2 : BOOLEAN; END_LOCAL; END_PROCEDURE;
PROCEDURE variable_expression_procedure; LOCAL test : BOOLEAN := TRUE; END_LOCAL; END_PROCEDURE;
PROCEDURE multiple_variable_expression_procedure; LOCAL test : BOOLEAN := TRUE; test2 : BOOLEAN := TRUE; END_LOCAL; END_PROCEDURE;
PROCEDURE multiple_shorthand_variable_expression_procedure; LOCAL test, test2 : BOOLEAN := TRUE; END_LOCAL; END_PROCEDURE;
PROCEDURE statement_procedure; ; END_PROCEDURE;

-- rules
RULE empty_rule FOR (empty_entity); WHERE TRUE; END_RULE;
RULE type_rule FOR (empty_entity); TYPE test = BOOLEAN; END_TYPE; WHERE TRUE; END_RULE;
RULE constant_rule FOR (empty_entity); CONSTANT test : BOOLEAN := TRUE; END_CONSTANT; WHERE TRUE; END_RULE;
RULE multiple_constant_rule FOR (empty_entity); CONSTANT test : BOOLEAN := TRUE; test2 : BOOLEAN := TRUE; END_CONSTANT; WHERE TRUE; END_RULE;
RULE variable_rule FOR (empty_entity); LOCAL test : BOOLEAN; END_LOCAL; WHERE TRUE; END_RULE;
RULE multiple_variable_rule FOR (empty_entity); LOCAL test : BOOLEAN; test2 : BOOLEAN; END_LOCAL; WHERE TRUE; END_RULE;
RULE multiple_shorthand_variable_rule FOR (empty_entity); LOCAL test, test2 : BOOLEAN; END_LOCAL; WHERE TRUE; END_RULE;
RULE variable_expression_rule FOR (empty_entity); LOCAL test : BOOLEAN := TRUE; END_LOCAL; WHERE TRUE; END_RULE;
RULE multiple_variable_expression_rule FOR (empty_entity); LOCAL test : BOOLEAN := TRUE; test2 : BOOLEAN := TRUE; END_LOCAL; WHERE TRUE; END_RULE;
RULE multiple_shorthand_variable_expression_rule FOR (empty_entity); LOCAL test, test2 : BOOLEAN := TRUE; END_LOCAL; WHERE TRUE; END_RULE;
RULE statement_rule FOR (empty_entity); ; WHERE TRUE; END_RULE;
RULE where_label_rule FOR (empty_entity); WHERE WR1 : TRUE; END_RULE;

-- simple types
TYPE binary_type = BINARY; END_TYPE;
TYPE binary_width_type = BINARY (3); END_TYPE;
TYPE binary_width_fixed_type = BINARY (3) FIXED; END_TYPE;
TYPE boolean_type = BOOLEAN; END_TYPE;
TYPE integer_type = INTEGER; END_TYPE;
TYPE logical_type = LOGICAL; END_TYPE;
TYPE number_type = NUMBER; END_TYPE;
TYPE real_type = REAL; END_TYPE;
TYPE real_precision_type = REAL (3); END_TYPE;
TYPE string_type = STRING; END_TYPE;
TYPE string_width_type = STRING (3); END_TYPE;
TYPE string_width_fixed_type = STRING (3) FIXED; END_TYPE;

-- aggregation types
TYPE array_type = ARRAY [1:9] OF STRING; END_TYPE;
TYPE array_optional_type = ARRAY [1:9] OF OPTIONAL STRING; END_TYPE;
TYPE array_unique_type = ARRAY [1:9] OF UNIQUE STRING; END_TYPE;
TYPE array_optional_unique_type = ARRAY [1:9] OF OPTIONAL UNIQUE STRING; END_TYPE;
TYPE bag_type = BAG OF STRING; END_TYPE;
TYPE bag_bound_type = BAG [1:9] OF STRING; END_TYPE;
TYPE list_type = LIST OF STRING; END_TYPE;
TYPE list_bound_type = LIST [1:9] OF STRING; END_TYPE;
TYPE list_unique_type = LIST OF UNIQUE STRING; END_TYPE;
TYPE list_bound_unique_type = LIST [1:9] OF UNIQUE STRING; END_TYPE;
TYPE set_type = SET OF STRING; END_TYPE;
TYPE set_bound_type = SET [1:9] OF STRING; END_TYPE;

-- constructed types
TYPE select_type = SELECT; END_TYPE;
TYPE select_extensible_type = EXTENSIBLE SELECT; END_TYPE;
TYPE select_extensible_generic_entity_type = EXTENSIBLE GENERIC_ENTITY SELECT; END_TYPE;
TYPE select_list_type = SELECT (empty_type); END_TYPE;
TYPE select_extension_type_ref_type = SELECT BASED_ON select_type; END_TYPE;
TYPE select_extension_type_ref_list_type = SELECT BASED_ON select_type WITH (empty_type); END_TYPE;
TYPE enumeration_type = ENUMERATION; END_TYPE;
TYPE enumeration_extensible_type = EXTENSIBLE ENUMERATION; END_TYPE;
TYPE enumeration_list_type = ENUMERATION OF (test); END_TYPE;
TYPE enumeration_extension_type_ref_type = ENUMERATION BASED_ON enumeration_type; END_TYPE;
TYPE enumeration_extension_type_ref_list_type = ENUMERATION BASED_ON enumeration_type WITH (test); END_TYPE;

-- statements
FUNCTION alias_simple_reference_statement : BOOLEAN; ALIAS test FOR test; ; END_ALIAS; END_FUNCTION;
FUNCTION alias_attribute_reference_statement : BOOLEAN; ALIAS test FOR test.test; ; END_ALIAS; END_FUNCTION;
FUNCTION alias_group_reference_statement : BOOLEAN; ALIAS test FOR test\test; ; END_ALIAS; END_FUNCTION;
FUNCTION alias_index_reference_statement : BOOLEAN; ALIAS test FOR test[1]; ; END_ALIAS; END_FUNCTION;
FUNCTION alias_index2_reference_statement : BOOLEAN; ALIAS test FOR test[1:9]; ; END_ALIAS; END_FUNCTION;
FUNCTION assignment_simple_reference_statement : BOOLEAN; test := TRUE; END_FUNCTION;
FUNCTION assignment_attribute_reference_statement : BOOLEAN; test.test := TRUE; END_FUNCTION;
FUNCTION assignment_group_reference_statement : BOOLEAN; test\test := TRUE; END_FUNCTION;
FUNCTION assignment_index_reference_statement : BOOLEAN; test[1] := TRUE; END_FUNCTION;
FUNCTION assignment_index2_reference_statement : BOOLEAN; test[1:9] := TRUE; END_FUNCTION;
FUNCTION case_statement : BOOLEAN; CASE test OF TRUE : ; END_CASE; END_FUNCTION;
FUNCTION case_multiple_statement : BOOLEAN; CASE test OF TRUE : ; TRUE : ; END_CASE; END_FUNCTION;
FUNCTION case_multiple_shorthand_statement : BOOLEAN; CASE test OF TRUE, TRUE : ; END_CASE; END_FUNCTION;
FUNCTION case_otherwise_statement : BOOLEAN; CASE test OF TRUE : ; OTHERWISE : ; END_CASE; END_FUNCTION;
FUNCTION compound_statement : BOOLEAN; BEGIN ; END; END_FUNCTION;
FUNCTION escape_statement : BOOLEAN; ESCAPE; END_FUNCTION;
FUNCTION if_statement : BOOLEAN; IF TRUE THEN ; END_IF; END_FUNCTION;
FUNCTION if2_statement : BOOLEAN; IF TRUE THEN ; ; END_IF; END_FUNCTION;
FUNCTION if_else_statement : BOOLEAN; IF TRUE THEN ; ELSE ; END_IF; END_FUNCTION;
FUNCTION if2_else_statement : BOOLEAN; IF TRUE THEN ; ; ELSE ; END_IF; END_FUNCTION;
FUNCTION if_else2_statement : BOOLEAN; IF TRUE THEN ; ELSE ; ; END_IF; END_FUNCTION;
FUNCTION if2_else2_statement : BOOLEAN; IF TRUE THEN ; ; ELSE ; ; END_IF; END_FUNCTION;
FUNCTION null_statement : BOOLEAN; ; END_FUNCTION;
FUNCTION call_statement : BOOLEAN; empty_procedure; END_FUNCTION;
FUNCTION call_parameter_statement : BOOLEAN; empty_procedure(TRUE); END_FUNCTION;
FUNCTION call_parameter2_statement : BOOLEAN; empty_procedure(TRUE, TRUE); END_FUNCTION;
FUNCTION call_insert_statement : BOOLEAN; INSERT(TRUE); END_FUNCTION;
FUNCTION call_remove_statement : BOOLEAN; REMOVE(TRUE); END_FUNCTION;
FUNCTION repeat_statement : BOOLEAN; REPEAT; ; END_REPEAT; END_FUNCTION;
FUNCTION repeat_variable_statement : BOOLEAN; REPEAT test := 1 TO 9; ; END_REPEAT; END_FUNCTION;
FUNCTION repeat_variable_increment_statement : BOOLEAN; REPEAT test := 1 TO 9 BY 2; ; END_REPEAT; END_FUNCTION;
FUNCTION repeat_while_statement : BOOLEAN; REPEAT WHILE TRUE; ; END_REPEAT; END_FUNCTION;
FUNCTION repeat_until_statement : BOOLEAN; REPEAT UNTIL TRUE; ; END_REPEAT; END_FUNCTION;
FUNCTION return_statement : BOOLEAN; RETURN; END_FUNCTION;
FUNCTION return_expression_statement : BOOLEAN; RETURN (TRUE); END_FUNCTION;
FUNCTION skip_statement : BOOLEAN; SKIP; END_FUNCTION;

-- literal expressions
FUNCTION binary_expression : BOOLEAN; RETURN (%011110000111100001111000); END_FUNCTION;
FUNCTION integer_expression : BOOLEAN; RETURN (999); END_FUNCTION;
FUNCTION true_logical_expression : BOOLEAN; RETURN (TRUE); END_FUNCTION;
FUNCTION false_logical_expression : BOOLEAN; RETURN (FALSE); END_FUNCTION;
FUNCTION unknown_logical_expression : BOOLEAN; RETURN (UNKNOWN); END_FUNCTION;
FUNCTION real_expression : BOOLEAN; RETURN (999.999); END_FUNCTION;
FUNCTION simple_string_expression : BOOLEAN; RETURN ('xxx'); END_FUNCTION;
FUNCTION utf8_simple_string_expression : BOOLEAN; RETURN ('UTF8 test: Příliš žluťoučký kůň úpěl ďábelské ódy.'); END_FUNCTION;
FUNCTION encoded_string_expression : BOOLEAN; RETURN ("000000780000007800000078"); END_FUNCTION;

-- constant expressions
FUNCTION const_e_expression : BOOLEAN; RETURN (CONST_E); END_FUNCTION;
FUNCTION indeterminate_expression : BOOLEAN; RETURN (?); END_FUNCTION;
FUNCTION pi_expression : BOOLEAN; RETURN (PI); END_FUNCTION;
FUNCTION self_expression : BOOLEAN; RETURN (SELF); END_FUNCTION;

-- function expressions
FUNCTION abs_expression : BOOLEAN; RETURN (ABS(TRUE)); END_FUNCTION;
FUNCTION acos_expression : BOOLEAN; RETURN (ACOS(TRUE)); END_FUNCTION;
FUNCTION asin_expression : BOOLEAN; RETURN (ASIN(TRUE)); END_FUNCTION;
FUNCTION atan_expression : BOOLEAN; RETURN (ATAN(TRUE)); END_FUNCTION;
FUNCTION blength_expression : BOOLEAN; RETURN (BLENGTH(TRUE)); END_FUNCTION;
FUNCTION cos_expression : BOOLEAN; RETURN (COS(TRUE)); END_FUNCTION;
FUNCTION exists_expression : BOOLEAN; RETURN (EXISTS(TRUE)); END_FUNCTION;
FUNCTION exp_expression : BOOLEAN; RETURN (EXP(TRUE)); END_FUNCTION;
FUNCTION format_expression : BOOLEAN; RETURN (FORMAT(TRUE)); END_FUNCTION;
FUNCTION hibound_expression : BOOLEAN; RETURN (HIBOUND(TRUE)); END_FUNCTION;
FUNCTION hiindex_expression : BOOLEAN; RETURN (HIINDEX(TRUE)); END_FUNCTION;
FUNCTION length_expression : BOOLEAN; RETURN (LENGTH(TRUE)); END_FUNCTION;
FUNCTION lobound_expression : BOOLEAN; RETURN (LOBOUND(TRUE)); END_FUNCTION;
FUNCTION loindex_expression : BOOLEAN; RETURN (LOINDEX(TRUE)); END_FUNCTION;
FUNCTION log_expression : BOOLEAN; RETURN (LOG(TRUE)); END_FUNCTION;
FUNCTION log2_expression : BOOLEAN; RETURN (LOG2(TRUE)); END_FUNCTION;
FUNCTION log10_expression : BOOLEAN; RETURN (LOG10(TRUE)); END_FUNCTION;
FUNCTION nvl_expression : BOOLEAN; RETURN (NVL(TRUE)); END_FUNCTION;
FUNCTION odd_expression : BOOLEAN; RETURN (ODD(TRUE)); END_FUNCTION;
FUNCTION rolesof_expression : BOOLEAN; RETURN (ROLESOF(TRUE)); END_FUNCTION;
FUNCTION sin_expression : BOOLEAN; RETURN (SIN(TRUE)); END_FUNCTION;
FUNCTION sizeof_expression : BOOLEAN; RETURN (SIZEOF(TRUE)); END_FUNCTION;
FUNCTION sqrt_expression : BOOLEAN; RETURN (SQRT(TRUE)); END_FUNCTION;
FUNCTION tan_expression : BOOLEAN; RETURN (TAN(TRUE)); END_FUNCTION;
FUNCTION typeof_expression : BOOLEAN; RETURN (TYPEOF(TRUE)); END_FUNCTION;
FUNCTION usedin_expression : BOOLEAN; RETURN (USEDIN(TRUE)); END_FUNCTION;
FUNCTION value_expression : BOOLEAN; RETURN (VALUE(TRUE)); END_FUNCTION;
FUNCTION value_in_expression : BOOLEAN; RETURN (VALUE_IN(TRUE)); END_FUNCTION;
FUNCTION value_unique_expression : BOOLEAN; RETURN (VALUE_UNIQUE(TRUE)); END_FUNCTION;

-- operator expressions
FUNCTION plus_expression : BOOLEAN; RETURN (+4); END_FUNCTION;
FUNCTION plus_addition_expression : BOOLEAN; RETURN (+(4 + 2)); END_FUNCTION;
FUNCTION minus_expression : BOOLEAN; RETURN (-4); END_FUNCTION;
FUNCTION minus_addition_expression : BOOLEAN; RETURN (-(4 + 2)); END_FUNCTION;
FUNCTION addition_expression : BOOLEAN; RETURN (4 + 2); END_FUNCTION;
FUNCTION subtraction_expression : BOOLEAN; RETURN (4 - 2); END_FUNCTION;
FUNCTION multiplication_expression : BOOLEAN; RETURN (4 * 2); END_FUNCTION;
FUNCTION real_division_expression : BOOLEAN; RETURN (4 / 2); END_FUNCTION;
FUNCTION integer_division_expression : BOOLEAN; RETURN (4 DIV 2); END_FUNCTION;
FUNCTION modulo_expression : BOOLEAN; RETURN (4 MOD 2); END_FUNCTION;
FUNCTION exponentiation_expression : BOOLEAN; RETURN (4 ** 2); END_FUNCTION;
FUNCTION addition_addition_expression : BOOLEAN; RETURN (4 + 2 + 1); END_FUNCTION;
FUNCTION subtraction_subtraction_expression : BOOLEAN; RETURN (4 - 2 - 1); END_FUNCTION;
FUNCTION addition_subtraction_expression : BOOLEAN; RETURN (4 + 2 - 1); END_FUNCTION;
FUNCTION subtraction_addition_expression : BOOLEAN; RETURN (4 - 2 + 1); END_FUNCTION;
FUNCTION addition_multiplication_expression : BOOLEAN; RETURN (8 + 4 * 2); END_FUNCTION;
FUNCTION multiplication_addition_expression : BOOLEAN; RETURN (8 * 4 + 2); END_FUNCTION;
FUNCTION parenthesis_addition_multiplication_expression : BOOLEAN; RETURN ((8 + 4) * 2); END_FUNCTION;
FUNCTION multiplication_parenthesis_addition_expression : BOOLEAN; RETURN (8 * (4 + 2)); END_FUNCTION;
FUNCTION equal_expression : BOOLEAN; RETURN (4 = 2); END_FUNCTION;
FUNCTION not_equal_expression : BOOLEAN; RETURN (4 <> 2); END_FUNCTION;
FUNCTION instance_equal_expression : BOOLEAN; RETURN (4 :=: 2); END_FUNCTION;
FUNCTION instance_not_equal_expression : BOOLEAN; RETURN (4 :<>: 2); END_FUNCTION;
FUNCTION lt_expression : BOOLEAN; RETURN (4 < 2); END_FUNCTION;
FUNCTION gt_expression : BOOLEAN; RETURN (4 > 2); END_FUNCTION;
FUNCTION lte_expression : BOOLEAN; RETURN (4 <= 2); END_FUNCTION;
FUNCTION gte_expression : BOOLEAN; RETURN (4 >= 2); END_FUNCTION;
FUNCTION not_expression : BOOLEAN; RETURN (NOT TRUE); END_FUNCTION;
FUNCTION not_or_expression : BOOLEAN; RETURN (NOT (TRUE OR FALSE)); END_FUNCTION;
FUNCTION or_expression : BOOLEAN; RETURN (TRUE OR FALSE); END_FUNCTION;
FUNCTION and_expression : BOOLEAN; RETURN (TRUE AND FALSE); END_FUNCTION;
FUNCTION or_or_expression : BOOLEAN; RETURN (TRUE OR FALSE OR TRUE); END_FUNCTION;
FUNCTION and_and_expression : BOOLEAN; RETURN (TRUE AND FALSE AND TRUE); END_FUNCTION;
FUNCTION or_and_expression : BOOLEAN; RETURN (TRUE OR FALSE AND TRUE); END_FUNCTION;
FUNCTION and_or_expression : BOOLEAN; RETURN (TRUE AND FALSE OR TRUE); END_FUNCTION;
FUNCTION parenthesis_or_and_expression : BOOLEAN; RETURN ((TRUE OR FALSE) AND TRUE); END_FUNCTION;
FUNCTION and_parenthesis_or_expression : BOOLEAN; RETURN (TRUE AND (FALSE OR TRUE)); END_FUNCTION;
FUNCTION combine_expression : BOOLEAN; RETURN (test || test); END_FUNCTION;
FUNCTION in_expression : BOOLEAN; RETURN (TRUE IN [TRUE]); END_FUNCTION;
FUNCTION like_expression : BOOLEAN; RETURN ('xxx' LIKE 'xxx'); END_FUNCTION;

-- aggregate initializer expressions
FUNCTION aggregate_initializer_expression : BOOLEAN; RETURN ([4]); END_FUNCTION;
FUNCTION repeated_aggregate_initializer_expression : BOOLEAN; RETURN ([4:2]); END_FUNCTION;
FUNCTION complex_aggregate_initializer_expression : BOOLEAN; RETURN ([4 + 2]); END_FUNCTION;
FUNCTION complex_repeated_aggregate_initializer_expression : BOOLEAN; RETURN ([4 + 2:4 + 2]); END_FUNCTION;

-- function call or entity constructor expressions
FUNCTION call_expression : BOOLEAN; RETURN (parameter_function(TRUE)); END_FUNCTION;

-- reference expressions
FUNCTION simple_reference_expression : BOOLEAN; RETURN (simple_string_expression); END_FUNCTION;
FUNCTION attribute_reference_expression : BOOLEAN; RETURN (simple_string_expression.test); END_FUNCTION;
FUNCTION group_reference_expression : BOOLEAN; RETURN (simple_string_expression\test); END_FUNCTION;
FUNCTION index_reference_expression : BOOLEAN; RETURN (simple_string_expression[1]); END_FUNCTION;
FUNCTION index2_reference_expression : BOOLEAN; RETURN (simple_string_expression[1:9]); END_FUNCTION;

-- interval expressions
FUNCTION lt_lt_interval_expression : BOOLEAN; RETURN ({1 < 5 < 9}); END_FUNCTION;
FUNCTION lte_lt_interval_expression : BOOLEAN; RETURN ({1 <= 5 < 9}); END_FUNCTION;
FUNCTION lt_lte_interval_expression : BOOLEAN; RETURN ({1 < 5 <= 9}); END_FUNCTION;
FUNCTION lte_lte_interval_expression : BOOLEAN; RETURN ({1 <= 5 <= 9}); END_FUNCTION;

-- query expressions
FUNCTION query_expression : BOOLEAN; RETURN (QUERY(test <* test2 | TRUE)); END_FUNCTION;
END_SCHEMA;
